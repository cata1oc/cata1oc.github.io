<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>《Linux内核源代码情景分析》笔记 | cataLoc's Blog</title><meta name="description" content="《Linux内核源代码情景分析》笔记"><meta name="keywords" content="Linux内核"><meta name="author" content="cataLoc"><meta name="copyright" content="cataLoc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Linux内核源代码情景分析》笔记"><meta name="twitter:description" content="《Linux内核源代码情景分析》笔记"><meta name="twitter:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/cover0x4A.png"><meta property="og:type" content="article"><meta property="og:title" content="《Linux内核源代码情景分析》笔记"><meta property="og:url" content="http://cata1oc.github.io/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="cataLoc's Blog"><meta property="og:description" content="《Linux内核源代码情景分析》笔记"><meta property="og:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/cover0x4A.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'true'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://cata1oc.github.io/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="prev" title="KCTF题库：异想天开" href="http://cata1oc.github.io/2021/10/22/KCTF%E9%A2%98%E5%BA%93-%E5%BC%82%E6%83%B3%E5%A4%A9%E5%BC%80/"><link rel="next" title="Arm-v8架构简介" href="http://cata1oc.github.io/2021/06/03/Armv8%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">cataLoc's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/Substitute.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">146</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#笔记"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">笔记</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#耐人寻味的do-while"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">耐人寻味的do-while</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#绕人的宿主结构体"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">绕人的宿主结构体</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Ubuntu的常规工具"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">Ubuntu的常规工具</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#LDT的设计初衷"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">LDT的设计初衷</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux中的段寄存器"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">Linux中的段寄存器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#卑微的段式保护机制"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">卑微的段式保护机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#段式存储管理的特殊系统调用"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">段式存储管理的特殊系统调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux中对页的管理"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">Linux中对页的管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#物理空间的均匀性"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">物理空间的均匀性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux中的映射内存"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">Linux中的映射内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux虚拟内存管理中数据结构间的联系"><span class="toc_mobile_items-number">2.11.</span> <span class="toc_mobile_items-text">Linux虚拟内存管理中数据结构间的联系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#页式存储管理机制下的越界访问"><span class="toc_mobile_items-number">2.12.</span> <span class="toc_mobile_items-text">页式存储管理机制下的越界访问</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#页面增长量计算"><span class="toc_mobile_items-number">2.13.</span> <span class="toc_mobile_items-text">页面增长量计算</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#文件操作函数表中的内存分配函数"><span class="toc_mobile_items-number">2.14.</span> <span class="toc_mobile_items-text">文件操作函数表中的内存分配函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#中断与异常的返回"><span class="toc_mobile_items-number">2.15.</span> <span class="toc_mobile_items-text">中断与异常的返回</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-2-5小结"><span class="toc_mobile_items-number">2.16.</span> <span class="toc_mobile_items-text">2.1~2.5小结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux内核对内存页面和盘上页面的管理"><span class="toc_mobile_items-number">2.17.</span> <span class="toc_mobile_items-text">Linux内核对内存页面和盘上页面的管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内存页面的周转"><span class="toc_mobile_items-number">2.18.</span> <span class="toc_mobile_items-text">内存页面的周转</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#物理内存页面换入-换出的周转要点"><span class="toc_mobile_items-number">2.19.</span> <span class="toc_mobile_items-text">物理内存页面换入&#x2F;换出的周转要点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#物理内存页面换入-换出的周转实现"><span class="toc_mobile_items-number">2.20.</span> <span class="toc_mobile_items-text">物理内存页面换入&#x2F;换出的周转实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多重身份的address-sapce"><span class="toc_mobile_items-number">2.21.</span> <span class="toc_mobile_items-text">多重身份的address_sapce</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#连续空间与不连续空间的alloc-pages"><span class="toc_mobile_items-number">2.22.</span> <span class="toc_mobile_items-text">连续空间与不连续空间的alloc_pages()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#kswapd"><span class="toc_mobile_items-number">2.23.</span> <span class="toc_mobile_items-text">kswapd</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#kernel-thread"><span class="toc_mobile_items-number">2.24.</span> <span class="toc_mobile_items-text">kernel_thread()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#kswapd-每秒一次的例行路线会做些什么？"><span class="toc_mobile_items-number">2.25.</span> <span class="toc_mobile_items-text">kswapd() 每秒一次的例行路线会做些什么？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#系统可供分配或周转的物理页面检查"><span class="toc_mobile_items-number">2.26.</span> <span class="toc_mobile_items-text">系统可供分配或周转的物理页面检查</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内核对进程虚存空间的管理"><span class="toc_mobile_items-number">2.27.</span> <span class="toc_mobile_items-text">内核对进程虚存空间的管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#系统调用-mmap"><span class="toc_mobile_items-number">2.28.</span> <span class="toc_mobile_items-text">系统调用 mmap()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考资料"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#笔记"><span class="toc-number">2.</span> <span class="toc-text">笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#耐人寻味的do-while"><span class="toc-number">2.1.</span> <span class="toc-text">耐人寻味的do-while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绕人的宿主结构体"><span class="toc-number">2.2.</span> <span class="toc-text">绕人的宿主结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ubuntu的常规工具"><span class="toc-number">2.3.</span> <span class="toc-text">Ubuntu的常规工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LDT的设计初衷"><span class="toc-number">2.4.</span> <span class="toc-text">LDT的设计初衷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux中的段寄存器"><span class="toc-number">2.5.</span> <span class="toc-text">Linux中的段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卑微的段式保护机制"><span class="toc-number">2.6.</span> <span class="toc-text">卑微的段式保护机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#段式存储管理的特殊系统调用"><span class="toc-number">2.7.</span> <span class="toc-text">段式存储管理的特殊系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux中对页的管理"><span class="toc-number">2.8.</span> <span class="toc-text">Linux中对页的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理空间的均匀性"><span class="toc-number">2.9.</span> <span class="toc-text">物理空间的均匀性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux中的映射内存"><span class="toc-number">2.10.</span> <span class="toc-text">Linux中的映射内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux虚拟内存管理中数据结构间的联系"><span class="toc-number">2.11.</span> <span class="toc-text">Linux虚拟内存管理中数据结构间的联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页式存储管理机制下的越界访问"><span class="toc-number">2.12.</span> <span class="toc-text">页式存储管理机制下的越界访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面增长量计算"><span class="toc-number">2.13.</span> <span class="toc-text">页面增长量计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件操作函数表中的内存分配函数"><span class="toc-number">2.14.</span> <span class="toc-text">文件操作函数表中的内存分配函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断与异常的返回"><span class="toc-number">2.15.</span> <span class="toc-text">中断与异常的返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-5小结"><span class="toc-number">2.16.</span> <span class="toc-text">2.1~2.5小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux内核对内存页面和盘上页面的管理"><span class="toc-number">2.17.</span> <span class="toc-text">Linux内核对内存页面和盘上页面的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存页面的周转"><span class="toc-number">2.18.</span> <span class="toc-text">内存页面的周转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理内存页面换入-换出的周转要点"><span class="toc-number">2.19.</span> <span class="toc-text">物理内存页面换入&#x2F;换出的周转要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理内存页面换入-换出的周转实现"><span class="toc-number">2.20.</span> <span class="toc-text">物理内存页面换入&#x2F;换出的周转实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重身份的address-sapce"><span class="toc-number">2.21.</span> <span class="toc-text">多重身份的address_sapce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连续空间与不连续空间的alloc-pages"><span class="toc-number">2.22.</span> <span class="toc-text">连续空间与不连续空间的alloc_pages()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kswapd"><span class="toc-number">2.23.</span> <span class="toc-text">kswapd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel-thread"><span class="toc-number">2.24.</span> <span class="toc-text">kernel_thread()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kswapd-每秒一次的例行路线会做些什么？"><span class="toc-number">2.25.</span> <span class="toc-text">kswapd() 每秒一次的例行路线会做些什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统可供分配或周转的物理页面检查"><span class="toc-number">2.26.</span> <span class="toc-text">系统可供分配或周转的物理页面检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核对进程虚存空间的管理"><span class="toc-number">2.27.</span> <span class="toc-text">内核对进程虚存空间的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用-mmap"><span class="toc-number">2.28.</span> <span class="toc-text">系统调用 mmap()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/cover0x4A.png)"><div id="post-info"><div id="post-title"><div class="posttitle">《Linux内核源代码情景分析》笔记</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2021-07-02<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2022-05-17</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原计划在7月份写一些与Linux内核相关的博客，6月份就都在看这方面的书了，问轩辕大哥要了份资源，其中一本就是毛德操老师的《Linux内核源代码情景分析》，在学习 Windows 内核时就曾久仰毛德操老师的大名，这本书确实不错，但在读完存储管理这一章后，我就放弃了，内容非常深入，但不结合代码一点点看，显然是读不明白的，另一方面，鉴于这是2001年就出版的基于2.4版本的 Linux 内核的书，属实有些旧了。同样经典的 ULK，LDD 以及红宝书，均是基于2.6版本 Linux 内核。</p>
<p>经过一个周末的筛选，接下来会选择红宝书（3本书中翻译的较为好的一本，另外2本不想去看英文原版）作为主要资料进行学习。并会从7月初开始，根据所学进度逐步更新 Linux 内核知识点。</p>
<p>本篇主要是先前阅读《Linux内核源代码情景分析》时记录下的我认为比较重要或者构思巧妙的点（主要是存储管理这一章节的内容）。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="耐人寻味的do-while"><a href="#耐人寻味的do-while" class="headerlink" title="耐人寻味的do-while"></a>耐人寻味的do-while</h3><p>参考P17~18，这个宏操作为什么要通过一个do-while循环来定义呢？</p>
<p><code>#define DUMP_WRITE(addr,nr) do { memcpy(bufp,addr,nr); bufp += nr; } while(0)</code></p>
<h3 id="绕人的宿主结构体"><a href="#绕人的宿主结构体" class="headerlink" title="绕人的宿主结构体"></a>绕人的宿主结构体</h3><p>参考P21中rmqueue()的例子，如何通过结构体中的字段，算出宿主结构体的地址。</p>
<p><code>((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))</code></p>
<h3 id="Ubuntu的常规工具"><a href="#Ubuntu的常规工具" class="headerlink" title="Ubuntu的常规工具"></a>Ubuntu的常规工具</h3><ul>
<li>gcc：编译</li>
<li>objdump：反汇编</li>
</ul>
<h3 id="LDT的设计初衷"><a href="#LDT的设计初衷" class="headerlink" title="LDT的设计初衷"></a>LDT的设计初衷</h3><p>参考P37，Intel的设计意图是内核用GDT而各个进程都用其自己的LDT。但实际上，不光Windows内核不用LDT，Linux内核也不怎么用（除了运行wine或其它模拟运行Windows软件时才使用）。</p>
<h3 id="Linux中的段寄存器"><a href="#Linux中的段寄存器" class="headerlink" title="Linux中的段寄存器"></a>Linux中的段寄存器</h3><p>参考P38，虽然Intel的意图是将一个进程的映像分成代码段、数据段和堆栈段，Linux内核却并不买这个帐。在Linux内核中堆栈段和数据段是不分的。</p>
<h3 id="卑微的段式保护机制"><a href="#卑微的段式保护机制" class="headerlink" title="卑微的段式保护机制"></a>卑微的段式保护机制</h3><p>参考P40，要不是 i386 CPU中的 MMU 规定先作段式映射，然后才可以作页式映射，那就根本不需要段描述符和段寄存器了。所以，这里 Linux 内核只不过是装模做样地糊弄 i386 CPU，对付其检查比对而已。</p>
<h3 id="段式存储管理的特殊系统调用"><a href="#段式存储管理的特殊系统调用" class="headerlink" title="段式存储管理的特殊系统调用"></a>段式存储管理的特殊系统调用</h3><p>参考P43，<code>modify_ldt(int func, void \*ptr, unsigned bytecount)</code>，用来实现WINE（<strong>WIN</strong>dows <strong>E</strong>mulation）的系统调用，可以改变当前进程的<strong>局部</strong>段描述符表，也就有办法侵犯到其它进程或内核的空间中去。一方面它确实是在内存管理机制上开了一个小小的缺口，但另一方面它的背后仍然是 Linux 内核的页式存储管理，只要不让用户进程掌握修改页面目录和页面表的手段，系统就还是安全的。</p>
<h3 id="Linux中对页的管理"><a href="#Linux中对页的管理" class="headerlink" title="Linux中对页的管理"></a>Linux中对页的管理</h3><p>参考P45~49，内核中有个全局变量 mem_map，是一个指针，指向一个 page 数据结构的数组（物理页面的仓库），每个 page 数据结构代表着一个物理页面，整个数组就代表着系统中的全部物理页面。这个 mem_map 相当于 Windows 系统中一个记录所有物理页信息的全局数组的指针 <a href="https://cataloc.gitee.io/blog/2020/09/03/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E7%AE%A1%E7%90%86/#%E7%A9%BA%E9%97%B2%E9%A1%B5%E7%9A%84%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">MmPfnDatabase</a>。</p>
<p>”仓库“中有管理区（常规的2个管理区：ZONE_DMA, ZONE_NORAML；用于物理地址超过 1GB 存储空间的管理区：ZONE_HIGHMEM）的概念，不同于 Windows 中的空闲页与活动状态页。</p>
<h3 id="物理空间的均匀性"><a href="#物理空间的均匀性" class="headerlink" title="物理空间的均匀性"></a>物理空间的均匀性</h3><p>参考P49，均质存储结构（<strong>U</strong>niform <strong>M</strong>emory <strong>A</strong>rchitecture），是一种理想化的物理空间结构，即CPU访问这个空间中的任何一个地址所需的时间都相同。随着非均质存储结构的引入（<strong>N</strong>on-<strong>U</strong>niform <strong>M</strong>emory <strong>A</strong>rchitecture）物理页面管理机制也作了相应的修正。管理区不再是属于最高层的机构，而是在每个存储节点中都有至少两个管理区。而且 page 结构数组（mem_map）也不再是全局性的，而是从属于具体的节点了。从而，在 zone_struct 结构（以及 page 结构数组）之上又有了另一层代表着存储节点的 pglist_data 数据结构。</p>
<h3 id="Linux中的映射内存"><a href="#Linux中的映射内存" class="headerlink" title="Linux中的映射内存"></a>Linux中的映射内存</h3><p>参考P52，有两种情况下虚存页面会跟磁盘文件发生关系。一种是盘区交换（swap），参考缺页异常的处理流程。另一种情况则是将一个磁盘文件映射到一个进程的用户空间中。Linux 提供了一个系统调用 mmap()，使一个进程可以将一个已经打开的文件映射到其用户空间中，此后就可以像访问内存中一个字符数组那样来访问这个文件的内容，而不必通过 leek()、read() 或 write() 等进行文件操作。这部分内容类似 Windows 中的<a href="https://cataloc.gitee.io/blog/2020/09/01/Mapped-Memory/" target="_blank" rel="noopener">映射内存</a>。</p>
<h3 id="Linux虚拟内存管理中数据结构间的联系"><a href="#Linux虚拟内存管理中数据结构间的联系" class="headerlink" title="Linux虚拟内存管理中数据结构间的联系"></a>Linux虚拟内存管理中数据结构间的联系</h3><p>参考2.3 几个重要的数据结构和函数。这一节介绍了多个数据结构，mm_struct 和 vm_area_struct 说明了（进程）对页面的需求；page、zone_struct 等结构则说明了（物理内存）对页面的供应；而页面目录、中间目录以及页面表则是二者中间的桥梁。其关系如下所示：</p>
<a href="/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/vm_ds_relationship.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/vm_ds_relationship.png"></a>



<h3 id="页式存储管理机制下的越界访问"><a href="#页式存储管理机制下的越界访问" class="headerlink" title="页式存储管理机制下的越界访问"></a>页式存储管理机制下的越界访问</h3><p>参考2.4节 越界访问P57~P60，这一节简略的分析了 Linux 系统中对缺页异常的处理函数 <code>do_page_fault</code> 的执行流程，里面提到了一个 task_struct 结构，它是描述进程的数据结构，从它可以修改线程的 Cr2 的值来看，task_struct 结构有点类似 Windows 内核中的 EProcess 或 KProcess 结构体。</p>
<p>P59，提到关于 Linux 中越界的一个定义：回忆一下内核对用户虚存空间的使用，堆栈在用户区的顶部，从上向下伸展，而进程的代码和数据都是自底向上分配空间。如果没有一个区间的结束地址高于给定的地址，那就是说明这个地址是在堆栈之上，也就是 3G 字节以上。要从用户空间访问属于系统的空间，那当然是越界了。</p>
<p>同样是P59，关于空洞。在用户虚存空间中，可能有两种不同的空洞。第一种是堆栈区以下的那个大空洞，它代表着供动态分配（通过系统调用 brk() ）而仍未分配出去的空间；第二种我的理解就是缺页异常时，页内容被换出去，P=0，但PTE不为空的那种情况。在2.5节 用户堆栈的扩展这一节中，有对第一种情况异常处理的分析。</p>
<h3 id="页面增长量计算"><a href="#页面增长量计算" class="headerlink" title="页面增长量计算"></a>页面增长量计算</h3><p>参考P62，当发生缺页异常，原因是进程堆栈空间不足时（属于正常的堆栈扩展要求情况下），需要扩充堆栈。首先将地址按页面边界对齐，并计算需要增长几个页面才能把给定的地址包括进去（通常是一个）。这里的代码逻辑我很喜欢，特此记录下来：</p>
<p><code>grow = (vma->vm_start - address) >> PAGE_SHIFT;</code></p>
<h3 id="文件操作函数表中的内存分配函数"><a href="#文件操作函数表中的内存分配函数" class="headerlink" title="文件操作函数表中的内存分配函数"></a>文件操作函数表中的内存分配函数</h3><p>参考P66，在虚存区间结构 vm_area_struct 中有个指针 vm_ops，指向一个 vm_operations_struct 数据结构。这个数据结构实际上是一个函数跳转表，结构中通常是一些与文件操作有关的函数指针。其中有一个函数指针就是用于物理内存页面的分配。在这一节中，还涉及到对<strong>写保护</strong>部分代码实现的分析。</p>
<h3 id="中断与异常的返回"><a href="#中断与异常的返回" class="headerlink" title="中断与异常的返回"></a>中断与异常的返回</h3><p>参考P69，中断返回后，会从下一条指令开始执行；异常返回后，会重新执行导致异常的那条指令。</p>
<h3 id="2-1-2-5小结"><a href="#2-1-2-5小结" class="headerlink" title="2.1~2.5小结"></a>2.1~2.5小结</h3><p>参考P70，在系统的初始化阶段，内核根据检测到的物理内存的大小，为每一个页面都建立一个 page 结构，形成一个 page 结构的数组，并使一个全局变量 mem_map 指向这个数组。同时，又按需要将这些页面拼合成物理地址连续的许多内存页面”块“，再根据块的大小建立起若干”管理区“（zone），而在每个管理区中则设置一个空闲块队列，以便物理内存页面的分配使用。</p>
<h3 id="Linux内核对内存页面和盘上页面的管理"><a href="#Linux内核对内存页面和盘上页面的管理" class="headerlink" title="Linux内核对内存页面和盘上页面的管理"></a>Linux内核对内存页面和盘上页面的管理</h3><p>参考P70~73：</p>
<ul>
<li><p>swap_info_struct：内核中定义的数据结构，用以描述和管理用于页面交换的文件或设备。</p>
<ul>
<li>swap_map：指针，指向一个无符号短型数组；值代表盘上（或普通文件中）的一个物理页面，下标决定了该页面在盘上或文件中的位置。<ul>
<li>swap_map[0]：所代表的页面不用于页面交换，它包含了该设备或文件自身的一些信息以及一个表明哪些页面可供使用的位图。</li>
</ul>
</li>
<li>lowest_bit&highest_bit：供页面交换使用的范围区间。</li>
<li>max：该设备或文件中最大的页面号，即物理大小。</li>
</ul>
</li>
<li><p>swap_info：swap_info_struct 结构的数组。</p>
</li>
<li><p>swap_list：将各个可以分配物理页面的磁盘设备或文件的 swap_info_struct 结构按优先级高低链接在一起。</p>
</li>
<li><p>swp_entry_t：类似 pte_t</p>
<ul>
<li><p>offset：表示在一个磁盘设备或文件中的位置</p>
</li>
<li><p>type：指该页面在哪一个文件中，是个序号</p>
</li>
<li><p>0：相当于 pte_t 的最低位 P 标志。指明页面不在内存，在磁盘上。</p>
<a href="/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/swap_entry_t.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/swap_entry_t.png"></a>

</li>
</ul>
</li>
</ul>
<h3 id="内存页面的周转"><a href="#内存页面的周转" class="headerlink" title="内存页面的周转"></a>内存页面的周转</h3><p>参考P74，并非所有的内存页面都是可以交换出去的。事实上，只有映射到用户空间的页面才会被换出，而内核，即系统空间的页面则不在此列。</p>
<h3 id="物理内存页面换入-换出的周转要点"><a href="#物理内存页面换入-换出的周转要点" class="headerlink" title="物理内存页面换入/换出的周转要点"></a>物理内存页面换入/换出的周转要点</h3><p>参考P76：</p>
<ol>
<li>空闲。页面的 page 数据结构通过其队列头结构 list 链入某个页面管理区（zone）的空闲区队列 free_area。页面的使用计数 count 为0</li>
<li>分配。通过函数 _alloc_page() 或 __get_free_page() 从某个空闲队列中分配内存页面，并将所分配页面的使用计数 count 置成1，其 page 数据结构的队列头 list 结构则变成空闲。</li>
<li>活跃状态。页面的 page 数据结构通过其队列头结构 LRU 链入活跃页面队列 active_list，并且至少有一个进程的（用户空间）页面表项指向该页面。每当为页面建立或恢复映射时，都使页面的使用计数 count 加1。</li>
<li>不活跃状态（脏）。页面的 page 数据结构通过其队列头结构 LRU 链入不活跃 ”脏“ 页面队列 inactive_dirty_list，但是原则上不再有任何进程的页面表项指向该页面。每当断开页面的映射时都使页面的使用计数 count 减1。</li>
<li>将不活跃 ”脏“ 页面的内容写入交换设备，并将页面的 page 数据结构从不活跃 “脏” 页面队列 inactive_dirty_list 转移到某个不活跃 “干净” 页面队列中。</li>
<li>不活跃状态（干净）。页面的 page 数据结构通过其队列头结构 LRU 链入某个不活跃 “干净” 页面队列，<strong>每个页面管理区</strong>都有一个不活跃 “干净” 页面队列 inactive_clean_list。</li>
<li>如果在转入不活跃状态以后的一段时间内页面受到访问，则又转入活跃状态并恢复映射。</li>
<li>当有需要时，就从 “干净” 页面队列中回收页面，或退回到空闲队列中，或直接另行分配。</li>
</ol>
<h3 id="物理内存页面换入-换出的周转实现"><a href="#物理内存页面换入-换出的周转实现" class="headerlink" title="物理内存页面换入/换出的周转实现"></a>物理内存页面换入/换出的周转实现</h3><p>参考P77，为了实现这种策略，在 page 数据结构中设置了所需的各种成分，并在内核中设置了<strong>全局性</strong>的 active_list 和 inactive_dirty_list 两个 LRU 队列，还在每个<strong>页面管理区</strong>中设置了一个 inactive_clean_list。根据页面的 page 结构在这些 LRU 队列中的位置，就可以知道这个页面转入不活跃状态后时间的长短，为回收页面提供参考。同时，还通过一个全局的 address_space 数据结构 swapper_space，把所有可交换内存页面管理起来，每个可交换内存页面的 page 数据结构都通过其队列列头结构 list 链入其中的一个队列。此外，为加快在暂存队列中的搜索，又设置了一个哈希表 page_hash_table。</p>
<p>P78~80，通过分析 add_to_swap_cache() 的执行流程，介绍了内核是如何将一个内存页面链入上述队列的。不过该函数具体实现，还是和上述描述有些差别。</p>
<h3 id="多重身份的address-sapce"><a href="#多重身份的address-sapce" class="headerlink" title="多重身份的address_sapce"></a>多重身份的address_sapce</h3><p>参考P79，通常来自同一个文件的页面就通过一个 address_space 数据结构来管理，而代表着一个文件的 inode 数据结构中有个成分 i_data，那就是一个 address_space 数据结构。从这个意义上说，用来管理可交换页面的 address_space 数据结构 swapper_space 只是个特例。</p>
<h3 id="连续空间与不连续空间的alloc-pages"><a href="#连续空间与不连续空间的alloc-pages" class="headerlink" title="连续空间与不连续空间的alloc_pages()"></a>连续空间与不连续空间的alloc_pages()</h3><p>参考P82。可见，参数 gfp_mask 在这里用作给定节点中数组 node_zonelists[]的下标，决定具体的分配策略。在连续空间 UMA 结构中只有一个节点 contig_pape_data，而在 NUMA 结构或不连续空间 UMA 结构中则有多个。</p>
<h3 id="kswapd"><a href="#kswapd" class="headerlink" title="kswapd"></a>kswapd</h3><p>参考P93，Linux 内核中设置了一个专司定期将页面换出的 “守护神” kswapd。从原理上说，kswapd 相当于一个进程，有其自身的进程控制块 task_struct 结构，跟其它进程一样受内核的调度。而正因为内核将它按进程来调度，就可以让它在系统相对空闲的时候来运行。不过，与普通的进程相比，kswapd 还是有其特殊性。首先，它没有自己独立的地址空间，所以在近代操作系统理论中称为 “线程” （thread）以示区别。那么，kswapd 使用谁的地址空间呢？它使用的是内核的空间。在这一点上，它与中断服务程序相似。其次，它的代码是静态地连接在内核中的，可以直接调用内核中的各种子程序，而不像普通的进程那样只能通过系统调用，使用预先定义好的一组功能。</p>
<h3 id="kernel-thread"><a href="#kernel-thread" class="headerlink" title="kernel_thread()"></a>kernel_thread()</h3><p>参考P94，kernel_thread() 用来创建线程，例如 kswapd 和 kreclaimd 这两个线程：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(kswapd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);</span><br><span class="line">kernel_thread(kreclaimd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="kswapd-每秒一次的例行路线会做些什么？"><a href="#kswapd-每秒一次的例行路线会做些什么？" class="headerlink" title="kswapd() 每秒一次的例行路线会做些什么？"></a>kswapd() 每秒一次的例行路线会做些什么？</h3><p>参考P97：</p>
<ul>
<li>预先找出若干页面，且将这些页面的映射断开，使这些物理页面从活跃状态转入不活跃状态，为页面的换出作好准备。该功能只有在发现物理页面出现短缺时才会执行。</li>
<li>把已经处于不活跃状态的 “脏” 页面写入交换设备，使它们成为不活跃 “干净” 页面继续缓冲，或进一步回收一些这样的页面成为空闲页面。这个功能每次都会执行。</li>
</ul>
<h3 id="系统可供分配或周转的物理页面检查"><a href="#系统可供分配或周转的物理页面检查" class="headerlink" title="系统可供分配或周转的物理页面检查"></a>系统可供分配或周转的物理页面检查</h3><p>参考P97，系统中应该维持的物理页面供应量由两个全局变量确定，freepages.high 和 inactive_target，分别为空闲页面的数量和不活跃页面的数量，二者之和为正常情况下潜在的供应链。这些内存页面的来源有3个方面：</p>
<ul>
<li>nr_fress_pages() 统计的空闲页面，分散在各个页面管理区中，合并成地址连续的页面块形式存在。</li>
<li>nr_inactive_clean_pages() 统计的不活跃 “干净” 页面，也分散在各个页面管理区中，但不合并成块。</li>
<li>由内核中的一个全局变量队列 nr_inactive_dirty_pages 统计的不活跃的 “脏” 页面，使用前要先将内容写入交换设备。</li>
</ul>
<h3 id="内核对进程虚存空间的管理"><a href="#内核对进程虚存空间的管理" class="headerlink" title="内核对进程虚存空间的管理"></a>内核对进程虚存空间的管理</h3><p>参考P164，那么，内核怎样管理每个进程的 3G 字节虚存空间呢？粗略的说，用户程序经过编译、连接形成的映像文件中有一个代码段和一个数据段（包括 data 段和 bss 段），其中代码段在下，数据段在上。数据段中包含了所有静态分配的数据空间，包括全局变量和说明为 static 的局部变量。<strong>这些空间是进程所必须的基本要求</strong>，所以内核在建立一个进程的运行映像时就分配好这些空间，包括虚存地址空间和物理页面，并建立好二者间的映射。除此之外，<strong>堆栈使用的空间也属于基本要求</strong>，所以也是在建立进程时就分配好的（但可以扩充）。所不同的是，堆栈空间安置在虚存空间的顶部，运行时由顶向下延申；代码段和数据段则在底部，在运行时并不向上伸展。而从数据段的顶部 end_data 到堆栈段地址的下沿这个中间区域则是一个巨大的空洞，这就是可以在运行时动态分配的空间。最初，这个动态分配空间是从进程的 end_data 开始的，这个地址为内核和进程所共知。以后，每次动态分配一块 “内存”，这个边界就往上推进一段距离，同时内核和进程都要记下当前的边界在哪里。在进程这一边由 malloc() 或类似的库函数管理，而在内核中则将当前的边界记录在进程的 mm_struct 结构中。具体地说，mm_struct 结构中有一个成分 brk，表示动态分配区当前的底部。当一个进程需要分配内存时，将要求的大小与其当前的动态分配区底部边界相加，所得的就是所要求的新边界，也就是 brk() 调用时的参数 brk。当内核能满足要求时，系统调用 brk() 返回0，此后新旧两个边界之间的虚存地址就都可以使用了。当内核发现无法满足要求（例如物理空间已经分配完），或者发现新的边界已经过于逼近设于顶部的堆栈时，就拒绝分配而返回-1。</p>
<p>系统调用  brk() 在内核中的实现为 sys_brk()。这个函数既可以用来分配空间，即把动态分配区底部的边界往上推；也可以用来释放，即归还空间。</p>
<h3 id="系统调用-mmap"><a href="#系统调用-mmap" class="headerlink" title="系统调用 mmap()"></a>系统调用 mmap()</h3><p>参考P181，一个进程可以通过系统调用 mmap()， 将一个已打开文件的内容映射到它的用户空间，有点类似 Windows 上的 CreateFileMapping + MapViewOfFile 实现映射内存的过程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Linux内核源代码情景分析-上册》—— 毛德操/胡希明</li>
<li><a href="https://www.cnblogs.com/feng9exe/p/6879273.html" target="_blank" rel="noopener">博客园-虚拟内存映射：段分割</a></li>
</ul>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">cataLoc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://cata1oc.github.io/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">http://cata1oc.github.io/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E5%86%85%E6%A0%B8/">Linux内核    </a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/07/02/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/cover0x4A.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/10/22/KCTF%E9%A2%98%E5%BA%93-%E5%BC%82%E6%83%B3%E5%A4%A9%E5%BC%80/"><img class="prev_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/10/22/KCTF%E9%A2%98%E5%BA%93-%E5%BC%82%E6%83%B3%E5%A4%A9%E5%BC%80/cover0x4B.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>KCTF题库：异想天开</span></div></a></div><div class="next-post pull_right"><a href="/2021/06/03/Armv8%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/06/03/Armv8%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/cover0x49.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Arm-v8架构简介</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By cataLoc</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>