<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>堆基础02：malloc源码分析 | cataLoc's Blog</title><meta name="description" content="堆基础02：malloc源码分析"><meta name="keywords" content="二进制安全"><meta name="author" content="cataLoc"><meta name="copyright" content="cataLoc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="堆基础02：malloc源码分析"><meta name="twitter:description" content="堆基础02：malloc源码分析"><meta name="twitter:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0x60.png"><meta property="og:type" content="article"><meta property="og:title" content="堆基础02：malloc源码分析"><meta property="og:url" content="http://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="cataLoc's Blog"><meta property="og:description" content="堆基础02：malloc源码分析"><meta property="og:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0x60.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'true'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="prev" title="堆基础03：free源码分析" href="http://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="next" title="堆基础01：ptmalloc2初探" href="http://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">cataLoc's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/Substitute.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#源码调试"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">源码调试</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#libc-malloc-主流程"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">__libc_malloc 主流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#libc-malloc-辅助函数"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">__libc_malloc 辅助函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#checked-request2size"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">checked_request2size</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#csize2tidx"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">csize2tidx</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#MAYBE-INIT-TCACHE"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">MAYBE_INIT_TCACHE</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#tcache-get"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">tcache_get</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#chunk-is-mmapped"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">chunk_is_mmapped</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#chunk2mem-mem2chunk"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">chunk2mem &#x2F; mem2chunk</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#arena-get"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">arena_get</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#arena-get-retry"><span class="toc_mobile_items-number">4.8.</span> <span class="toc_mobile_items-text">arena_get_retry</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#int-malloc-主流程"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">_int_malloc 主流程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#初始校验"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">初始校验</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Fast-Bin-处理流程"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">Fast Bin 处理流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Small-Bin-处理流程"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">Small Bin 处理流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Unsorted-Bin-处理流程"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">Unsorted Bin 处理流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Large-Bin-处理流程"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">Large Bin 处理流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Top-Chunk-处理流程"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text">Top Chunk 处理流程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#int-malloc-辅助函数"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">_int_malloc 辅助函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考链接"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">参考链接</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码调试"><span class="toc-number">2.</span> <span class="toc-text">源码调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-malloc-主流程"><span class="toc-number">3.</span> <span class="toc-text">__libc_malloc 主流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-malloc-辅助函数"><span class="toc-number">4.</span> <span class="toc-text">__libc_malloc 辅助函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#checked-request2size"><span class="toc-number">4.1.</span> <span class="toc-text">checked_request2size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csize2tidx"><span class="toc-number">4.2.</span> <span class="toc-text">csize2tidx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MAYBE-INIT-TCACHE"><span class="toc-number">4.3.</span> <span class="toc-text">MAYBE_INIT_TCACHE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-get"><span class="toc-number">4.4.</span> <span class="toc-text">tcache_get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk-is-mmapped"><span class="toc-number">4.5.</span> <span class="toc-text">chunk_is_mmapped</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk2mem-mem2chunk"><span class="toc-number">4.6.</span> <span class="toc-text">chunk2mem &#x2F; mem2chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena-get"><span class="toc-number">4.7.</span> <span class="toc-text">arena_get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena-get-retry"><span class="toc-number">4.8.</span> <span class="toc-text">arena_get_retry</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-malloc-主流程"><span class="toc-number">5.</span> <span class="toc-text">_int_malloc 主流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始校验"><span class="toc-number">5.1.</span> <span class="toc-text">初始校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fast-Bin-处理流程"><span class="toc-number">5.2.</span> <span class="toc-text">Fast Bin 处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Small-Bin-处理流程"><span class="toc-number">5.3.</span> <span class="toc-text">Small Bin 处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsorted-Bin-处理流程"><span class="toc-number">5.4.</span> <span class="toc-text">Unsorted Bin 处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Bin-处理流程"><span class="toc-number">5.5.</span> <span class="toc-text">Large Bin 处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-Chunk-处理流程"><span class="toc-number">5.6.</span> <span class="toc-text">Top Chunk 处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-malloc-辅助函数"><span class="toc-number">6.</span> <span class="toc-text">_int_malloc 辅助函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0x60.png)"><div id="post-info"><div id="post-title"><div class="posttitle">堆基础02：malloc源码分析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2022-07-16<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2023-03-26</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>已经介绍了 ptmalloc2 的分配策略以及涉及到的主要数据结构，本篇将<strong>基于 glibc.2.31 源码</strong>，分析 <code>malloc</code>在源码中的具体实现。主要参考博客园上的<a href="https://www.cnblogs.com/luoleqi/p/15520621.html" target="_blank" rel="noopener">一篇</a>基于 glibc2.31的源码分析，以及看雪上<a href="https://bbs.pediy.com/thread-271316.htm" target="_blank" rel="noopener">一篇</a>基于 glibc2.23 的源码分析。分析过程与之前分析 AFL 源码一样，按照执行的先后顺序来。</p>
<h2 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h2><ol>
<li><p>按照<a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">官网</a>的方式下载安装</p>
</li>
<li><p>网速慢，可下载 zip 包后，解压到指定目录下，然后配置<code>~/.gdbinit</code>文件即可</p>
</li>
<li><p>要进行源码调试，需在<a href="https://ftp.gnu.org/gnu/glibc" target="_blank" rel="noopener">官网</a>下载对应版本的源码，然后在<code>~/.gdbinit</code>中配置源码所在路径，我这里只配置常用的源码</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/source_dbg_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/source_dbg_1.png"></a>
</li>
<li><p>配置完后，用 gdb 调试程序，<code>start</code> 启动后会在程序入口断下，单步（<code>si</code>指令）到库函数例如 malloc  中，就可以看到源码了，如下图所示</p>
</li>
<li><p>我这里直接在 vscode 的 terminal 中调试，没用 ubuntu 自带的 terminal，这样方便查看源码。尽管已经是源码调试，但 terminal 中只能看到源码片段，并不完整，所以还是需要有源码进行辅助</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_2.png"></a>




</li>
</ol>
<h2 id="libc-malloc-主流程"><a href="#libc-malloc-主流程" class="headerlink" title="__libc_malloc 主流程"></a>__libc_malloc 主流程</h2><ol>
<li><p>首先编写一个会使用到 malloc / free 的简单程序：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_1.png"></a>
</li>
<li><p>用 pwndbg 结合源码进行单步调试，<code>si</code>单步到 malloc 中，进入下图所示的状态</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_2.png"></a>

<ul>
<li>DISASM：反汇编窗口显示经过 .plt 表中的 stub 代码后，跳转到了 malloc 函数真正开始的地方 </li>
<li>SOURCE：源码窗口，可以看到目前位于 <code>__libc_malloc()</code> 函数的开始处</li>
<li>BACKTRACE：调用栈窗口显示，此时进入了 malloc 函数中执行</li>
</ul>
<p>综上，可以分析得出，在<strong>程序进入 malloc 函数后，最先执行的函数为 <code>__libc_malloc()</code></strong></p>
</li>
<li><p>接下来，开始分析 <code>__libc_malloc()</code>，这里会先分析主体流程，涉及到的其它函数与宏，会先简要概括，并在后文根据情况适当展开，我们先来看第一部分：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_3.png"></a>

<ul>
<li>mstate 类型对应的结构体是 malloc_state，其作用相当于 Arena Header</li>
<li>判断是否存在 __malloc_hook，若存在则调用该 hook 函数并返回。值得注意的是，在 2.34 版本中，malloc_hook 同其它大部分的 hook 都被删除了</li>
<li><code>atomic_forced_read(x)</code>这个宏的作用相当于 <code>*ptr</code>，只不过是原子操作</li>
<li>若开启了 tcache 机制（默认开启），则：<ul>
<li>调用 <code>checked_request2size()</code> 判断申请的空间大小是否超过边界。若未超过边界，则<strong>根据申请的大小计算出需要分配的 chunk 大小，该值保存在传入的 tbytes 参数中</strong></li>
<li>调用<code>csize2tidx()</code>根据 tbytes 中指定的 chunk 大小找到对应的 tcache bin 下标</li>
<li>若 tcache 还未创建，则通过宏<code>MAYBE_INIT_TCACHE</code>调用<code>tcache_init()</code>来初始化 tcache</li>
<li>接下来进行 3 项判断，若都满足，则调用<code>tcache_get()</code>返回对应大小的 chunk：<ol>
<li>先前计算出的下标是否在 tcache bins 范围内（这里的 mp_ 对应的结构体是 malloc_par）</li>
<li>tcache 是否存在</li>
<li>下标所对应的 tcache bin 中是否仍有空闲的 tcache chunk</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来分析<code>libc_malloc()</code>的第二部分：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_4.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_4.png"></a>

<ul>
<li>首先处理单线程的情况：<ul>
<li>调用<code>_int_malloc()</code>函数分配内存，该函数是内存分配的最核心函数，后面会对其进行分析。<ol>
<li>main_arena：由于是单线程，所以只有一个主分配区。其为 malloc_state 结构体，在第一次申请时可能值为 NULL，在<code>_int_malloc()</code>内部会对其进行初始化</li>
<li>bytes：也就是申请的字节数了，注意这里的 bytes 是外层在 malloc 中传入的申请的字节数，尚未转换成需要申请的 chunk 大小</li>
</ol>
</li>
<li>如果执行成功的话，就会返回一个指向内存的指针。本质上，这个指针<strong>指向分配的 chunk 中存放数据的首地址</strong>，也就是 chunkaddr + 2 * SIZE_SZ 的位置</li>
</ul>
</li>
<li>然后是多线程的情况：<ul>
<li>首先调用<code>arena_get()</code>获取分配区</li>
<li>然后通过<code>_int_malloc()</code>从该分配区中拿到分配给咱的内存地址</li>
<li><strong>如果成功获取分配区，但是分配内存失败，可能是 mmap 区域的内存耗尽等多种原因</strong>。所里会调用<code>arena_get_retry()</code>更换分配区，然后再调用<code>_int_malloc</code>从新的分配区上进行分配</li>
<li>前面两次无论是否分配成功，只要获取到了分配区，这里就会将线程锁释放。这个锁是在获取空闲分配区时加上的。在前面两次试图获取或者更换分配区时，会在不同情况下进行上锁，这个后面会讨论</li>
<li>最后将指向分配内存的指针返回给用户</li>
</ul>
</li>
</ul>
</li>
<li><p>至此，<code>__libc_malloc()</code>的主体流程分析完毕</p>
</li>
</ol>
<h2 id="libc-malloc-辅助函数"><a href="#libc-malloc-辅助函数" class="headerlink" title="__libc_malloc 辅助函数"></a>__libc_malloc 辅助函数</h2><p>这部分会对在分析<code>__libc_malloc()</code>时见到的几个关键的”函数 / 宏”展开分析，部分函数也在<code>_int_malloc()</code>中被调用，因为首次出现在<code>__libc_malloc()</code>中，所以放在此处分析，在后面分析<code>_int_malloc()</code>时也是如此</p>
<h3 id="checked-request2size"><a href="#checked-request2size" class="headerlink" title="checked_request2size"></a>checked_request2size</h3><ol>
<li><p>首先来看<code>checked_requeset2size()</code></p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_1.png"></a>

<ul>
<li>首先判断申请的内存大小是否超过了边界 PTRDIFF_MAX，这个在 64 位系统上是 0x7fffffffffffffff</li>
<li>如果符合要求，就调用<code>request2size()</code>这个宏，根据申请申请大小 req，计算出需要分配的 chunk 大小返回给 sz，并返回 true</li>
</ul>
</li>
<li><p>然后进入<code>request2size()</code>，这里涉及到的宏均已经列出，其中 SIZE_SZ，根据系统位数变化，64 位对应 8 字节，32 位对应 4 字节。<strong>我们默认环境是 64 位的，所以都以 8 字节进行计算</strong></p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_2.png"></a>

<ul>
<li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p>
</li>
<li><p>MALLOC_ALIGN_MASK 就是 15 字节，也就是 0xF</p>
</li>
<li><p>MIN_CHUNK_SIZE 是从 malloc_chunk 结构体开头，到 fd_nextsize 这个字段之前的大小，也就是 4个 SIZE_SZ，共 32 字节，即 0x20</p>
</li>
<li><p>MINSIZE 算出来也是 0x20 字节</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-> (<span class="number">0x20</span> + <span class="number">0xF</span>) & (~<span class="number">0x0F</span>)</span><br><span class="line">-> <span class="number">0x2F</span> & <span class="number">0xF0</span></span><br><span class="line">-> <span class="number">0x20</span></span><br></pre></td></tr></tbody></table></figure></div>
</li>
<li><p>最后计算出 <code>request2size()</code> 的两种情况：</p>
<ul>
<li>当申请的内存少于 25(0x19) 字节时，分配一个 0x20 大小的 chunk 块。这个值可以根据 malloc_chunk 结构体推算出，<strong>因为 fd & bk 这俩字段仅在 free_chunk 中有效，否则用于存放数据，并且当 chunk 被使用时，下一个 chunk 的 prev_size 字段也可以用于存放当前 chunk 的数据</strong>，这 3 个字段加起来就是 24 字节，因此，当申请的空间小于 25 字节时，一个最小 chunk （0x20）即可满足需求 </li>
<li>当大于等于 25(0x19) 字节时，就会计算出一个按照 0x10 对其的值，作为至少需要分配的 chunk 大小，具体算法参考下面的计算过程</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-> req + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE</span><br><span class="line">-> req + <span class="number">0x8</span> + <span class="number">0xF</span> < <span class="number">0x20</span></span><br><span class="line">-> req < <span class="number">0x20</span> - <span class="number">0x8</span> - <span class="number">0xF</span></span><br><span class="line">-> req < <span class="number">0x9</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 为方便理解，这里假设req是一个小于0xFF的数    </span></span><br><span class="line">-> (req + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK</span><br><span class="line">-> (req + <span class="number">0x8</span> + <span class="number">0xF</span>) & ~<span class="number">0x0F</span></span><br><span class="line">-> (req + <span class="number">0x17</span>) & <span class="number">0xF0</span></span><br><span class="line">-> (req + <span class="number">0x30</span> - <span class="number">0x19</span>) & <span class="number">0xF0</span></span><br></pre></td></tr></tbody></table></figure></div>



</li>
</ul>
</li>
</ol>
<h3 id="csize2tidx"><a href="#csize2tidx" class="headerlink" title="csize2tidx"></a>csize2tidx</h3><a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/csize2tidx_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/csize2tidx_1.png"></a>

<ul>
<li><p>这里的参数 x，正是前<code>request2size()</code>这个宏计算出的实际需要分配的 chunk 大小</p>
</li>
<li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p>
</li>
<li><p>MINSIZE 前面也算出来是 0x20 字节</p>
</li>
<li><p>下面进行一个简单的演算，假设 x 的值为 0x30 字节</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-> (x - MINSIZE + MALLOC_ALIGNMENT - <span class="number">1</span>) / <span class="number">0x10</span></span><br><span class="line">-> (<span class="number">0x30</span> - <span class="number">0x20</span> + <span class="number">0x10</span> - <span class="number">1</span>) / <span class="number">0x10</span></span><br><span class="line">-> (<span class="number">0x10</span> + <span class="number">0xF</span>) / <span class="number">0x10</span></span><br><span class="line">-> <span class="number">0x1F</span> / <span class="number">0x10</span></span><br><span class="line">-> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>此时得到的 idx 值为 1，我们知道 idx 是从 0 开始的，最小的 tcache bin chunk 大小是 0x20 字节。因此可以得出<code>chunksize = 0x20 + idx * 0x10</code>，这个 chunksize 就是需要分配的 chunk 大小，这样就会好理解很多</p>
</li>
</ul>
<h3 id="MAYBE-INIT-TCACHE"><a href="#MAYBE-INIT-TCACHE" class="headerlink" title="MAYBE_INIT_TCACHE"></a>MAYBE_INIT_TCACHE</h3><a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_init_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_init_1.png"></a>

<ul>
<li><p>先看 3006 行，这里<code>MAYBE_INIT_TCACHE</code>宏内部调用了<code>tcache_init()</code></p>
</li>
<li><p>回到 2972 行，我们来看<code>tcache_init()</code>的内部实现</p>
<ol>
<li>首先计算出 tcache_perthread_struct 结构的大小，然后为其分配空间</li>
<li>分配空间的过程和<code>__libc_malloc()</code>中类似，为了防止套娃这里只分析最外层的函数</li>
<li>调用<code>arena_get()</code>获取分配区，然后通过<code>_int_malloc()</code>从该分配区分配内存</li>
<li>如果分配区存在但没分配到，那就调用<code>arena_get_retry()</code>换个分配区再分配</li>
<li>分配完成后调用<code>__libc_lock_unlock</code>释放分配区，这是因为在获取分配区或者更换分配区时会进行上锁操作</li>
<li>最后将申请到的内存赋给 tcache_perthread_struct 结构，再调用<code>memset()</code>将内容初始化为0</li>
</ol>
</li>
</ul>
<h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><p>方才在<code>__libc_malloc()</code>中提到，如果满足一定条件，则通过<code>tcache_get()</code>获取到一个 chunk，传入的参数是经过宏<code>csize2tidx</code>算出来的所在 tcache bin 的 idx，下面来看这个函数：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_get_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_get_1.png"></a>

<ul>
<li>先根据 idx 找到对应的 tcache bin 的第一个 tcache_entry，也就是这条 bin 上的第一个 chunk 块</li>
<li>将这条 tcache bin 上的第一个 tcache_entry 修改为当前 tcache_entry 的下一个 tcache_entry，相当于将原先第一个 tcache_entry 给取出来（这玩意本质上就是 malloc_chunk，用到的字段不同，参考<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>)介绍的内容）</li>
<li>修改此 tcache_bin 对应 tcache_counts 中表示该链上 chunk 数量的值，执行减 1 操作</li>
<li>将取出的 chunk 的 key 字段置为 NULL，表示已经从 tcache 上取出；最后将其返回</li>
</ul>
<h3 id="chunk-is-mmapped"><a href="#chunk-is-mmapped" class="headerlink" title="chunk_is_mmapped"></a>chunk_is_mmapped</h3><a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk_is_mmapped_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk_is_mmapped_1.png"></a>

<ul>
<li>这个宏就是判断当前这个 chunk 是否通过<code>mmap()</code>申请的，这部分在<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>介绍 malloc_chunk 时有提到，在 chunksize 的低 3 位保存了当前 chunk 的一些属性，其中下标为1的位（10b）就是用于判断 IS_MAPPED 的 M 位</li>
</ul>
<h3 id="chunk2mem-mem2chunk"><a href="#chunk2mem-mem2chunk" class="headerlink" title="chunk2mem / mem2chunk"></a>chunk2mem / mem2chunk</h3><p>这俩宏功能互补，所以放在一起说</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk2mem_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" title="} - `chunk2mem`**传入的是 chunk 的实际首地址**，所以需要加上 prev_size 和 chunksize 两个字段的大小后，才能指向开始存储数据的位置。一般调用这个宏是将分配好的 chunk 转换为可以返回给用户的地址 - `mem2chunk`**传入的是返回给用户的地址，即经过 chunk2mem 处理后的结果**，其指向 malloc_chunk 中位于开始存储数据的位置，减去 2 个 SIZE_SZ 大小后，即可指向 chunk 实际开始的位置 ### arena_for_chunk 这部分涉及的宏定义还是挺多的 {% asset_img arena_for_chunk_1.png" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk2mem_1.png"></a>

<ul>
<li>这个宏传入的参数是经过<code>mem2chunk</code>得到的 chunk 地址，用来获取 chunk 所在的分配区（arena）</li>
<li>首先会调用<code>chunk_main_arena</code>这个宏，判断是否设置了 NON_MAIN_ARENA 位，这个值若未设置，就可以直接判断出是 main_arena（主分配区）</li>
<li>否则，先计算 HEAP_MAX_SIZE - 1 取反后的值，将其与 chunk 所在地址进行与操作，从而得到 chunk 所在堆的 heap_info 地址（<strong>这么做是因为每次申请的堆的起始地址是与 HEAP_MAX_SIZE 对齐的，因此这样可以取到堆的起始地址，从而拿到堆的 heap_info</strong>）</li>
<li>这里再回顾一下<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>中总结的概念：<strong>一个堆对应一个 heap_info，一个 thread_arena（非主分配区） 对应一个 malloc_state，一个 thread_arena 中包含多个堆</strong></li>
<li>拿到 heap_info 的地址后，就可以根据 ar_ptr 字段得到堆所在的分配区的地址了</li>
</ul>
<h3 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h3><p>这里涉及到的函数比较多，分开来讲</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_1.png"></a>

<ul>
<li><strong>arena_get</strong>：<ul>
<li>直接从 thread_arena 获取分配区（主分配区的获取不使用<code>arena_get()</code>）</li>
<li>将获取到的分配区和申请内存大小作为参数传入 <code>arean_lock()</code></li>
</ul>
</li>
<li><strong>arena_lock</strong>：<ul>
<li>判断是否成功获取分配区，若成功获取，则调用<code>__libc_lock_lock</code>对分配区上锁</li>
<li>若获取失败，则调用<code>arena_get2()</code>重新获取分配区</li>
</ul>
</li>
<li><strong>arena_get2</strong>：<ul>
<li>这个函数就干了一件事，调用<code>get_free_list()</code>获取分配区，如果获取成功则将分配区返回，这里<code>get_free_list()</code>返回的是 malloc_state 结构体</li>
</ul>
</li>
<li><strong>get_free_list</strong>：<ul>
<li>想要弄明白这个函数，需要回顾下<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>)中介绍 malloc_state 的部分</li>
<li>这里的 replaced_arena 是给下面要分析的<code>arena_get_retry()</code>用的，调用<code>arena_get()</code>时这个值通常为 NULL</li>
<li>先获取 free_list 上的第一个空闲分配区（free_arena），这是一个串着所有空闲分配区的链表，然后将其从 free_list 上摘下来</li>
<li>摘下来后，修改分配区的 attached_threads 的值为1，表明该分配区附加到当前线程；如果是通过<code>arena_get_retry</code>调用的，则还会将线程与原先的分配区（replaced_arena）进行 detach 操作；最后将新获取的分配区返回</li>
</ul>
</li>
</ul>
<h3 id="arena-get-retry"><a href="#arena-get-retry" class="headerlink" title="arena_get_retry"></a>arena_get_retry</h3><a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_retry_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_retry_1.png"></a>

<ul>
<li>对于非主分配区来说，如果分配区没空间了，可以考虑试着从主分配区分出来一点；否则，试着通过<code>sbrk()</code>进行分配区扩展；如果还不行的话，就试试其它空闲的分配区。这里最终调用回到了<code>arena_get2()</code>上面，前面刚分析过，就不再赘述了</li>
</ul>
<h2 id="int-malloc-主流程"><a href="#int-malloc-主流程" class="headerlink" title="_int_malloc 主流程"></a>_int_malloc 主流程</h2><h3 id="初始校验"><a href="#初始校验" class="headerlink" title="初始校验"></a>初始校验</h3><a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/int_malloc_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/int_malloc_1.png"></a>

<ul>
<li><p><code>_int_malloc()</code>接收两个参数，分配区和需要分配的大小，然后从分配区中分配满足需求大小的 chunk</p>
</li>
<li><p>变量中需要注意，mchunkptr 与 mbinptr 类型均是 malloc_chunk 结构体，其余参考注释即可</p>
</li>
<li><p>进入函数后最先会遇到两处校验：</p>
<ol>
<li><code>checked_request2size()</code>前面分析过了，这里主要是判断申请的内存大小是否超过了边界，若未超过，则会计算出至少需要分配的 chunksize，将值保存到 nb 中，然后进入下一个判断</li>
<li>接下来会判断 av 也就是传入的分配区是否为空，通常不为空。但如果为空，说明前面<code>arena_get()</code>与<code>arena_get_retry()</code>都未能获取到分配区。此时就会调用<code>sysmalloc()</code>去请求一个 chunk，通过<code>alloc_perturb()</code>初始化后，将这个 chunk 返回。这里 perturb_byte 的值默认为 0</li>
</ol>
</li>
<li><p>这里需要补充一些宏的含义（此处来自<a href="https://bbs.pediy.com/thread-271316.htm" target="_blank" rel="noopener">xi@0ji233的文章</a>）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就</span></span><br><span class="line"><span class="comment">// 把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。</span></span><br><span class="line"><span class="comment">// 或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。</span></span><br><span class="line">__glibc_unlikely(<span class="built_in">exp</span>): 表示<span class="built_in">exp</span>很可能为假</span><br><span class="line">__glibc_likely(<span class="built_in">exp</span>): 表示<span class="built_in">exp</span>很可能为真</span><br><span class="line">__builtin_expect(<span class="built_in">exp</span>, value): 表示<span class="built_in">exp</span>==value大概率成立</span><br></pre></td></tr></tbody></table></figure></div>



</li>
</ul>
<h3 id="Fast-Bin-处理流程"><a href="#Fast-Bin-处理流程" class="headerlink" title="Fast Bin 处理流程"></a>Fast Bin 处理流程</h3><ol>
<li><p>在 fast bin 处理的开始处有一个宏定义如下：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_part_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_part_1.png"></a>

<ul>
<li>这个宏主要是通过 lock-free 的技术实现单向链表删除第一个 node 的操作，暂时不必关注</li>
</ul>
</li>
<li><p>接下来进入 fast bin 的处理过程，源码的格式看着可能比较乱，这里分别框出来来看：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_part_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_part_2.png"></a>

<ul>
<li>首先，<strong>判断 nb（先前计算出的所需 chunk 大小）是否位于 fast bin 范围内</strong>，如果在范围内，就进入红框做进一步处理，否则直接跳过 fast bin 的处理逻辑</li>
<li><strong>红色方框</strong>：<ul>
<li>先通过<code>fastbin_index</code>算出 idx，即所需的 chunk 位于哪条 bin 上</li>
<li>调用<code>fastbin</code>获取对应 bin 的链表头，并将链表上的第一个 chunk 地址赋给 victim</li>
<li>判断 vicitim 是否存在，若不存在，说明这条 bin 上已经没有多余的 chunk 了，又<strong>因为 fast bin 中是大小严格匹配的</strong>，如果大小符合的 chunk 不存在，也不会去寻找其它的 bin，就会直接跳过 fast bin 剩余的处理逻辑</li>
</ul>
</li>
<li><strong>橙色方框</strong>：<ul>
<li>进入橙色方框，说明 chunk 存在。这里只做了一件事，就是将这个 chunk 从 bin 上摘下来；由于 fast bin 是先进后出单链表，具体手法就是令当前 bin 的指针指向 victim 的 fd 所指向的那个 chunk，<strong>这么做是因为 fast bin 这个单链表通过 fd 相连，且每次进入 fast bin 时，chunk 会放在 bin 和 bin->fd 之间的位置，取的时候则是取 bin->fd 指向的这个 chunk，因此是先进后出（FILO）</strong>。其中<code>REMOVE_FB</code>这个宏对应的是多线程的处理</li>
</ul>
</li>
<li><strong>蓝色方框</strong>：<ul>
<li>这部分主要是两个 check，第一个 check 是用 vicitim 再算一遍，判断其是否属于它原先所在的 bin</li>
<li>第二个 check 是对一些标志位的 check</li>
</ul>
</li>
<li><strong>粉色方框</strong>：<ul>
<li>这里是仅在开启了 tcache 的情况下才会发生的操作，当然 glibc2.31 版本中 tcache 是默认开启的</li>
<li>首先根据申请的 chunk 的大小，计算出当前 fast bin 对应的 tcache bin 是哪一个</li>
<li>先将找到的第一个符合要求的 chunk 作为 victim 暂存，并从 fast bin 上摘下，接下来从这条找到符合要求 chunk 的 fast bin 里面继续找，<strong>如果这个 fast bin 不为空，且 tcache bin 仍有多余空间（少于 7 个 chunk）</strong>，那么会通过一个循环将 fast bin 中的剩余 chunk 移动到 tcache bin 中，每轮循环都会判断一次 fast bin 是否还有 chunk 以及 tcache bin 是否还有空间（这个过程也是 <a href="https://cata1oc.github.io/2022/08/16/%E5%A0%86%E5%9F%BA%E7%A1%8005-how2heap%E5%88%9D%E7%BA%A7%E7%AF%87/#fastbin-reverse-into-tcache">fastbin_reverse_into_tcache</a> 这个利用手法的核心）。从 fast bin 摘下来的操作和前面橙色方框中的一样；放入 tcache bin 中则是用的 <code>tcache_put</code></li>
</ul>
</li>
<li><strong>绿色方框</strong>：<ul>
<li>粉色方框是不影响整体逻辑的部分，这里可以直接跟着蓝色方框来看</li>
<li>拿到 vicitim 后，调用<code>chunk2mem</code>将指针指向 chunk 存储数据的开始地址</li>
<li>再调用<code>alloc_perturb()</code>对这块内存初始化，然后返回给用户</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Small-Bin-处理流程"><a href="#Small-Bin-处理流程" class="headerlink" title="Small Bin 处理流程"></a>Small Bin 处理流程</h3><ol>
<li><p><strong>如果 fast bin 中没有合适的 chunk，且所需 chunk 的大小位于 small bin 范围内，那么就会进入 small bin 的处理流程</strong>。small bin 与 fast bin 的处理流程大体看着类似，但是细节有所不同：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/smallbin_part_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/smallbin_part_1.png"></a>

<ul>
<li>首先是判断申请的 chunksize 范围是否在 small bin 的范围内，不在就跳过这段处理逻辑，在的话就<ul>
<li>先调用<code>smallbin_index</code>算出 chunk 所在的 idx 是多少</li>
<li>再调用<code>bin_at</code>得到 idx 在 bins 中对应的那个 bin 的链表头。这里简单回顾一下，<strong>bins 是一个数组，数组中包含了 unsorted bin、small bin 以及 large bin 中各个 bin 的链表头，这些 bin 都是双链表</strong></li>
</ul>
</li>
<li>然后判断这个链表头的后一个元素是否还是它自己（<strong>注意这里在判断的同时，也进行了赋值操作，此时该链表若至少存在 1 个 chunk，那么 vicitim 指向的就是这个 chunk 的地址</strong>），如果是，说明这个 bin 已经空了，就跳过 small bin 的处理逻辑，因为 small bin 和 fast bin 一样也是严格匹配的，一旦大小不符合，就会跳过这段处理逻辑<ul>
<li>否则，获取 vicitim 的下一个 chunk，victim 是刚刚在进行判断链表是否为空时，取到的第一个 chunk，并判断这个 chunk 与 victim 之间的双链表是否完整，从而防止一些堆利用</li>
<li>然后，通过<code>set_inuse_bit_at_offset</code>将 victim 之后（进程虚拟内存中紧挨着 victim  地址的 chunk）的一个 chunk 的 prev_inuse 设置为 1，表示 victim 这个 chunk 正在被使用。fast bin 处理过程中是没有这个操作的，因为 fast bin 中的 chunk 默认都设置了 prev_inuse 的值，从而防止 chunk 之间的前后合并</li>
<li>设置完以后是一个常规的链表操作，将 victim 从双链表上摘下来:<ol>
<li><strong>在这里，从 small bin 中取出 chunk 时，取的是 bin 与 bin->bk->bk 之间</strong></li>
<li><strong>在从 unsorted bin 中加入 chunk 到 small bin 时，放入的位置是 bin 与 bin->fd 之间</strong></li>
<li><strong>再补充一点，从 unsorted bin 中取出 chunk 时，取的是 bin 与 bin->bk->bk 之间</strong></li>
<li><strong>往 unsorted bin 中加入 chunk 时，放入的位置是 bin 与 bin->fd 之间</strong></li>
</ol>
</li>
<li>然后再判断一下用来分配这个 chunk 的分配区是否为主分配区，若是，则设置相应字段的值</li>
<li>接着调用<code>check_malloced_chunk</code>进行一些字段的检查</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来是针对 tcache 情况的一些处理以及将 chunk 返回给用户，这部分和 fast bin 处理过程也很像，简单来看下：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/smallbin_part_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/smallbin_part_2.png"></a>

<ul>
<li>tcache 处理的部分和  fast bin 中 tcache 处理的部分基本上一样，就是在对应大小（<strong>刚刚分配的 chunk 的大小</strong>）的 small bin 不为空且 tcache bin 还有额外空间时，通过循环将 small bin 中的 chunk 塞到 tcache bin 中；且每次循环判断一次 small bin 是否为空，以及 tcache bin 是否满了。这里仅说下不同点：<ul>
<li>small bin 中的 chunk 放入 tcache bin 中时需要设置 prev_inuse；fast bin 中的 chunk 默认是设置了的</li>
<li>small bin 断链进行的是双链表操作；fast bin 是单链表操作</li>
<li>small bin 需要判断是否为主分配区，并设置相应字段；fast bin 没有</li>
</ul>
</li>
<li>最后和 fast bin 一样，将分配的好的 chunk 初始化后返回给用户</li>
</ul>
</li>
</ol>
<h3 id="Unsorted-Bin-处理流程"><a href="#Unsorted-Bin-处理流程" class="headerlink" title="Unsorted Bin 处理流程"></a>Unsorted Bin 处理流程</h3><ol>
<li><p>如果在 small bin 或者 fast bin 处理流程中找到了合适大小的 chunk，那么程序就返回了。<strong>如果执行到这里，说明 chunk 大小位于 large bin 中或者在 small bin 和 fast bin 中没有找到所需大小的块</strong>，接下来就沿着这个思路结合源码继续分析</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_1.png"></a>

<ul>
<li>首先的一个 else 块，它对应前面的<code>if (in_smallbin_range(nb))</code>，因此，<strong>如果进入了 else 语句，那么说明所需 chunk 的大小位于 large bin 中</strong>，这里会做两件事：<ul>
<li>通过宏<code>largebin_index</code>获取所需 chunk 在 large bin 中的 index，即所在的 bin 链</li>
<li>判断 fast bin 是否存在（即是否已经初始化），若存在，则调用<code>malloc_consolidate()</code>将 fast bin 中的所有 chunk free 掉并与前后的块合并，然后存到 unsorted bin 中</li>
</ul>
</li>
<li><strong>如果没有进入 else 语句，说明所需的大小位于 fast bin 或者 small bin 中，但是 fast bin 与 small bin 分配时要求大小严格匹配，因此没有找到合适的块</strong>，所以就会进入到 unsorted bin 是处理流程。并且对于 large bin 范围的申请，在 else 语句执行完后，也会执行到此处：<ul>
<li>glibc2.31版本默认开启 tcache，因此会执行此处的代码</li>
<li>调用<code>csize2tidx</code>获取所需 chunk 大小在 tcache bin 中的 idx，如果 nb 的大小位于 tcache 范围内（tcache 范围涵盖了 large bin 中的前面一小部分），则将其赋值给变量 tcache_nb</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来进入一个大的 for 循环，该循环可以忽略，因为一直延续到<code>__int_malloc</code>结束，重点在于这个 while 循环</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_2.png"></a>

<ul>
<li>unsorted bin 是一个双链表，位于 bins 上的第一个 </li>
<li>迭代循环 unsorted bin 中的所有 chunk，变量 iters 跟踪迭代次数</li>
<li>victim 表示当前 chunk，<strong>bck 为 unsorted bin 上 victim 的后一个 chunk，next 为堆上 victim 的后一个 chunk</strong></li>
<li><code>chunksize</code>用于获取 chunk 的大小，<code>chunk_at_offset</code>用于获取下一个 chunk 的地址</li>
<li>接下来会进行一堆 check：<ul>
<li>检查 victim 和 next 的 size 不能小于最小的 chunksize，也不能大于所属分配区已经分配的内存大小</li>
<li>检查 next 的 prev_size 是否等于 victim 的 size</li>
<li>检查 victim->bk->fd 是否等于 victim，保证双链表完整性</li>
<li>检查 victim->fd 是否等于 unsorted_chunks(av) 这是因为在每轮循环开始有 <code>victim = unsorted_chunks(av)->bk</code></li>
<li>检查 victim 是否设置了 prev_inuse，因为进入 unsorted bin 中的 chunk 都已经清空了该值</li>
</ul>
</li>
</ul>
</li>
<li><p>经过一系列 check 后，是针对各类情况的处理</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_3.png"></a>

<ul>
<li>如果同时满足以下 4 个条件，则会进入对应的处理：<ol>
<li><strong>所需 chunk 的大小的范围在 small bin 中</strong></li>
<li>unsorted bin 中仅剩最后一个 chunk<ul>
<li><code>bck = victim->bk</code></li>
<li><code>victim = unsorted_chunks(av)->bk</code></li>
</ul>
</li>
<li>victim 是 last remainder chunk</li>
<li>该 last remainder chunk 的 size 需大于所需 chunk 大小与 MINSIZE 之和</li>
</ol>
</li>
<li>具体是进行一次 chunk 切割的操作，把所需大小的 chunk 返回给用户，余下的部分作为 last remainder chunk 回到 unsorted bin 中，下面简单分析下这个过程：<ol>
<li><strong>计算出 remainder_size，然后通过<code>chunk_at_offset</code>拿到分割后 remainder 的地址（成为新的 last remainder chunk）</strong></li>
<li>修改 unsorted bin 的头指针，将其指向 last remainder chunk 的位置</li>
<li><strong>如果 remainder 大小不在 small bin 范围内</strong>，就添加 fd_nextsize 与 bk_nextsize 指针</li>
<li>设置 victim 与 remainder 的标志位</li>
<li>将 victim 存储数据的地址（victim + 2*SIZE_SZ）返回给用户</li>
</ol>
</li>
</ul>
</li>
<li><p>若不满足前面的判断条件，或 remainder 不够分割了，则会继续走到这里</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_4.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_4.png"></a>

<ul>
<li>首先会 check 一下链表的完整性，校验成功后，会将当前的 chunk 也就是 victim 从 unsorted bin 上面摘下来，方便后续操作</li>
<li>然后判断一下，如果 victim 的 size 刚好符合申请所需的 chunk 大小，那么先设置好标志位，然后：<ul>
<li>如果开启了 tcache（glibc2.31中默认开启），并且<strong>victim size 对应的 tc_idx 所在 bin 中仍有空余位置</strong>（少于7个），那么就调用<code>tcache_put()</code>将 victim 放入到 tcache 中</li>
<li>如果对应的这条 tcache bin 已经满了，那么就直接将其返回给用户</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来这步是 unsorted bin 处理的核心，它会将 unsorted bin 中遍历的 chunk 根据 size 放入对应的 small bin 或者 large bin 中，这是唯一一次将 chunk 放入 small bin 或者 large bin 的过程</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_5.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_5.png"></a>

<ul>
<li><p>如果 vicitim 的 size 位于 small bin：</p>
<ol>
<li>获取该 size 在 small bin 中的 index</li>
<li>获取该 index 所在 bin 的头指针作为 bck</li>
<li>获取头指针后的第一个 chunk 指针作为 fwd</li>
<li>使用头插法将 victim 插入到 bck 与 fwd 之间的位置</li>
</ol>
</li>
<li><p>否则，即 victim 的 size 位于 large bin 时：</p>
<ol>
<li><p>获取该 size 在 large bin 中的 index</p>
</li>
<li><p>获取该 index 所在 bin 的头指针作为 bck</p>
</li>
<li><p>获取头指针后的第一个 chunk 指针作为 fwd，<strong>这里的第一个 chunk 可以理解为这条 bin 链上 size 最大的 chunk</strong>，因为 large bin 上每条 bin 里的 chunk 大小并不相同，可以参考下图<code>chunk#1</code>在这条 bin 链上的位置。当然这张图是针对 glibc2.23 版本的 large bin，在 glibc2.31 版本下 large bin 的排列与下图有所不同，稍微我们会说到</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_1.png"></a>
</li>
<li><p>接下来会有一系列条件判断，以及对应的处理逻辑，这里我将不按照代码前后顺序去分析其逻辑，而是直接将不同条件及处理逻辑进行对应，这样也许更加清晰：</p>
<ul>
<li><p><strong>情形一：fwd == bck</strong></p>
<p>此时 large bin 中不包含任何 chunk，victim 会将其 fd_nextsize 与 bk_nextsize 设置成自己，然后链入到 bin 上。此时 victim 的 fd 和 bk 都是 bin 链表头</p>
</li>
<li><p><strong>情形二：fwd != bck 且 victim_size < #n_size（bck->bk）</strong></p>
<p>这个情形可以参考上图，#n_size 指的就是上图蓝色的那个 chunk，前面 bck 指向了链表头，bck->bk 就指向最后一个 chunk，它是目前 large bin 上 size 最小的 chunk。如果 victim 的 size 比最小的 chunk 还要小。那么就会让 vicitim 作为最后一个 chunk</p>
<p>注意这里所说的最后一个 chunk，参考上图，large bin 的 bin 链中相同大小的 chunk 用 fd/bk 相连，不同大小的 chunk 用 fd_nextsize/bk_nextsize 相连。当前这种情况下，large bin 中还没有与 victim_size 相等的 chunk，且 vicitim_size 小于这条 bin 上的所有 chunk，因此被放在了最后一个的位置</p>
<p>这里具体所作的操作是，<strong>将 fwd 设置为链表头，bck 设置为原先最小 chunk 中的某一个</strong>（当有多个大小相同 chunk 的情况下，这个 bck 是与链表头相连的那一个，即这些 chunk 中的最后一个，而不是链在 fd_nextsize/bk_nextsize 上面的那个，因为它是相同大小 chunk 链上的第一个。另外通过它是用 <code>fwd->fd->bk_nextsize</code> 来定位的，而不是<code>fwd->bk</code> 来定位，也可以判断出这一点），fd_nextsize 指向原先最大 chunk 中的第一个，bk_nextsize 指向原先最小 chunk 中的第一个</p>
</li>
<li><p><strong>情形三：fwd != bck 且 victim_size > fwd_size</strong></p>
<p>large bin 不为空，且不包含 victim_size 的 chunk，victim_size 大于链表中最小 chunk 的 size</p>
<p>这一步判断时，会通过循环，从前往后找（最大的 chunk 开始往最小的 chunk 找）直到 victim_size >= fwd_size（当前 chunk 的大小），这里是大于的情况，也就说，当前 large bin 中并没有与 victim_size 相同的 chunk 存在，这里的操作和情形二比较类似，区别是情形二是在链表尾进行操作，这里则是在链表中间进行操作</p>
<p>具体会通过 fd_nextsize/bk_nextsize 将 victim 放到 fwd 与 fwd->bk_nextsize 之间，这样保持了不同大小之间的 chunk  链接。然后将 victim 串在 fwd 与 fwd->bk 之间。<strong>这里注意 fwd->bk_nextsize 与 fwd->bk 指向的可能是不同 chunk</strong>。如果 fwd->bk_nextsize 指向的 chunk 相同大小的仅有它一个，那么此时 fwd->bk 与 fwd->bk_nextsize 是相同的，否则，fwd->bk 指向的是 fwd->bk_nextsize 所在 chunk 大小相同的这个链表里最靠后的一个 chunk。通过 <code>fwd->bk_nextsize->fd->fd->fd...</code>这种形式来访问</p>
</li>
<li><p><strong>情形四：fwd != bck 且 victim_size == fwd_size</strong></p>
<p>large bin 不为空，包含 victim_size 的 chunk。</p>
<p>此时通过遍历相同大小的第一个 chunk（通过 fd_nextsize/bk_nextsize 相连），找到后将其插入到 <strong>fwd->fd 与 fwd 之间的位置</strong>，每次都是如此，也就是说新来的相同大小的 chunk 永远是放在第二个位置，原先的将会依次递增，然后结束。这下就可以解释情形三了，<strong>如果已经存在相同大小的 chunk，则找到这个大小位于 fd_nextsize/bk_nextsize 链上的那个 chunk 作为 fwd，将 victim 链入到 fwd 与 fwd->fd 之间，也就是相同大小 chunk 链表的第二个位置；如果不存在相同大小的 chunk，找到比 victim_size 小的里面最大的一个位于 fd_nextsize/bk_nextsize 链上的那个 chunk 作为 fwd，将 victim 链入到 fwd 与 fwd->bk 之间</strong></p>
<p>fd_nextsize/bk_nextsize 那条链上的链入操作比较好理解，这里解释这么多主要是防止被上面一张图 large bin 的排布所误解，glibc2.31 这个版本的 large bin 构筑可以参考下图，图片来自<a href="https://bbs.pediy.com/thread-272416.htm#msg_header_h2_11" target="_blank" rel="noopener">pukrquq</a></p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_2.png"></a>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>这里是 unsorted bin 处理流程的第六步，在第四步时，如果从 unsorted bin 中摘下来的 chunk 刚好满足我们的需求，并且 tcache 仍然有多余的空间，那么 ptmalloc2 会先将这个 chunk 放到对应的 tcache bin 中，然后回到循环开头，直到下一个从 unsorted bin 中摘出来的 chunk 不满足需求（如果满足需求，同样会进入 tcache bin，若 tcache bin 已满，则直接返回给用户，不会执行到此处），那么再根据其 size 被分配到 small bin 或者 large bin 以后，就会执行到这里。</p>
<p>因为代码块不同，这里我们分为 3 个部分来看更为清晰些：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_6.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_6.png"></a>

<ul>
<li><p><strong>红色方框</strong>：</p>
<p>首先前面在从 unsorted bin 中取出 chunk 时，若发现符合要求的则会放入 tcache bin 中，并将 return_cached 的值设置为 1，会用于此处的判断。此外，tcache_unsorted_count 会在每次执行到这里时都会自增1，说明此轮没有 chunk 进入 tcache bin，而是进入了 large bin/ small bin。如果执行到此处的次数超过了 tcache_unsorted_limit 的值（默认是 0），就会调用 <code>tcache_get()</code>从 tcache bin 中取出符合需求的 chunk 返回给用户</p>
</li>
<li><p><strong>绿色方框</strong>：</p>
<p>注意这部分有个大括号，闭合了前面的 while 循环，这里说的是，<strong>最多遍历 unsorted bin 一万次</strong>。不然一次产生了太多的 unsorted bin，然后我  malloc 一次，结果一直在这个循环里分配 unsorted bin 上面的 chunk，迟迟等不到分配的内存，所以这里会设定一个遍历的最大值</p>
</li>
<li><p><strong>蓝色方框</strong>：</p>
<p>最后，出了 while 循环，也就遍历完 unsorted bin 了，这时会判断一下在先前遍历时是否找到符合需求的 chunk，若找到了且被放入了 tcache bin 中，则 return_cached 会被设置，此时调用<code>tcache_get()</code>即可。至此，unsorted bin 的处理逻辑就全部结束了。若仍未找到合适的 chunk，则会继续往后执行。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Large-Bin-处理流程"><a href="#Large-Bin-处理流程" class="headerlink" title="Large Bin 处理流程"></a>Large Bin 处理流程</h3><ol>
<li><p>在将 unsorted bin 中的 chunk 分配到 small bin 与 large bin 后，若所需的 chunk 大小位于 large bin 的范围区间，则会从这里开始处理</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_1.png"></a>

<ul>
<li><strong>第一层校验</strong>会判断所需的 chunk 大小 nb 是否位于 small bin 范围内，这里再判断一遍的原因是 <code>bin_at</code>这个宏是根据 size 获取在 bins 中的 idx 的，<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>我们提到，bins 中包含了 unsorted bin，small bin 以及 large bin。这里又判断一次范围是否在 small bin 也是为了确保，<code>bin_at</code> 的结果会落在 large bin 在 bins 对应的 idx 范围内</li>
<li><strong>第二层校验</strong>是确保 large bin 不为空，且 large bin 中最大的 chunk 要比所需的 chunk 要大。<code>first</code>宏用于获取 idx 所在 bin 中第一个 chunk，即当前 idx 中最大的 chunk</li>
<li>接下来开始在 large bin 中寻找到最合适的那个 chunk，逻辑如下：<ol>
<li>与插入 chunk 到 large bin 中不同，这里是从最小的 chunk 开始遍历，直到找到一个 chunk 大于等于所需的 chunk 大小</li>
<li>这里有两处判断，第二处<strong>用来确保 victim 所在的相同大小的双链上至少有两个 chunk</strong>，这样我们方便把第二个 chunk，也就是 victim->fd 给分配出去。<code>victim != last(bin)</code>主要是判断 size 最小的那个双链是否有两个或更多 chunk，因为这个双链上最后一个 chunk 与 bin 链表头相连，若相等，则说明该链上就只有一个 chunk，所以这两个判断证明的事是一样的 </li>
<li>如果这条链上存在至少 2 个 chunk，那就取第 2 个，否则就用第 1 个。然后调用<code>unlink_chunk()</code>将这个 chunk 断链，并判断切去所需大小 nb 后，余下空间是否构成一个最小 chunk：<ul>
<li>若不能，则对这个 chunk 设置并检查相应的标志位后，返回给用户</li>
<li>若能，则会切割出 nb 大小的部分，余下的部分作为 remainder 链入到 unsorted bin 中并根据大小决定是否设置 bk_nextsize / fd_nextsize，并对 remainder 与分割出的部分分别设置标志位，将分割出的部分返回给用户。<strong>此处分割剩下的 remainder，并没有被设置为该分配区的 last remainder chunk。分析到这里为止，仅在 unsorted bin 处理逻辑中的一次分割会设置 last remainder chunk，这点需要注意</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>如果在前面找到的 large bin 中未发现符合要求的 chunk，就会来到这一步。这部分代码看着不复杂，但是理解起来也不是非常容易，咱们来逐条分析：</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_2.png"></a>

<ul>
<li><p><code>++idx</code>：在前一个 bins[idx] 所表示的 large bin 中没有找到合适的块，那么就增加 idx 的值，去 bins[idx++] 去找是否有符合的块。当然，理论上 bins[idx++] 中只要存在 chunk，就一定可以满足需求</p>
</li>
<li><p><code>bin_at</code>：这个宏之前已经多次出现，就是<strong>拿到这个 idx 在 bins 对应的链表的头节点</strong>，这个头节点是一个 malloc_chunk 结构体，通过头节点的 fd/bk 指针可以访问这个 bin 上的第一个块（对应 large bin 中最大的块）与最后一块（对应 large bin 中最小的块）</p>
</li>
<li><p>接下来 3  行相互之间有所关联，需要放在一起来看：</p>
<ul>
<li><p>首先 block，map，bit 这三个变量都是 unsigned int 类型</p>
</li>
<li><p>malloc_state 结构中有一个 binmap，它用来快速查找对应 index 所在的 bin 是否为空。这里通过 av->binmap 来访问</p>
</li>
<li><p>binmap 是个数组，长度为 4，每个元素都是一个 32 位的整数，加起来刚好是 128 位，刚好对应 bins 中的每个 bin，这 128 位可以看作是下标，若该下标的值置0，则说明 bin 为空</p>
</li>
<li><p><code>idx2block</code> 这个宏的操作是将 idx 右移 5位，即将 idx 除 32，得到一个位于 0~3 范围内的值，从而找到该下标位于 binmap 中的第几个 32 位的整数上</p>
</li>
<li><p><code>idx2bit</code> 这个宏如下，作用是取到 idx 对应 large bin 的下标（图片来自付师傅的笔记）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U << ((i) & ((1U << BINMAPSHIFT) - 1))))</span></span><br></pre></td></tr></tbody></table></figure></div>

<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/idx2bit.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/idx2bit.png"></a>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来会进入一个死循环，直到找到一个符合要求的 chunk</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_3.png"></a>

<ul>
<li><p>if 语句有两个条件（来自付师傅的笔记）</p>
<ul>
<li>bit > map：如果bit大于map说明在本block中，map中大于bit的位置都为0，表示对应的bin都为空，无需继续检查</li>
<li>bit == 0：通过idx2bit转化为32位的数据中，应该是31个0和一个1组成的，所以bit!=0；且因为前面进行了++idx，所以不可能转变成对应第一个bin的unsorted bin</li>
</ul>
<p>然后进入循环，判断当前 block 的值是否为 0，即这个 block 所表示的 32 个 bin 是否都是空的，如果是空的，就找下一个 block。如果全部都为空，就跳转到后面的 use_top 中进行处理。如果不为空，那么找到下标对应的 bin 并将 bit 置 1</p>
</li>
<li><p>while 循环里通过 bit 与 map 相与是否为 0 来判断这个 bin 是否为空。若为空，则通过<code>next_bin</code>来访问下一个 bin，这里的下一个可以理解为 <code>bins[80] -> bins[81]</code> 这种形式，同时 bit 也进行左移，即移动到这个 block 里面与表示这个 bin 所在位置的下标处</p>
</li>
<li><p>此时这个 bin 应该不是空的，但还是要判断一下。通过 <code>last</code> 获取到 bin 中的第一个元素，判断是否与自身相等，若相等，则说明 bin 为空，那么将这个 bin 在 binmap 中对应的 bit 置零，然后继续查看下一个 bin</p>
</li>
</ul>
</li>
<li><p>若不为空，那这个 bin 里面的 chunk 肯定是可以拿来用的，所以这里取的是最小的 chunk 作为 victim。接下来的操作就和 unsorted bin 里面满足 4 个条件的那个操作，以及前面在一开始就可以找到一个合适的 large bin chunk 时的操作是类似的。就是先切割，挂到 unsorted bin 中，返回给用户这么几个操作，这里就不多赘述了。<strong>唯一需要注意的是，若所需的 chunk 位于 small bin 的范围（有人可能问这都校验多少次了为什么还可能是 small bin 范围，那可能是因为 small bin 和 unsorted bin 中都没有 chunk，最后只能来 large bin 申请），那么这里分割后的 remainder 会被设置为 last remainder chunk。这是第二次设置 last remainder chunk 的地方。</strong></p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_4.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_4.png"></a>



</li>
</ol>
<h3 id="Top-Chunk-处理流程"><a href="#Top-Chunk-处理流程" class="headerlink" title="Top Chunk 处理流程"></a>Top Chunk 处理流程</h3><p>如果 large bin 也是空的或者满足不了需求怎么办，那么前面有一处 <code>goto use_top</code>，就会来到这里，试图分配 top chunk</p>
<a href="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/top_chunk_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/top_chunk_1.png"></a>

<ul>
<li>先通过 av->top 获取到 top chunk，通过宏 <code>chunksize</code> 获取到 top chunk 的大小。然后先做一个判断，看这个 top chunk 的 size 是否超过了 av->system_mem（这个值表示系统调用时申请的内存大小）。这个判断在 unsorted bin 的处理流程开始处也进行过一次</li>
<li>接下来，则根据 top chunk 的情况分类处理：<ul>
<li>如果 top chunk 超过 nb（所需 chunk 大小） + MINSIZE，那么操作和前面 unsorted bin 与 large bin 分割类似。<strong>此处分割不会设置 last remainder chunk</strong></li>
<li>否则，如果存在 fastbin，那么先调用 <code>malloc_consolidate()</code> 将 fastbin 合并；再根据所需的 chunk 大小设置 idx 的值，然后回到死循环的开头（图中紫色大括号，对应 unsorted bin 处理流程的开始部分）再进行一轮判断</li>
<li>若上面俩都没执行，那么调用 <code>sysmalloc()</code> 通过系统调用来进行内存分配，这部分可参考<a href="https://www.cnblogs.com/luoleqi/p/15520621.html#sysmalloc-internal_size_t-nb-mstate-av" target="_blank" rel="noopener">Pwnki</a>的分析</li>
</ul>
</li>
</ul>
<h2 id="int-malloc-辅助函数"><a href="#int-malloc-辅助函数" class="headerlink" title="_int_malloc 辅助函数"></a>_int_malloc 辅助函数</h2><p><code>_int_malloc()</code> 中涉及到的辅助函数较多，大多数以宏为主，且都比较简单，跟进去看看源码就明白意思了。所以这部分暂时先鸽掉了，等后期复习本篇时如果发现有需要记录下的函数，再进行适当补充。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://www.cnblogs.com/luoleqi/p/15520621.html" target="_blank" rel="noopener">博客园：glibc2.31 malloc 与 free 源码分析</a></li>
<li><a href="https://bbs.pediy.com/thread-271316.htm" target="_blank" rel="noopener">看雪：malloc源码分析</a></li>
<li><a href="https://blog.csdn.net/weixin_44215692/article/details/123930658" target="_blank" rel="noopener">CSDN：glibc下malloc与free的实现原理（二）：malloc函数的实现</a></li>
<li><a href="https://www.lmlphp.com/user/56/article/item/7838/" target="_blank" rel="noopener">堆学习之 fastbin-attack</a></li>
<li><a href="https://bbs.pediy.com/thread-272416.htm" target="_blank" rel="noopener">看雪：how2heap深入浅出学习堆利用</a></li>
</ol>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">cataLoc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">http://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全    </a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0x60.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="prev_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0x61.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>堆基础03：free源码分析</span></div></a></div><div class="next-post pull_right"><a href="/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/0x5F.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>堆基础01：ptmalloc2初探</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/10/31/初探GOT与PLT/" title="初探GOT与PLT"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/10/31/%E5%88%9D%E6%8E%A2GOT%E4%B8%8EPLT/cover0x4C.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-31</div><div class="relatedPosts_title">初探GOT与PLT</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/07/缓冲区溢出入门-上/" title="缓冲区溢出入门(上)"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/11/07/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%85%A5%E9%97%A8-%E4%B8%8A/cover0x4D.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-07</div><div class="relatedPosts_title">缓冲区溢出入门(上)</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/13/缓冲区溢出入门-下/" title="缓冲区溢出入门(下)"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/11/13/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%85%A5%E9%97%A8-%E4%B8%8B/cover0x4E.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-13</div><div class="relatedPosts_title">缓冲区溢出入门(下)</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/02/AFL源码分析01/" title="AFL源码分析01：afl-gcc.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/02/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001/cover0x50.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-02</div><div class="relatedPosts_title">AFL源码分析01：afl-gcc.c</div></div></a></div><div class="relatedPosts_item"><a href="/2021/12/22/AFL环境搭建/" title="AFL环境搭建"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/12/22/AFL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/cover0x4F.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-12-22</div><div class="relatedPosts_title">AFL环境搭建</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/05/AFL源码分析02/" title="AFL源码分析02：afl-as.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/05/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/cover0x51.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-05</div><div class="relatedPosts_title">AFL源码分析02：afl-as.c</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By cataLoc</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>