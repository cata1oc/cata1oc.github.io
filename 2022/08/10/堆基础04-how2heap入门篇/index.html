<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>堆基础04：how2heap入门篇 | cataLoc's Blog</title><meta name="description" content="堆基础04：how2heap入门篇"><meta name="keywords" content="二进制安全"><meta name="author" content="cataLoc"><meta name="copyright" content="cataLoc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="堆基础04：how2heap入门篇"><meta name="twitter:description" content="堆基础04：how2heap入门篇"><meta name="twitter:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/cover0x62.png"><meta property="og:type" content="article"><meta property="og:title" content="堆基础04：how2heap入门篇"><meta property="og:url" content="http://cata1oc.github.io/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/"><meta property="og:site_name" content="cataLoc's Blog"><meta property="og:description" content="堆基础04：how2heap入门篇"><meta property="og:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/cover0x62.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'true'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://cata1oc.github.io/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/"><link rel="prev" title="堆基础05-how2heap初级篇" href="http://cata1oc.github.io/2022/08/16/%E5%A0%86%E5%9F%BA%E7%A1%8005-how2heap%E5%88%9D%E7%BA%A7%E7%AF%87/"><link rel="next" title="堆基础03：free源码分析" href="http://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">cataLoc's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/Substitute.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#fastbin-dup"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">fastbin_dup</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#源码分析"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">源码分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#执行分析"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">执行分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调试分析"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">调试分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原理小结"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">原理小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#tcache-house-of-spirit"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">tcache_house_of_spirit</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#源码分析-1"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">源码分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#执行分析-1"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">执行分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调试分析-1"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">调试分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原理小结-1"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">原理小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#overlapping-chunks"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">overlapping_chunks</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#源码分析-2"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">源码分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#完整版"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">完整版</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#简化版"><span class="toc_mobile_items-number">4.1.2.</span> <span class="toc_mobile_items-text">简化版</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#执行分析-2"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">执行分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调试分析-2"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">调试分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原理小结-2"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">原理小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#unsafe-unlink"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">unsafe_unlink</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#源码分析-3"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">源码分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#完整版-1"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">完整版</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#简化版-1"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">简化版</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#执行分析-3"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">执行分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调试分析-3"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">调试分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原理小结-3"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">原理小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#tcache-poisoning"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">tcache_poisoning</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#源码分析-4"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">源码分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#执行分析-4"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">执行分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调试分析-4"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">调试分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原理小结-4"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">原理小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考链接"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">参考链接</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup"><span class="toc-number">2.</span> <span class="toc-text">fastbin_dup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">2.1.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行分析"><span class="toc-number">2.2.</span> <span class="toc-text">执行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试分析"><span class="toc-number">2.3.</span> <span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理小结"><span class="toc-number">2.4.</span> <span class="toc-text">原理小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-house-of-spirit"><span class="toc-number">3.</span> <span class="toc-text">tcache_house_of_spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-1"><span class="toc-number">3.1.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行分析-1"><span class="toc-number">3.2.</span> <span class="toc-text">执行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试分析-1"><span class="toc-number">3.3.</span> <span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理小结-1"><span class="toc-number">3.4.</span> <span class="toc-text">原理小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overlapping-chunks"><span class="toc-number">4.</span> <span class="toc-text">overlapping_chunks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-2"><span class="toc-number">4.1.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#完整版"><span class="toc-number">4.1.1.</span> <span class="toc-text">完整版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简化版"><span class="toc-number">4.1.2.</span> <span class="toc-text">简化版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行分析-2"><span class="toc-number">4.2.</span> <span class="toc-text">执行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试分析-2"><span class="toc-number">4.3.</span> <span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理小结-2"><span class="toc-number">4.4.</span> <span class="toc-text">原理小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-unlink"><span class="toc-number">5.</span> <span class="toc-text">unsafe_unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-3"><span class="toc-number">5.1.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#完整版-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">完整版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简化版-1"><span class="toc-number">5.1.2.</span> <span class="toc-text">简化版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行分析-3"><span class="toc-number">5.2.</span> <span class="toc-text">执行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试分析-3"><span class="toc-number">5.3.</span> <span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理小结-3"><span class="toc-number">5.4.</span> <span class="toc-text">原理小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">6.</span> <span class="toc-text">tcache_poisoning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析-4"><span class="toc-number">6.1.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行分析-4"><span class="toc-number">6.2.</span> <span class="toc-text">执行分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试分析-4"><span class="toc-number">6.3.</span> <span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理小结-4"><span class="toc-number">6.4.</span> <span class="toc-text">原理小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/cover0x62.png)"><div id="post-info"><div id="post-title"><div class="posttitle">堆基础04：how2heap入门篇</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2022-08-10<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2022-08-20</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><strong>学习材料：</strong>“how2heap” 是 shellphish 团队在 <a href="https://github.com/fr0ster/how2heap" target="_blank" rel="noopener">Github</a> 上开源的堆漏洞系统教程，包含很多常见的堆漏洞教学示例，本篇也将使用此教程 中的示例完成对堆利用的学习</li>
<li><strong>glibc版本：</strong>glibc2.31</li>
<li><strong>操作系统：</strong>Ubuntu 20.04</li>
<li><strong>示例选择：</strong>本篇参考了<a href="https://bbs.pediy.com/thread-272416.htm" target="_blank" rel="noopener">pukrquq师傅</a>基于 glibc2.34 版本的分析文章，选用了在高版本依然存在的利用方式进行分析，文章的分析顺序与pukrquq师傅一致，按照示例 poc 代码由简单到复杂的过程进行 </li>
</ul>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_code_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_code_1.png"></a>

<p>先分析源码，可能是为了方便理解，源码中包含大量的描述性语句，会影响阅读，所以这里分块来看：</p>
<ul>
<li><p><strong>橙色方框：</strong></p>
<ol>
<li>申请 8 个<strong>能容纳 8 字节的 chunk</strong>，而 MINSIZE 刚好可以容纳 8 字节，因此这里是申请了 8 个 0x20 字节大小的 chunk。由于此时所有 bin 都是空的，因此这个 8 个 chunk 是从 top chunk 中分配的。为了方便描述，此示例后面所有申请能容纳 8 字节 chunk 的行为，我都会描述成申请 0x20 字节大小的 chunk</li>
<li>再释放这 7 个 0x20 大小的 chunk，用于填充 0x20 大小的这条 tcache bin，7 个刚好填满</li>
</ol>
</li>
<li><p><strong>蓝色方框：</strong></p>
<ol>
<li>通过 <code>calloc()</code> 方法分配申请 3 个 0x20 字节大小的 chunk</li>
<li>这里调用的是 <code>calloc()</code> 而不是我们先前分析的 <code>malloc()</code>，它俩的执行路线略有不同，区别如下：<ul>
<li><code>calloc() -> __libc_calloc() -> _int_malloc()</code></li>
<li><code>malloc() -> __libc_malloc() -> _int_malloc()</code></li>
</ul>
</li>
<li>在 glibc2.31 版本的 <code>__libc_calloc()</code> 中，<strong>不会尝试从 tcache 中分配 chunk</strong>，其分配内存的行为是从 <code>_int_malloc()</code> 才开始的，因此通过 <code>calloc()</code>  申请内存时只需要关注 <code>_int_malloc()</code> 即可</li>
<li>由于此时除了 tcache bin 以外，所有 bin 都是空的，所以这 3 个 chunk 还是从 top chunk 中分配的</li>
</ol>
</li>
<li><p><strong>红色方框：</strong></p>
<p>这里是一个典型的 double free 操作，但是为了防止被 glibc 中内置的机制检测出，这里选择在 2 次  <code>free(a)</code> 操作之间进行一次 <code>free(b)</code> 的操作。接下来我们分析下这顿操作会发生什么，这部分的前置知识可以参考我先前<a href="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"> free 的分析文章</a></p>
<ol>
<li><strong>free() 开始前：</strong><ul>
<li>0x20 大小的 fast bin 是空的</li>
<li><code>fastbinsY[0x20] -> NULL</code></li>
</ul>
</li>
<li><strong>第一次 free(a) ：</strong><ul>
<li>由于 0x20 字节大小的 tcache bin 已经满了，所以会释放到 0x20 大小的 fast bin 中</li>
<li><code>fastbinsY[0x20] -> a</code></li>
</ul>
</li>
<li><strong>free(b) ：</strong><ul>
<li>与上面类似，也会释放到 0x20 大小的 fast bin 中，由于采用头插法，先进后出，所以会放在 a 前面</li>
<li><code>fastbinsY[0x20] -> b -> a</code></li>
</ul>
</li>
<li><strong>第二次 free(a)：</strong><ul>
<li>double free 的核心操作，第二次释放 a，又因为 <code>_int_free()</code> 只会检查前后两个 chunk 是否相同，因此这里可以成功释放，将 a 再次放入 fast bin 链表头指向的位置 </li>
<li><code>fastbinsY[0x20] -> a -> b -> a</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>粉色方框：</strong></p>
<p>这部分依次申请 3 个 0x20 大小的 chunk，用的还是 <code>calloc()</code>，从而避免申请到 tcache bin 中的 chunk。又因为此时 fast bin 中的有 chunk 的，所以不会去分配 top chunk 了，直接从 fast bin 中拿。并且由于 tcache bin 已经满了，因此在 <code>_int_malloc()</code> 中从 fast bin 拿到 chunk 后不会放入 tcache bin 而是直接返回这个 chunk。接下来看看执行过程</p>
<ol>
<li><strong>malloc() 执行前：</strong><ul>
<li><code>fastbinsY[0x20] -> a -> b -> a</code></li>
</ul>
</li>
<li><strong>第一次 malloc()：</strong><ul>
<li>fast bin 是先进后出，所以先获取到第二个 free 的 a</li>
<li><code>fastbinsY[0x20] -> b -> a</code></li>
</ul>
</li>
<li><strong>第二次 malloc()：</strong><ul>
<li>然后获取到 b</li>
<li><code>fastbinsY[0x20] -> a</code></li>
</ul>
</li>
<li><strong>第三次 malloc()：</strong><ul>
<li>最后获取到第一个 free 的 a</li>
<li><code>fastbinsY[0x20] -> NULL</code></li>
</ul>
</li>
</ol>
<p>由于第一次和第三次 <code>malloc()</code> 获取到的都是 a，所以这两次获取到了完成一样的地址，那么修改其中一个的内存就可以影响到另一个，从而实现利用</p>
</li>
</ul>
<h3 id="执行分析"><a href="#执行分析" class="headerlink" title="执行分析"></a>执行分析</h3><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_run_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_run_1.png"></a>

<p>观察执行结果，可以发现，第二次申请 3 个内存块时，第1次和第2次获取到了相同的地址</p>
<h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>接下来，我们通过 pwndbg 简单调试一下程序，并观察 3 次 <code>free</code> 前后堆空间的变化，通过 <code>bins</code> 指令可以查看堆空间：</p>
<ol>
<li><p><strong>free() 开始前：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_1.png"></a>
</li>
<li><p><strong>第一次 free(a) ：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_2.png"></a>
</li>
<li><p><strong>free(b) ：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_3.png"></a>
</li>
<li><p><strong>第二次 free(a)：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_4.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/fastbin_dup_dbg_4.png"></a>


</li>
</ol>
<p>经过调试，观察 3 次 <code>free</code> 执行前后堆中的变化，可以发现这和前面源码分析时的推论是一致的，第二次 malloc 3 个 内存块的就不贴图了，这里推荐亲自动手调试一下，和前面的结论也是一致的。有一点需要补充说明，<strong>图中 bins 显示的 tcache bin 与 fast bin 中的是 chunk 地址，而 free 的参数是一个指向数据区的指针，即 chunk+2*SIZE_SZ（64 位下为  chunk+0x10）的位置</strong>，这一点在调试时需要注意转换。</p>
<h3 id="原理小结"><a href="#原理小结" class="headerlink" title="原理小结"></a>原理小结</h3><ul>
<li>这个例子演示了经典的 double free 场景，通过对同一个指针 <code>free</code> 2次，使得 fast bin 中存在相同地址的 chunk，从而影响用户后续通过 <code>malloc</code> 申请的内存</li>
<li>在 glibc2.26 引入 tcache 后，则需要先填充 tcache，再进行 double free</li>
<li>在掌握 malloc/free 相关的源码后，对于其中的利用手法理解也会更加透彻，所以推荐学习 how2heap 前先了解相关源码</li>
</ul>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_code_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_code_1.png"></a>

<ul>
<li><p><strong>橙色方框：</strong></p>
<ol>
<li>定义一个指针 a，未初始化</li>
<li>定义一个数组 fake_chunks，位于栈空间中，大小为 10，共 80/0x50 字节，用于设置 fake chunk</li>
</ol>
</li>
<li><p><strong>蓝色方框：</strong></p>
<ol>
<li>设置 fake_chunks[1] 的值为 0x40</li>
<li>这条语句的目的是构造一个 chunk。chunk 前 4 个位置通常为 prev_size、size、fd 和 bk</li>
<li>当 chunk 处于 inuse 状态下，其 fd 与 bk 字段用于存放数据，其中 fd 所在的地址正是返回给用户的指针所指向的地址</li>
<li>此语句的意图，设置一个 fake chunk 的 size 值为 0x40 </li>
</ol>
</li>
<li><p><strong>红色方框：</strong></p>
<ol>
<li>将指针 a 初始化为 fake_chunk[2] 处的地址</li>
<li>假设我们构造的这个 fake chunk 表示一个实际的 chunk，那么 <code>&fake_chunk[0]</code> 表示 chunk 首地址，<code>&fake_chunk[2]</code> 则是 <code>malloc()</code> 申请该 chunk 时返回的地址。</li>
<li><strong>此语句的意图正是让 a 成为一个申请了 fake chunk 的指针</strong></li>
<li>然后将指针 a 给 free 掉，让这个 fake chunk 释放到 tcache bin 中</li>
</ol>
</li>
<li><p><strong>粉色方框：</strong></p>
<ol>
<li><p><strong>注意一点，我们设置了 fake chunk 的 size 是 0x40，这个是 chunk 的大小，chunk 的前两个字段需要存储 prev_size 与 chunk，因此 0x40 大小的 chunk 实际容量是 0x30。那么我们申请 0x30 大小的内存时，就会分配给我们一个 0x40 大小的 chunk</strong></p>
</li>
<li><p>当然，我还需要补充一点，虽然 0x40 大小的 chunk 实际容量是 0x30，但是 chunk 的 prev_size 是一个很有意思的字段，<strong>如果 prev_chunk 处于 inuse 状态下，那么这个字段将会用于存放 prev_chunk 的数据</strong>。换句话说，下一个 chunk 的 prev_size 字段，也可以拿来用，这个字段在 64 位系统上占 0x8 个字节。那么，如果我申请一个 0x38 大小的空间， 也只会分配给我一个 0x40 大小的 chunk，因为 0x30 的空间来源于分配的 chunk 容量，还有 0x8 字节来源于下一个 chunk。那么就会有人说了，我申请 0x30 字节的空间，为什么不能分配一个 0x38 大小的 chunk，其中 0x28 来源于 chunk，0x8 来源于下一个 chunk，这当然是不行的，因为在 64 位系统上 chunk 本身要按照 0x10 字节对齐</p>
</li>
<li><p>明白了上面的原理，就能清楚这里为什么 malloc 一个 0x30 字节大小，这是为了让指针 b 获取到之前 free 掉的 0x40 大小的 fake chunk，如下图所示，b 指针会指向 fake_chunk[2] 的位置</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_code_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_code_2.png"></a>



</li>
</ol>
</li>
</ul>
<h3 id="执行分析-1"><a href="#执行分析-1" class="headerlink" title="执行分析"></a>执行分析</h3><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_run_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_run_1.png"></a>

<p>根据执行信息，这里可以看到 fake_chunk[1] 与 fake_chunk[2] 的位置，分别对应 fake_chunk 的 size 和返回给用户的指针，不过这里看的不明显，还是从调试角度看看</p>
<h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><ol>
<li><p>fake_chunk 初始在栈中，fake_chunk[1] 被赋值给 0x40，地址为 0x7fffffffdd18。根据前面的推论，可以得知：</p>
<ul>
<li><strong>首地址为  0x7fffffffdd10 的 chunk 会进入 tcache bin，由于 tcache bin 是通过 fd 访问的，所以进入后链入的位置是  0x7fffffffdd20</strong></li>
<li>地址 0x7fffffffdd20 除了作为 fd 存在，同样也是返回给用户的地址，即经过 <code>malloc()</code> 申请的得到的地址</li>
</ul>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_dbg_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_dbg_1.png"></a>
</li>
<li><p>经过 <code>free</code> 后进入 tcache bin 的地址为 0x7fffffffdd20</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_dbg_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_dbg_2.png"></a>
</li>
<li><p>经过 <code>malloc()</code> 后得到地址 0x7fffffffdd20，即 fake_chunk[2] 的地址</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_dbg_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_house_of_spirit_dbg_3.png"></a>
</li>
<li><p>与执行分析的结果不同，是因为默认开启了 ASLR</p>
</li>
</ol>
<h3 id="原理小结-1"><a href="#原理小结-1" class="headerlink" title="原理小结"></a>原理小结</h3><ul>
<li>本例演示了经典的 house of spirit 场景，通过伪造 chunk 实现任意地址写入</li>
<li>由于 glibc2.26 开始引入了 tcache，house of spirit 也增加了 tcache 的应用场景</li>
<li>原理通过伪造一个 chunk，并将其 free，使得之后的用户可以申请到我们伪造的 chunk，该 chunk 的地址可以是任意的，本例中以栈空间中的地址为例进行了演示</li>
</ul>
<h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h2><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>这个源码有点长，就不分析完整版了。这里删除些不影响程序执行的描述性语句，弄个简化版来分析</p>
<h4 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h4><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_fullcode_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_fullcode_1.png"></a>

<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_fullcode_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_fullcode_2.png"></a>



<h4 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h4><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_simplecode_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_simplecode_1.png"></a>

<ul>
<li><p><strong>橙色方框：</strong></p>
<ol>
<li><p>先用 <code>malloc()</code> 申请了 3 个块，然后将这三个块填充为 1、2、3</p>
</li>
<li><p>之所以申请的大小是 <code>0x80 - 8、0x500 - 8</code> 这种形式，在前面讲 tcache_house_of_spirit 是已提及，就是<strong>当一个 chunk 处于 inuse 状态时，它是可以使用下一个 chunk 的 prev_size 位来存储数据的</strong>，所以例如，p1 申请了 0x78 字节的空间，那么最终分配给它的是一个大小为 0x80 字节的 chunk。这一顿操作完，堆中的情形大致如下（注意：这里是为了演示方便，因此每个块只标了 4 字节，实际应该是 8 字节）：</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_simplecode_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_simplecode_2.png"></a>
</li>
</ol>
</li>
<li><p><strong>蓝色方框：</strong></p>
<ol>
<li>设置了俩值，其中 evil_chunk_size，设置为了 0x581，也就是 p2 + p3 这两个 chunk 的大小</li>
<li>evil_region_size 则用于 <code>malloc()</code> 的参数，申请一个 <code>0x580 - 8</code> 的内存，最终会被分配 0x580 大小的 chunk</li>
</ol>
</li>
<li><p><strong>红色方框：</strong></p>
<ol>
<li><p>这里先修改了 p2 的 size 位为 0x581，然后将其 free，这样进入 large bin 的就是一个 0x580 大小的 chunk</p>
</li>
<li><p>当再次申请一个 0x580 大小的块时，large bin 中刚好有一个，就会将这个 chunk 返回给用户</p>
</li>
<li><p>这里 p4 拿到的就是这个 0x580 大小的块，下图红色区域框出了 p2 与 p4 对应 chunk 的范围，这里可以明显看出，p4 与 p2 的起始地址一样，但是 p4 包含了 p3 区域<strong>（注意：这里是为了演示方便，因此每个块只标了 4 字节，实际应该是 8 字节）</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_simplecode_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_simplecode_3.png"></a>
</li>
</ol>
</li>
<li><p><strong>粉色方框：</strong></p>
<ol>
<li>这部分主要对比观察 p4、p3 所指区域覆盖前后的变化</li>
<li>由于 p4 包含了 p3 的区域，所以结果会比较明显</li>
</ol>
</li>
</ul>
<h3 id="执行分析-2"><a href="#执行分析-2" class="headerlink" title="执行分析"></a>执行分析</h3><p>由于源码很长，并且示例中申请了一个 large bin chunk， 执行结果也比较长，截图也分为两部分：</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_run_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_run_1.png"></a>

<ul>
<li>从这部分的执行结果来看，p2 与 p4 起始地址相同，p4 则与 p3 的结束地址相同</li>
</ul>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_run_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/overlapping_chunks_run_2.png"></a>

<ul>
<li>这部分就是对 p4，p3 执行 <code>memset()</code> 前后的对比了，可以看出来，由于 p4、p3 占了同样的空间，所以覆盖 p3 的区域，会直接影响到 p4 区域</li>
</ul>
<h3 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h3><p>这部分的示例代码写的很细，通过执行结果就可以验证源码分析时的推论了，因此就不再进行调试分析了</p>
<h3 id="原理小结-2"><a href="#原理小结-2" class="headerlink" title="原理小结"></a>原理小结</h3><ul>
<li>本例通过<strong>修改 chunk 的 size 来实现与后向的 chunk 合并，此修改操作可通过前向的 chunk 溢出来实现</strong></li>
<li>chunk 合并会而导致新申请的内存块与先前申请的内存块存在相同的区域，可能是包含关系，从而可以通过修改旧内存块中的值来影响新申请的内存块 </li>
</ul>
<h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><h3 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="完整版-1"><a href="#完整版-1" class="headerlink" title="完整版"></a>完整版</h4><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_fullcode_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_fullcode_1.png"></a>

<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_fullcode_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_fullcode_2.png"></a>

<h4 id="简化版-1"><a href="#简化版-1" class="headerlink" title="简化版"></a>简化版</h4><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_1.png"></a>

<ul>
<li><p><strong>橙色方框：</strong></p>
<ol>
<li><p>本例实现了一个任意地址写入，写入的这个地址就是这里定义的全局变量 chunk0_ptr 所在的地址，即 &chunk0_ptr</p>
</li>
<li><p>全局变量与局部变量不同，局部变量位于栈中，全局变量位于堆中，这里的 chunk0_ptr 是一个指针，会指向一个地址，而这个指针自己，也位于堆中的某个地址</p>
</li>
<li><p><strong>可以通过 <code>chunk0_ptr 或者 chunk0_ptr[0]</code> 来访问 chunk0_ptr 所指向内存区域的第一个元素</strong></p>
</li>
<li><p><strong>可以通过 <code>&chunk0_ptr</code> 来访问 <code>chunk0_ptr</code> 这个全局变量指针所在的地址</strong></p>
</li>
<li><p>通过 <code>malloc()</code> 申请了两个 0x420 大小的空间，获取两个 0x430 大小的 chunk，目前的情况大概如下图所示：</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_2.png"></a>
</li>
</ol>
</li>
<li><p><strong>蓝色方框：</strong></p>
<ol>
<li><p>修改 chunk0_ptr 区域中的内容，伪造了一个包含 size、fd、bk 字段的 fake chunk</p>
</li>
<li><p>需要注意<strong>这里用到了 &chunk0_ptr 附近的地址作为 fd、bk 的值</strong>，在下图中标出</p>
</li>
<li><p>其实这波操作很秀，根据下图的情况，我们可以发现，<code>fake_chunk->fd->bk == chunk0_ptr</code> 并且 <code>fake_chunk->bk->fd == chunk0_ptr</code>。这样在进行 unlink 时就可以过掉双链表完整性的校验了</p>
</li>
<li><p>为了防止以后忘记，这里再提一嘴，<strong>假设 p 指向一个 chunk 的开头。那么 p->fd 就是找 p + 2xSIZE_SZ 的位置处的值，p->bk 就是找 p + 3xSIZE_SZ 处的值</strong>。理论上这两处的值都是一个指针，指向另一个 chunk </p>
</li>
<li><p>修改 chunk1_ptr 中的 prev_size 字段，使得 chunk1_ptr 的前一个 chunk 成为先前伪造的 fake chunk，并设置 fake chunk 为 free 状态</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_3.png"></a>
</li>
</ol>
</li>
<li><p><strong>红色方框：</strong></p>
<ol>
<li><p>这是对 chunk1_ptr 执行的一次 free 操作，但是涉及到的东西很多</p>
</li>
<li><p>由于上一步将 chunk1_ptr 的 prev_inuse 设置为了 0，因此在 free 一个非 fast bin 大小的 chunk 时，会触发对前一个 chunk（正是先前伪造的 fake chunk） 的合并，其中会对前一个 chunk 进行 <code>unlink_chunk()</code> 操作，参考下图中部分 <code>_int_free()</code> 相关的源码</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_4.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_4.png"></a>
</li>
<li><p>图中已圈出关键的链表操作代码，断链时的语句可以简单概括如下：</p>
<ul>
<li><code>p->fd->bk = p->bk</code></li>
<li><code>p->bk->fd = p->fd</code></li>
</ul>
</li>
<li><p>然而，此处：</p>
<ul>
<li><code>p->fd->bk == p->bk->fd == chunk0_ptr</code></li>
<li><code>&(p->fd->bk) == &(p->bk->fd) == &chunk0_ptr</code></li>
</ul>
</li>
<li><p>所以<strong>这里执行的  <code>unlink_chunk()</code> 操作，最终就是先将 <code>p->bk</code> 的值写入 <code>&chunk0_ptr</code>，再将 <code>p->fd</code> 的值写入 <code>&chunk0_ptr</code>，将前面写入的值覆盖掉</strong>。这个过程大致如下图（图只是给个印象，不完全对，因为 chunk1_ptr 是第二个申请的，后面也没有别的申请的块了，所以大概率会在后向合并时被 top chunk 给合并，我这里画出来的是完成 <code>unlink_chunk()</code> 后的状态，而不是 <code>free()</code>  执行完后的状态，所以调试时看到的图会与这里的有所出入）：</p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_5.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_5.png"></a>
</li>
</ol>
</li>
<li><p><strong>粉色方框：</strong></p>
<ol>
<li><p>最后这一步，有点绕，如果不去调试是看不出来的，因为平时指针可能都是作为局部变量放在栈中，是通过 rsp/rbp 进行寻址的，这里不一样，它需要先获取到全局变量的地址，这个全局变量的地址里面的值，保存的正是指针所指向的地址</p>
</li>
<li><p>具体来说就是它在给 chunk0_ptr[3] 赋值的时候，不是像我们所理解的那样，直接在 chunk0_ptr[3] 的位置去赋值</p>
</li>
<li><p>而且<strong>先访问 &chunk0_ptr，这是全局变量指针的地址， &chunk0_ptr 这个地址保存的值正是 chunk0_ptr 指针所指向的地址</strong></p>
</li>
<li><p>这里 &chunk0_ptr 处保存的值因为 <code>unlink_chunk()</code> 已经被修改为了 &chunk0_ptr - 3xSIZE_EZ，所以此时我们访问 chunk0_ptr[3] 就会变成这样：</p>
<p><code>chunk0_ptr[3] == &chunk0_ptr - 3*SIZE_EZ + 3*SIZE_EZ == &chunk0_ptr</code> </p>
<p>也就是说，<strong>此时 chunk0_ptr[3] 所指的位置与 &chunk0_ptr 所指的位置是一样的</strong>，这点有点绕，慢慢理解</p>
</li>
<li><p>然后赋值，给赋了一个字符串的地址，这里用 &string 表示，此时 &chunk0_ptr 处的值又变成了字符串的地址 &string，<strong>也就是说此时 chunk0_ptr 指向的是字符串</strong></p>
</li>
<li><p>最后再给 chunk0_ptr[0] 进行赋值，根据第 3 步说的，这里 chunk0_ptr[0] 其实是 &string[0]，因此就是在改刚刚赋值的字符串，因此最后会发现字符串变了。<strong>这里的操作已经和 chunk0_ptr 原本指向的堆空间没什么关系了，因为它现在已经指向了自身这个全局变量所在的堆空间中</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_6.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_simplecode_6.png"></a>



</li>
</ol>
</li>
</ul>
<h3 id="执行分析-3"><a href="#执行分析-3" class="headerlink" title="执行分析"></a>执行分析</h3><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_run_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_run_1.png"></a>

<p>这题的描述写的不够细，但仍然可以看出 2 点：</p>
<ul>
<li>伪造的 fake chunk 的 fd/bk 指向 &chunk0_ptr 附近，即这个全局变量指针所在堆空间的附近，而不是它指向的堆空间附近</li>
<li>字符串可以被覆盖</li>
</ul>
<h3 id="调试分析-3"><a href="#调试分析-3" class="headerlink" title="调试分析"></a>调试分析</h3><ol>
<li><p><strong>第一次 <code>malloc()</code>后：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_1.png"></a>

<ul>
<li><code>malloc()</code> 申请到的地址为 0x5555555592a0</li>
<li>全局变量指针的地址为 0x555555558020，虽然全局变量地址是固定的，但它每次会通过 RIP + 偏移的形式计算得来</li>
<li>在 <code>malloc()</code> 获取到申请的地址后，会将其赋值给全局变量指针</li>
</ul>
</li>
<li><p><strong><code>printf()</code> fake chunk bk 后：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_2.png"></a>

<ul>
<li>选择这里是因为，此时 fake chunk 已经伪造好了</li>
<li>可以看到 fake chunk 相比原先 chunk0_ptr 所指的位置后移了  0x10</li>
<li>原先指向 0x00005555555592a0，chunk 位于 0x0000555555559290，现在 chunk 位于 0x00005555555592a0</li>
<li>同时设置了 fd 为 0x0000555555558008，bk 为 0x0000555555558010</li>
<li>然后往上看，会发现 fd 和 bk，这两处目前都有值，但这不重要，因为这两个处的值理应是 prev_size 才对</li>
<li>然后会发现 fd->bk 刚好是 0x00005555555592a0，bk->fd 也是 0x00005555555592a0，所以就可以过掉 <code>unlink_chunk()</code> 时对链表完整性的一次 check 了</li>
</ul>
</li>
<li><p><strong><code>free()</code> 执行后：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_3.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_3.png"></a>

<ul>
<li><p>先看橙色框，这个值很大，说明一点，chunk1_ptr 在被 free 后，先和我们伪造的 fake chunk 合并了，然后又直接和后面的 top chunk 合并了，因此 fake chunk 直接成为了新的 top chunk</p>
</li>
<li><p>红色框比较关键，它的值为 chunk0_ptr 指向的地址，原本这个值指向了 0x00005555555592a0，也就是一开始 <code>malloc()</code> 获得的地址，现在它指向了 0x0000555555558008，之所以会这样，是因为在 <code>unlink_chunk()</code> 中先后执行了：</p>
<ul>
<li><code>fd->bk = bk</code></li>
</ul>
</li>
<li><p><code>bk->fd = fd</code></p>
<p>前面已经提到过 fd->bk 与 bk->fd 是相等的，这个位置就是 0x0000555555558020 这个地址，也就是说，先后给 0x0000555555558020 这个地址赋值 bk 与 fd，fd 则是 0x00005555555592b0 处的值，也就是 0x0000555555558008。所以此时 0x0000555555558020 处的值就被修改为了 0x0000555555558008</p>
</li>
<li><p>为什么说这步很关键呢？<strong>因为 0x0000555555558020 存的是 chunk0_ptr 这个指针指向的地址，此时这个值为 0x0000555555558008，那么接下来我们要访问 chunk0_ptr[0] 也就是访问 0x0000555555558008，访问 chunk0_ptr[3] 也就是访问 0x0000555555558020</strong></p>
</li>
</ul>
</li>
<li><p><strong>赋值 chunk0_ptr[3] 后：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_4.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_4.png"></a>

<ul>
<li>可以看到给 chunk0_ptr[3] 赋值，其实就是给 0x0000555555558020 赋值，此时赋值为字符串的地址</li>
<li>此时  0x0000555555558020 的值已经修改为了 0x00007fffffffdd70</li>
<li>那么接下来若给 chunk0_ptr[0] 赋值，就是给  0x00007fffffffdd70 处赋值，若给 chunk0_ptr[3] 赋值，就是给 0x00007fffffffdd88 赋值</li>
</ul>
</li>
<li><p><strong>赋值 chunk0_ptr[0] 后：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_5.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/unsafe_unlink_dbg_5.png"></a>

<ul>
<li>从这里也可以看出，当我们再次尝试给 chunk0_ptr 赋值时，其实就是给字符串所在的地址赋值，这样就实现了修复字符串的操作，正如执行结果中显示的那样</li>
</ul>
</li>
</ol>
<h3 id="原理小结-3"><a href="#原理小结-3" class="headerlink" title="原理小结"></a>原理小结</h3><ul>
<li>通过在一个正常申请的 chunk 中伪造一个空闲状态的 fake chunk（可通过溢出实现），使得在 <code>free</code> 过程中可将其合并</li>
<li>合并时会调用 <code>unlink_chunk()</code>，该函数会使用伪造的 fd 影响原先指针的值</li>
<li>若对原先的指针进行新的赋值（例如一个地址），则可在后续操作中对这个地址进行写入，从而达到任意地址写入的操作</li>
<li>本例是这一篇中最难理解的，核心在于对访问指针指向元素过程的了解，必要时仍需调试弄明白执行细节</li>
</ul>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><h3 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h3><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_code_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_code_1.png"></a>

<ul>
<li><p><strong>橙色方框：</strong></p>
<p>先 <code>malloc()</code> 2 个能容纳 0x80 大小的空间，再将它们先后释放到 tcache 中，由于 b 是后释放的，所以 tcache 中排布大致为：<code>tcache -> b -> a</code></p>
</li>
<li><p><strong>红色方框：</strong></p>
<p>将 b[0] 设置为局部变量 stack_var 在栈中的地址，实际作用是修改 tcache_entry->next 为 stack_var 的地址，此时 tcache 中排布为：<code>tcache -> b -> &stack_var</code></p>
</li>
<li><p><strong>蓝色方框：</strong></p>
<p>先 <code>malloc()</code> 一次，把 b 申请走，然后再 <code>malloc()</code> 一次，此时获取到的不是 a 而实 &stack_var</p>
</li>
</ul>
<h3 id="执行分析-4"><a href="#执行分析-4" class="headerlink" title="执行分析"></a>执行分析</h3><a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_run_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_run_1.png"></a>

<p>执行结果很清晰，不多讲了，结合源码很容易看明白</p>
<h3 id="调试分析-4"><a href="#调试分析-4" class="headerlink" title="调试分析"></a>调试分析</h3><ol>
<li><p><strong>两次 <code>free()</code> 后：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_dbg_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_dbg_1.png"></a>
</li>
<li><p><strong>修改 <code>tcache_entry -> next</code> 后：</strong></p>
<a href="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_dbg_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/tcache_poisoning_dbg_2.png"></a>

<ul>
<li>这里原本 a 对应的 chunk 被修改为了栈中的地址</li>
<li>在申请完 0x555555559330 后，再申请就会申请到这个地址</li>
</ul>
</li>
</ol>
<h3 id="原理小结-4"><a href="#原理小结-4" class="headerlink" title="原理小结"></a>原理小结</h3><ul>
<li>原来很简单，UAF 的手法修改 tcache，实现将 tcache 中的某个 chunk 修改为任意地址</li>
<li>但是从 glibc2.32 开始，增加了 PROTECT_PTR 保护机制，需通过找到一个 0x10 对齐的地址，仍可以实现任意地址写入，本篇基于 glibc2.31 进行分析，故对此机制不进行展开</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://bbs.pediy.com/thread-272416.htm" target="_blank" rel="noopener">看雪：how2heap深入浅出学习堆利用</a></li>
<li><a href="https://github.com/fr0ster/how2heap" target="_blank" rel="noopener">Github：shellphish/how2heap</a></li>
</ol>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">cataLoc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://cata1oc.github.io/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/">http://cata1oc.github.io/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全    </a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/08/10/%E5%A0%86%E5%9F%BA%E7%A1%8004-how2heap%E5%85%A5%E9%97%A8%E7%AF%87/cover0x62.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/08/16/%E5%A0%86%E5%9F%BA%E7%A1%8005-how2heap%E5%88%9D%E7%BA%A7%E7%AF%87/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>堆基础05-how2heap初级篇</span></div></a></div><div class="next-post pull_right"><a href="/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0x61.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>堆基础03：free源码分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/10/31/初探GOT与PLT/" title="初探GOT与PLT"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/10/31/%E5%88%9D%E6%8E%A2GOT%E4%B8%8EPLT/cover0x4C.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-31</div><div class="relatedPosts_title">初探GOT与PLT</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/07/缓冲区溢出入门-上/" title="缓冲区溢出入门(上)"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/11/07/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%85%A5%E9%97%A8-%E4%B8%8A/cover0x4D.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-07</div><div class="relatedPosts_title">缓冲区溢出入门(上)</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/13/缓冲区溢出入门-下/" title="缓冲区溢出入门(下)"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/11/13/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%85%A5%E9%97%A8-%E4%B8%8B/cover0x4E.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-13</div><div class="relatedPosts_title">缓冲区溢出入门(下)</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/02/AFL源码分析01/" title="AFL源码分析01：afl-gcc.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/02/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001/cover0x50.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-02</div><div class="relatedPosts_title">AFL源码分析01：afl-gcc.c</div></div></a></div><div class="relatedPosts_item"><a href="/2021/12/22/AFL环境搭建/" title="AFL环境搭建"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/12/22/AFL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/cover0x4F.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-12-22</div><div class="relatedPosts_title">AFL环境搭建</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/05/AFL源码分析02/" title="AFL源码分析02：afl-as.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/05/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/cover0x51.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-05</div><div class="relatedPosts_title">AFL源码分析02：afl-as.c</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By cataLoc</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>