<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>AFL源码分析04：afl-fuzz.c | cataLoc's Blog</title><meta name="description" content="AFL源码分析04：afl-fuzz.c"><meta name="keywords" content="二进制安全,Fuzzing"><meta name="author" content="cataLoc"><meta name="copyright" content="cataLoc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="AFL源码分析04：afl-fuzz.c"><meta name="twitter:description" content="AFL源码分析04：afl-fuzz.c"><meta name="twitter:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/cover0x53.png"><meta property="og:type" content="article"><meta property="og:title" content="AFL源码分析04：afl-fuzz.c"><meta property="og:url" content="http://cata1oc.github.io/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/"><meta property="og:site_name" content="cataLoc's Blog"><meta property="og:description" content="AFL源码分析04：afl-fuzz.c"><meta property="og:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/cover0x53.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'true'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://cata1oc.github.io/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/"><link rel="prev" title="AFL源码分析05：fuzz_one" href="http://cata1oc.github.io/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/"><link rel="next" title="AFL源码分析03：afl-as.h" href="http://cata1oc.github.io/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">cataLoc's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/Substitute.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#afl-fuzz-c源码分析（初始配置）"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">afl-fuzz.c源码分析（初始配置）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#关键变量"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">关键变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setup-signal-handlers"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">setup_signal_handlers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#check-asan-opts"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">check_asan_opts</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#fix-up-sync"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">fix_up_sync</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#save-cmdline"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">save_cmdline</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#fix-up-banner"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">fix_up_banner</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#check-if-tty"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">check_if_tty</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CPU检查相关函数"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">CPU检查相关函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setup-post"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">setup_post</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setup-shm"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">setup_shm</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#init-count-class16"><span class="toc_mobile_items-number">2.11.</span> <span class="toc_mobile_items-text">init_count_class16</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setup-dirs-fds"><span class="toc_mobile_items-number">2.12.</span> <span class="toc_mobile_items-text">setup_dirs_fds</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#read-testcases"><span class="toc_mobile_items-number">2.13.</span> <span class="toc_mobile_items-text">read_testcases</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#add-to-queue"><span class="toc_mobile_items-number">2.14.</span> <span class="toc_mobile_items-text">add_to_queue</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#queue-entry结构体与部分相关变量"><span class="toc_mobile_items-number">2.14.1.</span> <span class="toc_mobile_items-text">queue_entry结构体与部分相关变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#源码分析"><span class="toc_mobile_items-number">2.14.2.</span> <span class="toc_mobile_items-text">源码分析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#load-auto"><span class="toc_mobile_items-number">2.15.</span> <span class="toc_mobile_items-text">load_auto</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#maybe-add-auto"><span class="toc_mobile_items-number">2.16.</span> <span class="toc_mobile_items-text">maybe_add_auto</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pivot-inputs"><span class="toc_mobile_items-number">2.17.</span> <span class="toc_mobile_items-text">pivot_inputs</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#nuke-resume-dir"><span class="toc_mobile_items-number">2.18.</span> <span class="toc_mobile_items-text">nuke_resume_dir</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#load-extras"><span class="toc_mobile_items-number">2.19.</span> <span class="toc_mobile_items-text">load_extras</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#find-timeout"><span class="toc_mobile_items-number">2.20.</span> <span class="toc_mobile_items-text">find_timeout</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#detect-file-args"><span class="toc_mobile_items-number">2.21.</span> <span class="toc_mobile_items-text">detect_file_args</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setup-stdio-file"><span class="toc_mobile_items-number">2.22.</span> <span class="toc_mobile_items-text">setup_stdio_file</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#check-binary"><span class="toc_mobile_items-number">2.23.</span> <span class="toc_mobile_items-text">check_binary</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#get-cur-time"><span class="toc_mobile_items-number">2.24.</span> <span class="toc_mobile_items-text">get_cur_time</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#get-qemu-argv"><span class="toc_mobile_items-number">2.25.</span> <span class="toc_mobile_items-text">get_qemu_argv</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#perform-dry-run"><span class="toc_mobile_items-number">2.26.</span> <span class="toc_mobile_items-text">perform_dry_run</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#calibrate-case"><span class="toc_mobile_items-number">2.27.</span> <span class="toc_mobile_items-text">calibrate_case</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#init-forkserver"><span class="toc_mobile_items-number">2.28.</span> <span class="toc_mobile_items-text">init_forkserver</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#关于文件共享"><span class="toc_mobile_items-number">2.28.1.</span> <span class="toc_mobile_items-text">关于文件共享</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#dup-dup2的用途"><span class="toc_mobile_items-number">2.28.2.</span> <span class="toc_mobile_items-text">dup&#x2F;dup2的用途</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#源码分析-1"><span class="toc_mobile_items-number">2.28.3.</span> <span class="toc_mobile_items-text">源码分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#流程梳理"><span class="toc_mobile_items-number">2.28.4.</span> <span class="toc_mobile_items-text">流程梳理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#has-new-bits"><span class="toc_mobile_items-number">2.29.</span> <span class="toc_mobile_items-text">has_new_bits</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#count-bytes"><span class="toc_mobile_items-number">2.30.</span> <span class="toc_mobile_items-text">count_bytes</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#run-target"><span class="toc_mobile_items-number">2.31.</span> <span class="toc_mobile_items-text">run_target</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#classify-count"><span class="toc_mobile_items-number">2.32.</span> <span class="toc_mobile_items-text">classify_count</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#update-bitmap-score"><span class="toc_mobile_items-number">2.33.</span> <span class="toc_mobile_items-text">update_bitmap_score</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#minimize-bits"><span class="toc_mobile_items-number">2.34.</span> <span class="toc_mobile_items-text">minimize_bits</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#cull-queue"><span class="toc_mobile_items-number">2.35.</span> <span class="toc_mobile_items-text">cull_queue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#mark-as-reduntant"><span class="toc_mobile_items-number">2.36.</span> <span class="toc_mobile_items-text">mark_as_reduntant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#show-init-stats"><span class="toc_mobile_items-number">2.37.</span> <span class="toc_mobile_items-text">show_init_stats</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#find-start-position"><span class="toc_mobile_items-number">2.38.</span> <span class="toc_mobile_items-text">find_start_position</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#write-stats-file"><span class="toc_mobile_items-number">2.39.</span> <span class="toc_mobile_items-text">write_stats_file</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#save-auto"><span class="toc_mobile_items-number">2.40.</span> <span class="toc_mobile_items-text">save_auto</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考资料"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-fuzz-c源码分析（初始配置）"><span class="toc-number">2.</span> <span class="toc-text">afl-fuzz.c源码分析（初始配置）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键变量"><span class="toc-number">2.1.</span> <span class="toc-text">关键变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-signal-handlers"><span class="toc-number">2.2.</span> <span class="toc-text">setup_signal_handlers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-asan-opts"><span class="toc-number">2.3.</span> <span class="toc-text">check_asan_opts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fix-up-sync"><span class="toc-number">2.4.</span> <span class="toc-text">fix_up_sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#save-cmdline"><span class="toc-number">2.5.</span> <span class="toc-text">save_cmdline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fix-up-banner"><span class="toc-number">2.6.</span> <span class="toc-text">fix_up_banner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-if-tty"><span class="toc-number">2.7.</span> <span class="toc-text">check_if_tty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU检查相关函数"><span class="toc-number">2.8.</span> <span class="toc-text">CPU检查相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-post"><span class="toc-number">2.9.</span> <span class="toc-text">setup_post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-shm"><span class="toc-number">2.10.</span> <span class="toc-text">setup_shm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-count-class16"><span class="toc-number">2.11.</span> <span class="toc-text">init_count_class16</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-dirs-fds"><span class="toc-number">2.12.</span> <span class="toc-text">setup_dirs_fds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-testcases"><span class="toc-number">2.13.</span> <span class="toc-text">read_testcases</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-to-queue"><span class="toc-number">2.14.</span> <span class="toc-text">add_to_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-entry结构体与部分相关变量"><span class="toc-number">2.14.1.</span> <span class="toc-text">queue_entry结构体与部分相关变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码分析"><span class="toc-number">2.14.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-auto"><span class="toc-number">2.15.</span> <span class="toc-text">load_auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maybe-add-auto"><span class="toc-number">2.16.</span> <span class="toc-text">maybe_add_auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pivot-inputs"><span class="toc-number">2.17.</span> <span class="toc-text">pivot_inputs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nuke-resume-dir"><span class="toc-number">2.18.</span> <span class="toc-text">nuke_resume_dir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-extras"><span class="toc-number">2.19.</span> <span class="toc-text">load_extras</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-timeout"><span class="toc-number">2.20.</span> <span class="toc-text">find_timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detect-file-args"><span class="toc-number">2.21.</span> <span class="toc-text">detect_file_args</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-stdio-file"><span class="toc-number">2.22.</span> <span class="toc-text">setup_stdio_file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-binary"><span class="toc-number">2.23.</span> <span class="toc-text">check_binary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-cur-time"><span class="toc-number">2.24.</span> <span class="toc-text">get_cur_time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-qemu-argv"><span class="toc-number">2.25.</span> <span class="toc-text">get_qemu_argv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#perform-dry-run"><span class="toc-number">2.26.</span> <span class="toc-text">perform_dry_run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calibrate-case"><span class="toc-number">2.27.</span> <span class="toc-text">calibrate_case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-forkserver"><span class="toc-number">2.28.</span> <span class="toc-text">init_forkserver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于文件共享"><span class="toc-number">2.28.1.</span> <span class="toc-text">关于文件共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup-dup2的用途"><span class="toc-number">2.28.2.</span> <span class="toc-text">dup&#x2F;dup2的用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码分析-1"><span class="toc-number">2.28.3.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流程梳理"><span class="toc-number">2.28.4.</span> <span class="toc-text">流程梳理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#has-new-bits"><span class="toc-number">2.29.</span> <span class="toc-text">has_new_bits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count-bytes"><span class="toc-number">2.30.</span> <span class="toc-text">count_bytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-target"><span class="toc-number">2.31.</span> <span class="toc-text">run_target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classify-count"><span class="toc-number">2.32.</span> <span class="toc-text">classify_count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update-bitmap-score"><span class="toc-number">2.33.</span> <span class="toc-text">update_bitmap_score</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#minimize-bits"><span class="toc-number">2.34.</span> <span class="toc-text">minimize_bits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cull-queue"><span class="toc-number">2.35.</span> <span class="toc-text">cull_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-as-reduntant"><span class="toc-number">2.36.</span> <span class="toc-text">mark_as_reduntant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#show-init-stats"><span class="toc-number">2.37.</span> <span class="toc-text">show_init_stats</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-start-position"><span class="toc-number">2.38.</span> <span class="toc-text">find_start_position</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-stats-file"><span class="toc-number">2.39.</span> <span class="toc-text">write_stats_file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#save-auto"><span class="toc-number">2.40.</span> <span class="toc-text">save_auto</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/cover0x53.png)"><div id="post-info"><div id="post-title"><div class="posttitle">AFL源码分析04：afl-fuzz.c</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2022-02-06<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2022-05-17</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇是对afl-fuzz.c中初始化部分的函数进行分析，由于源码过于庞大，部分较为简单的函数或者内容冗余的函数就不详细分析了，将只会摘取出部分源码进行解析。</p>
<h2 id="afl-fuzz-c源码分析（初始配置）"><a href="#afl-fuzz-c源码分析（初始配置）" class="headerlink" title="afl-fuzz.c源码分析（初始配置）"></a>afl-fuzz.c源码分析（初始配置）</h2><h3 id="关键变量"><a href="#关键变量" class="headerlink" title="关键变量"></a>关键变量</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u8 *in_dir,                    <span class="comment">/* Input directory with test cases  */</span></span><br><span class="line">          *out_file,                  <span class="comment">/* File to fuzz, if any             */</span></span><br><span class="line">          *out_dir,                   <span class="comment">/* Working & output directory       */</span></span><br><span class="line">          *sync_dir,                  <span class="comment">/* Synchronization directory        */</span></span><br><span class="line">          *sync_id,                   <span class="comment">/* Fuzzer ID                        */</span></span><br><span class="line">          *use_banner,                <span class="comment">/* Display banner                   */</span></span><br><span class="line">          *in_bitmap,                 <span class="comment">/* Input bitmap                     */</span></span><br><span class="line">          *doc_path,                  <span class="comment">/* Path to documentation dir        */</span></span><br><span class="line">          *target_path,               <span class="comment">/* Path to target binary            */</span></span><br><span class="line">                                      <span class="comment">/* 在check_binary被设置为可执行文件地址*/</span></span><br><span class="line">                                      <span class="comment">/* 在get_qemu_argv被设置为afl-qemu-trace地址 */</span></span><br><span class="line">          *orig_cmdline;              <span class="comment">/* Original command line            */</span></span><br><span class="line">    </span><br><span class="line">EXP_ST u32 exec_tmout = EXEC_TIMEOUT; <span class="comment">/* Configurable exec timeout (ms)   */</span></span><br><span class="line"><span class="keyword">static</span> u32 hang_tmout = EXEC_TIMEOUT; <span class="comment">/* Timeout used for hang det (ms)   */</span>                   </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u32 stats_update_freq = <span class="number">1</span>;     <span class="comment">/* Stats update frequency (execs)   */</span></span><br><span class="line">                                      <span class="comment">/* 首次出现在calibrate_case          */</span></span><br><span class="line">    </span><br><span class="line">EXP_ST u8  skip_deterministic,        <span class="comment">/* Skip deterministic stages?       */</span></span><br><span class="line">           force_deterministic,       <span class="comment">/* Force deterministic stages?      */</span></span><br><span class="line">           use_splicing,              <span class="comment">/* Recombine input files?           */</span></span><br><span class="line">           dumb_mode,                 <span class="comment">/* Run in non-instrumented mode?    */</span></span><br><span class="line">           score_changed,             <span class="comment">/* Scoring for favorites changed?   */</span></span><br><span class="line">                                      <span class="comment">/* 首次出现在update_bitmap_score判断 */</span></span><br><span class="line">                                      <span class="comment">/* top_rated[i]中的胜者是否改变      */</span></span><br><span class="line">           kill_signal,               <span class="comment">/* Signal that killed the child     */</span></span><br><span class="line">           resuming_fuzz,             <span class="comment">/* Resuming an older fuzzing job?   */</span></span><br><span class="line">           timeout_given,             <span class="comment">/* Specific timeout given?          */</span></span><br><span class="line">           cpu_to_bind_given,         <span class="comment">/* Specified cpu_to_bind given?     */</span></span><br><span class="line">           not_on_tty,                <span class="comment">/* stdout is not a tty              */</span></span><br><span class="line">           term_too_small,            <span class="comment">/* terminal dimensions too small    */</span></span><br><span class="line">           uses_asan,                 <span class="comment">/* Target uses ASAN?                */</span></span><br><span class="line">           no_forkserver,             <span class="comment">/* Disable forkserver?              */</span></span><br><span class="line">           crash_mode,                <span class="comment">/* Crash mode! Yeah!                */</span></span><br><span class="line">           in_place_resume,           <span class="comment">/* Attempt in-place resume?         */</span></span><br><span class="line">           auto_changed,              <span class="comment">/* Auto-generated tokens changed?   */</span></span><br><span class="line">           no_cpu_meter_red,          <span class="comment">/* Feng shui on the status screen   */</span></span><br><span class="line">           no_arith,                  <span class="comment">/* Skip most arithmetic ops         */</span></span><br><span class="line">           shuffle_queue,             <span class="comment">/* Shuffle input queue?             */</span></span><br><span class="line">           bitmap_changed = <span class="number">1</span>,        <span class="comment">/* Time to update bitmap?           */</span></span><br><span class="line">           qemu_mode,                 <span class="comment">/* Running in QEMU mode?            */</span></span><br><span class="line">           skip_requested,            <span class="comment">/* Skip request, via SIGUSR1        */</span></span><br><span class="line">           run_over10m,               <span class="comment">/* Run time over 10 minutes?        */</span></span><br><span class="line">           persistent_mode,           <span class="comment">/* Running in persistent mode?      */</span></span><br><span class="line">           deferred_mode,             <span class="comment">/* Deferred forkserver mode?        */</span></span><br><span class="line">           fast_cal;                  <span class="comment">/* Try to calibrate faster?         */</span></span><br><span class="line">                                      <span class="comment">/* 若设置了环境变量AFL_FAST_CAL，则会 */</span></span><br><span class="line">                                      <span class="comment">/* 设置该值，在calibrate_case中使用   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> s32 forksrv_pid,               <span class="comment">/* PID of the fork server           */</span></span><br><span class="line">           child_pid = <span class="number">-1</span>,            <span class="comment">/* PID of the fuzzed program        */</span></span><br><span class="line">           out_dir_fd = <span class="number">-1</span>;           <span class="comment">/* FD of the lock file              */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> s32 out_fd,                    <span class="comment">/* Persistent fd for out_file       */</span></span><br><span class="line">           dev_urandom_fd = <span class="number">-1</span>,       <span class="comment">/* Persistent fd for /dev/urandom   */</span></span><br><span class="line">           dev_null_fd = <span class="number">-1</span>,          <span class="comment">/* Persistent fd for /dev/null      */</span></span><br><span class="line">                                      <span class="comment">/* 首次用于init_forkserver            */</span></span><br><span class="line">           fsrv_ctl_fd,               <span class="comment">/* Fork server control pipe (write) */</span></span><br><span class="line">           fsrv_st_fd;                <span class="comment">/* Fork server status pipe (read)   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> s32 forksrv_pid,               <span class="comment">/* PID of the fork server           */</span></span><br><span class="line">           child_pid = <span class="number">-1</span>,            <span class="comment">/* PID of the fuzzed program        */</span></span><br><span class="line">           out_dir_fd = <span class="number">-1</span>;           <span class="comment">/* FD of the lock file              */</span></span><br><span class="line"></span><br><span class="line">EXP_ST u8* trace_bits;                <span class="comment">/* SHM with instrumentation bitmap  */</span>    </span><br><span class="line"><span class="keyword">static</span> s32 shm_id;                    <span class="comment">/* ID of the SHM region             */</span></span><br><span class="line"></span><br><span class="line">EXP_ST u8  virgin_bits[MAP_SIZE],     <span class="comment">/* Regions yet untouched by fuzzing */</span></span><br><span class="line">           virgin_tmout[MAP_SIZE],    <span class="comment">/* Bits we haven't seen in tmouts   */</span></span><br><span class="line">           virgin_crash[MAP_SIZE];    <span class="comment">/* Bits we haven't seen in crashes  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8  var_bytes[MAP_SIZE];       <span class="comment">/* Bytes that appear to be variable */</span> </span><br><span class="line">                                      <span class="comment">/* 仅用于calibrate_case中            */</span></span><br><span class="line"></span><br><span class="line">EXP_ST u32 queued_paths,              <span class="comment">/* Total number of queued testcases */</span></span><br><span class="line">           queued_variable,           <span class="comment">/* Testcases with variable behavior */</span></span><br><span class="line">           queued_at_start,           <span class="comment">/* Total number of initial inputs   */</span></span><br><span class="line">           queued_discovered,         <span class="comment">/* Items discovered during this run */</span></span><br><span class="line">           queued_imported,           <span class="comment">/* Items imported via -S            */</span></span><br><span class="line">           queued_favored,            <span class="comment">/* Paths deemed favorable           */</span></span><br><span class="line">           queued_with_cov,           <span class="comment">/* Paths with new coverage bytes    */</span></span><br><span class="line">           pending_not_fuzzed,        <span class="comment">/* Queued but not done yet          */</span></span><br><span class="line">           pending_favored,           <span class="comment">/* Pending favored paths            */</span></span><br><span class="line">           cur_skipped_paths,         <span class="comment">/* Abandoned inputs in cur cycle    */</span></span><br><span class="line">           cur_depth,                 <span class="comment">/* Current path depth               */</span></span><br><span class="line">           max_depth,                 <span class="comment">/* Max path depth                   */</span></span><br><span class="line">           useless_at_start,          <span class="comment">/* Number of useless starting paths */</span></span><br><span class="line">           var_byte_count,            <span class="comment">/* Bitmap bytes with var behavior   */</span></span><br><span class="line">           current_entry,             <span class="comment">/* Current queue entry ID           */</span></span><br><span class="line">           havoc_div = <span class="number">1</span>;             <span class="comment">/* Cycle count divisor for havoc    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里的大部分字段用于write_stats_file中更新状态界面 */</span></span><br><span class="line">EXP_ST u64 total_crashes,             <span class="comment">/* Total number of crashes          */</span></span><br><span class="line">           unique_crashes,            <span class="comment">/* Crashes with unique signatures   */</span></span><br><span class="line">           total_tmouts,              <span class="comment">/* Total number of timeouts         */</span></span><br><span class="line">           unique_tmouts,             <span class="comment">/* Timeouts with unique signatures  */</span></span><br><span class="line">           unique_hangs,              <span class="comment">/* Hangs with unique signatures     */</span></span><br><span class="line">           total_execs,               <span class="comment">/* Total execve() calls             */</span></span><br><span class="line">           slowest_exec_ms,           <span class="comment">/* Slowest testcase non hang in ms  */</span> </span><br><span class="line">                                      <span class="comment">/* 首次出现在run_target中，用于判断执行是否超时 */</span></span><br><span class="line">           start_time,                <span class="comment">/* Unix start time (ms)             */</span></span><br><span class="line">           last_path_time,            <span class="comment">/* Time for most recent path (ms)   */</span></span><br><span class="line">           last_crash_time,           <span class="comment">/* Time for most recent crash (ms)  */</span></span><br><span class="line">           last_hang_time,            <span class="comment">/* Time for most recent hang (ms)   */</span></span><br><span class="line">           last_crash_execs,          <span class="comment">/* Exec counter at last crash       */</span></span><br><span class="line">           queue_cycle,               <span class="comment">/* Queue round counter              */</span></span><br><span class="line">           cycles_wo_finds,           <span class="comment">/* Cycles without any new paths     */</span></span><br><span class="line">           trim_execs,                <span class="comment">/* Execs done to trim input files   */</span></span><br><span class="line">           bytes_trim_in,             <span class="comment">/* Bytes coming into the trimmer    */</span></span><br><span class="line">           bytes_trim_out,            <span class="comment">/* Bytes coming outa the trimmer    */</span></span><br><span class="line">           blocks_eff_total,          <span class="comment">/* Blocks subject to effector maps  */</span></span><br><span class="line">           blocks_eff_select;         <span class="comment">/* Blocks selected as fuzzable      */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8 *stage_name = <span class="string">"init"</span>,       <span class="comment">/* Name of the current fuzz stage   */</span></span><br><span class="line">          *stage_short,               <span class="comment">/* Short stage name                 */</span></span><br><span class="line">          *syncing_party;             <span class="comment">/* Currently syncing with...        */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> s32 stage_cur, stage_max;      <span class="comment">/* Stage progression                */</span></span><br><span class="line">                                      <span class="comment">/* 首次出现在calibrate_case          */</span></span><br><span class="line"><span class="keyword">static</span> s32 splicing_with = <span class="number">-1</span>;        <span class="comment">/* Splicing with which test case?   */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">extra_data</span> {</span></span><br><span class="line">  u8* data;                           <span class="comment">/* Dictionary token data            */</span></span><br><span class="line">  u32 len;                            <span class="comment">/* Dictionary token length          */</span></span><br><span class="line">  u32 hit_cnt;                        <span class="comment">/* Use count in the corpus          */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">extra_data</span>* <span class="title">extras</span>;</span>     <span class="comment">/* Extra tokens to fuzz with        */</span></span><br><span class="line"><span class="keyword">static</span> u32 extras_cnt;                <span class="comment">/* Total number of tokens read      */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">extra_data</span>* <span class="title">a_extras</span>;</span>   <span class="comment">/* Automatically selected extras    */</span></span><br><span class="line"><span class="keyword">static</span> u32 a_extras_cnt;              <span class="comment">/* Total number of tokens available */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interesting values, as per config.h */</span></span><br><span class="line"><span class="keyword">static</span> s8  interesting_8[]  = { INTERESTING_8 };</span><br><span class="line"><span class="keyword">static</span> s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 };</span><br><span class="line"><span class="keyword">static</span> s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 };</span><br><span class="line"></span><br><span class="line"><span class="comment">/* List of interesting values to use in fuzzing. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_8 </span></span><br><span class="line">  <span class="number">-128</span>,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> </span><br><span class="line">  <span class="number">-1</span>,            <span class="comment">/*                                         */</span> </span><br><span class="line">   <span class="number">0</span>,            <span class="comment">/*                                         */</span> </span><br><span class="line">   <span class="number">1</span>,            <span class="comment">/*                                         */</span> </span><br><span class="line">   <span class="number">16</span>,           <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">32</span>,           <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">64</span>,           <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">100</span>,          <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">127</span>           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_16 </span></span><br><span class="line">  <span class="number">-32768</span>,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> </span><br><span class="line">  <span class="number">-129</span>,          <span class="comment">/* Overflow signed 8-bit                   */</span> </span><br><span class="line">   <span class="number">128</span>,          <span class="comment">/* Overflow signed 8-bit                   */</span> </span><br><span class="line">   <span class="number">255</span>,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> </span><br><span class="line">   <span class="number">256</span>,          <span class="comment">/* Overflow unsig 8-bit                    */</span> </span><br><span class="line">   <span class="number">512</span>,          <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">1000</span>,         <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">1024</span>,         <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">4096</span>,         <span class="comment">/* One-off with common buffer size         */</span> </span><br><span class="line">   <span class="number">32767</span>         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_32 </span></span><br><span class="line">  <span class="number">-2147483648L</span>L, <span class="comment">/* Overflow signed 32-bit when decremented */</span> </span><br><span class="line">  <span class="number">-100663046</span>,    <span class="comment">/* Large negative number (endian-agnostic) */</span> </span><br><span class="line">  <span class="number">-32769</span>,        <span class="comment">/* Overflow signed 16-bit                  */</span> </span><br><span class="line">   <span class="number">32768</span>,        <span class="comment">/* Overflow signed 16-bit                  */</span> </span><br><span class="line">   <span class="number">65535</span>,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> </span><br><span class="line">   <span class="number">65536</span>,        <span class="comment">/* Overflow unsig 16 bit                   */</span> </span><br><span class="line">   <span class="number">100663045</span>,    <span class="comment">/* Large positive number (endian-agnostic) */</span> </span><br><span class="line">   <span class="number">2147483647</span>    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h3><p>理解这部分代码，需要掌握一些<a href="https://www.cnblogs.com/52php/p/5813867.html" target="_blank" rel="noopener">Linux进程间通信</a>的知识</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置信号处理程序 */</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_signal_handlers</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建sigaction结构体sa，并设置如下成员：</span></span><br><span class="line"><span class="comment">     sa_handler：   处理函数指针</span></span><br><span class="line"><span class="comment">     sa_flags：     信号处理修改器，这里设置为SA_RESTART表示重启可中断的函数而不是给出EINTR错误</span></span><br><span class="line"><span class="comment">     sa_sigaction： 信号行为</span></span><br><span class="line"><span class="comment">     sa_mask：      指定一个信号集，在调用sa_handler所指向的信号处理函数之前，该信号集将被加入到进程</span></span><br><span class="line"><span class="comment">                    的信号屏蔽字中。信号屏蔽字是指当前被阻塞的一组信号，它们不能被当前进程接收到，这里</span></span><br><span class="line"><span class="comment">                    使用了sigemptyset()创建了控的信号屏蔽字，即不屏蔽任何信息 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler   = <span class="literal">NULL</span>;</span><br><span class="line">  sa.sa_flags     = SA_RESTART;</span><br><span class="line">  sa.sa_sigaction = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  sigemptyset(&sa.sa_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用handle_stop_sig处理各种"stop"时的情况</span></span><br><span class="line"><span class="comment">     handle_stop_sig会进行如下操作：</span></span><br><span class="line"><span class="comment">        1.设置stop_soon的值为1</span></span><br><span class="line"><span class="comment">        2.如果child_pid存在，就kill掉它</span></span><br><span class="line"><span class="comment">        3.如果forksrv_pid存在，就kill掉它 */</span></span><br><span class="line">  sa.sa_handler = handle_stop_sig;</span><br><span class="line">  sigaction(SIGHUP, &sa, <span class="literal">NULL</span>);</span><br><span class="line">  sigaction(SIGINT, &sa, <span class="literal">NULL</span>);</span><br><span class="line">  sigaction(SIGTERM, &sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用handle_timeout处理超时的情况</span></span><br><span class="line"><span class="comment">     handle_timeout会进行如下操作：</span></span><br><span class="line"><span class="comment">        1.如果child_pid存在，先设置child_time_out值为1，再kill掉child_pid</span></span><br><span class="line"><span class="comment">        2.如果child_pid不存在但forksrv_pid存在，先设置child_time_out值为1，再kill掉forksrv_pid */</span></span><br><span class="line">  sa.sa_handler = handle_timeout;</span><br><span class="line">  sigaction(SIGALRM, &sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用handle_resize处理窗口大小变化的情况，它会将clear_screen的值设置为1 */</span></span><br><span class="line">  sa.sa_handler = handle_resize;</span><br><span class="line">  sigaction(SIGWINCH, &sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用handle_skipreq处理用户自定义的信号，它会将skip_requested的值设置为1 */</span></span><br><span class="line">  sa.sa_handler = handle_skipreq;</span><br><span class="line">  sigaction(SIGUSR1, &sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将其它一些不关心的信号的处理函数设置为SIG_IGN */</span></span><br><span class="line">  sa.sa_handler = SIG_IGN;</span><br><span class="line">  sigaction(SIGTSTP, &sa, <span class="literal">NULL</span>);</span><br><span class="line">  sigaction(SIGPIPE, &sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读取环境变量ASAN_OPTIONS和MASN_OPTIONS，做一些检查 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_asan_opts</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 读取环境变量ASAN_OPTIONS，若存在，则进行如下判断：</span></span><br><span class="line"><span class="comment">     1.是否设置了abort_on_error的值为1</span></span><br><span class="line"><span class="comment">     2.是否设置了symbolize的值为0 </span></span><br><span class="line"><span class="comment">     若未进行上述设置，则抛出异常 */</span></span><br><span class="line">  u8* x = getenv(<span class="string">"ASAN_OPTIONS"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">"abort_on_error=1"</span>))</span><br><span class="line">      FATAL(<span class="string">"Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">"symbolize=0"</span>))</span><br><span class="line">      FATAL(<span class="string">"Custom ASAN_OPTIONS set without symbolize=0 - please fix!"</span>);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 读取环境变量MSAN_OPTIONS，若存在，则进行如下判断：</span></span><br><span class="line"><span class="comment">     1.是否设置了exit_code的值为经过'STRINGIFY(MASN_ERROR)'运算后的结果</span></span><br><span class="line"><span class="comment">     2.是否设置了symbolize的值为0 </span></span><br><span class="line"><span class="comment">     若未进行上述设置，则抛出异常 */</span></span><br><span class="line">  x = getenv(<span class="string">"MSAN_OPTIONS"</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (x) {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">"exit_code="</span> STRINGIFY(MSAN_ERROR)))</span><br><span class="line">      FATAL(<span class="string">"Custom MSAN_OPTIONS set without exit_code="</span></span><br><span class="line">            STRINGIFY(MSAN_ERROR) <span class="string">" - please fix!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">"symbolize=0"</span>))</span><br><span class="line">      FATAL(<span class="string">"Custom MSAN_OPTIONS set without symbolize=0 - please fix!"</span>);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果通过-M或者-S指定了sync_id（位于main函数中），则修复out_dir和sync_dir的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_up_sync</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u8* x = sync_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果位于dumb_mode模式，即参数设置了'-n'选项，提示'-S/-M'参数与'-n'参数互斥 */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode)</span><br><span class="line">    FATAL(<span class="string">"-S / -M and -n are mutually exclusive"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果skip_deterministic置位，说明参数设置了'-d'选项，</span></span><br><span class="line"><span class="comment">     如果force_deterministic置位，说明参数设置了'-M'选项，</span></span><br><span class="line"><span class="comment">     这里对于这俩参数使用的冲突进行纠正 */</span></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic) {</span><br><span class="line">    <span class="keyword">if</span> (force_deterministic)</span><br><span class="line">      FATAL(<span class="string">"use -S instead of -M -d"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      FATAL(<span class="string">"-S already implies -d"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.检测sync_id是否以'数字'、'_'、'-'开头</span></span><br><span class="line"><span class="comment">     2.检测sync_id的长度是否过大 */</span></span><br><span class="line">  <span class="keyword">while</span> (*x) {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*x) && *x != <span class="string">'_'</span> && *x != <span class="string">'-'</span>)</span><br><span class="line">      FATAL(<span class="string">"Non-alphanumeric fuzzer ID specified via -S or -M"</span>);</span><br><span class="line">    x++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(sync_id) > <span class="number">32</span>) </span><br><span class="line">      FATAL(<span class="string">"Fuzzer ID too long"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 1.设置sync_dir的值为out_dir</span></span><br><span class="line"><span class="comment">     2.设置out_dir的值为拼接后的“out_dir/sync_id” */</span></span><br><span class="line">  x = alloc_printf(<span class="string">"%s/%s"</span>, out_dir, sync_id);</span><br><span class="line">  sync_dir = out_dir;</span><br><span class="line">  out_dir  = x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 若参数中未设置'-M'选项，则对skip_deterministic和use_splicing进行置位，相当于设置'-d'选项 */</span></span><br><span class="line">  <span class="keyword">if</span> (!force_deterministic) {</span><br><span class="line">    skip_deterministic = <span class="number">1</span>;</span><br><span class="line">    use_splicing = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将当前命令行中的参数复制到新申请的缓冲区buf中 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_cmdline</span><span class="params">(u32 argc, <span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u32 len = <span class="number">1</span>, i;</span><br><span class="line">  u8* buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < argc; i++)</span><br><span class="line">    len += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  buf = orig_cmdline = ck_alloc(len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < argc; i++) {</span><br><span class="line">    u32 l = <span class="built_in">strlen</span>(argv[i]);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[i], l);</span><br><span class="line">    buf += l;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (i != argc - <span class="number">1</span>) </span><br><span class="line">        *(buf++) = <span class="string">' '</span>;</span><br><span class="line">  }</span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* (创建)并修剪一个运行横幅 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_up_banner</span><span class="params">(u8* name)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果没有设置use_banner，即参数中没有'-T'选项，则对use_banner进行设置：</span></span><br><span class="line"><span class="comment">     如果存在sync_id，即参数中设置了'-M'或'-S'选项，就将use_banner设置为sync_id</span></span><br><span class="line"><span class="comment">     如果不存在sync_id，就设置为传入参数name的实际值(name本身或最后一个'/'后面的值) */</span></span><br><span class="line">  <span class="keyword">if</span> (!use_banner) {</span><br><span class="line">    <span class="keyword">if</span> (sync_id) {</span><br><span class="line">      use_banner = sync_id;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      u8* trim = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</span><br><span class="line">      <span class="keyword">if</span> (!trim) use_banner = name; <span class="keyword">else</span> use_banner = trim + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果use_banner的长度超过40字节，将超过40字节的地方截断，并设置成'.use_banner...'的形式 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(use_banner) > <span class="number">40</span>) {</span><br><span class="line">    u8* tmp = ck_alloc(<span class="number">44</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">"%.40s..."</span>, use_banner);</span><br><span class="line">    use_banner = tmp;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检测是否在tty终端上运行 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_if_tty</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检测环境变量AFL_NO_UI的值，如果存在，则设置not_on_tty的值为1，并返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">"AFL_NO_UI"</span>)) {</span><br><span class="line">    OKF(<span class="string">"Disabling the UI because AFL_NO_UI is set."</span>);</span><br><span class="line">    not_on_tty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* int ioctl(int fd, unsigned long request, ...); </span></span><br><span class="line"><span class="comment">     通过ioctl来读取windows size(TIOCGWINSZ时，用于获取窗口大小)，</span></span><br><span class="line"><span class="comment">     如果last error保存的值为ENOTTY，则设置not_on_tty的值为1，并返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(<span class="number">1</span>, TIOCGWINSZ, &ws)) {</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTTY) {</span><br><span class="line">      OKF(<span class="string">"Looks like we're not running on a tty, so I'll be a bit less verbose."</span>);</span><br><span class="line">      not_on_tty = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="CPU检查相关函数"><a href="#CPU检查相关函数" class="headerlink" title="CPU检查相关函数"></a>CPU检查相关函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算逻辑上CPU的核心数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_core_count</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据亲缘性设置，将进程绑定到指定CPU核心，如果没找到合适的CPU则返回-1，CPU上限为4096个 */</span></span><br><span class="line">bind_to_free_cpu();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确保核心转储时不会进入程序 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_crash_handling</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查CPU的管理者 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_cpu_governor</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置后置处理器 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_post</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取环境变量AFL_POST_LIBRARY，如果未设置该值，则直接返回 */</span></span><br><span class="line">  <span class="keyword">void</span>* dh;</span><br><span class="line">  u8* fn = getenv(<span class="string">"AFL_POST_LIBRARY"</span>);</span><br><span class="line">  u32 tlen = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">if</span> (!fn) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  ACTF(<span class="string">"Loading postprocessor from '%s'..."</span>, fn);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 打开环境变量AFL_POST_LIBRARY指向的动态链接库，RTLD_NOW指定了在函数返回前解析出所有未定义的符号</span></span><br><span class="line"><span class="comment">     调用dlsym获取'afl_postprocess'的函数地址，若获取失败，则抛出异常 */</span></span><br><span class="line">  dh = dlopen(fn, RTLD_NOW);</span><br><span class="line">  <span class="keyword">if</span> (!dh) </span><br><span class="line">      FATAL(<span class="string">"%s"</span>, dlerror());</span><br><span class="line">  post_handler = dlsym(dh, <span class="string">"afl_postprocess"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!post_handler) </span><br><span class="line">      FATAL(<span class="string">"Symbol 'afl_postprocess' not found."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用'afl_postprocess'，做个简单的测试，用于发现可能存在的段错误 */</span></span><br><span class="line">  post_handler(<span class="string">"hello"</span>, &tlen);</span><br><span class="line">  OKF(<span class="string">"Postprocessor installed successfully."</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h3><p>这部分涉及到的共享内存知识点可以参考<a href="https://www.cnblogs.com/52php/p/5861372.html" target="_blank" rel="noopener">此篇</a>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 配置共享内存和virgin_bits，在程序启动时会被调用 */</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果输入位图input bitmap为空，即参数中未设置'-B'选项，就用'\xff'初始化virgin_bits数组的每个元素</span></span><br><span class="line"><span class="comment">     接下来，virgin_tmout数组与virgin_crash数组也进行类似的初始化 (index: 0-65535) */</span>  </span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) </span><br><span class="line">      <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 函数原型：int shmget(key_t key, size_t size, int shmflg);</span></span><br><span class="line"><span class="comment">        参数1：程序提供的一个key(非0整数)，命名该共享内存段。这里IPC_PRIVATE表明创建一个新的共享内存段</span></span><br><span class="line"><span class="comment">        参数2：指定创建的共享内存的大小为MAP_SIZE</span></span><br><span class="line"><span class="comment">        参数3：IPC_CREAT -> 若共享内存不存在，则创建一个共享内存，否则直接打开它；</span></span><br><span class="line"><span class="comment">              IPC_EXCL  -> 只有在共享内存不存在的时候，新的共享内存才能创建，否则将报错</span></span><br><span class="line"><span class="comment">              0600      -> Owner==6；Group==0；Other==0</span></span><br><span class="line"><span class="comment">        返回值：将新创建的共享内存标识符返回给shm_id */</span></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (shm_id < <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">"shmget() failed"</span>);    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* atexit将函数remove_shm注册为在afl-fuzz程序运行结束时要被调用的函数，</span></span><br><span class="line"><span class="comment">     该函数执行了"shmctl(shm_id, IPC_RMID, NULL);"来删除共享内存。</span></span><br><span class="line"><span class="comment">        函数原型：int shmctl(int shmid, int cmd, struct_ds *buf);</span></span><br><span class="line"><span class="comment">        参数1：shmid为shmget函数返回的共享内存标识符</span></span><br><span class="line"><span class="comment">        参数2：cmd是采取的操作；这里的IPC_RMID表示删除由shmid指定的共享内存段</span></span><br><span class="line"><span class="comment">        参数3：buf指向一个shmid_ds结构体，该结构体用于设置共享内存模式和访问权限</span></span><br><span class="line"><span class="comment">        返回值：根据cmd指定的操作不同返回值也会不同，在这里返回0表示操作成功，-1表示失败 */</span></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 将shm_str设置为shm_id的值</span></span><br><span class="line"><span class="comment">     如果dumb_mode模式，即参数设置了'-n'选项，则将环境变量SHM_ENV_VAR的值设置为shm_str </span></span><br><span class="line"><span class="comment">     然后将shm_str给free掉；如果不是dumb_mode模式，就直接free掉 */</span></span><br><span class="line">  shm_str = alloc_printf(<span class="string">"%d"</span>, shm_id);</span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) </span><br><span class="line">      setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line">  ck_free(shm_str);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 调用shmat，用shmid指定的共享内存来设置位图trace_bit，用于跟踪fuzz的执行流程</span></span><br><span class="line"><span class="comment">        函数原型：void *shmat(int shmid, const void *shmaddr, int shmflg);</span></span><br><span class="line"><span class="comment">        参数1：shmid，参考上面的shmctl</span></span><br><span class="line"><span class="comment">        参数2：shmaddr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址</span></span><br><span class="line"><span class="comment">        参数3：shmflg，参考上面的shmget</span></span><br><span class="line"><span class="comment">        返回值：调用成功时返回一个指向共享内存第一个字节的指针；调用失败返回-1 */</span></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="keyword">void</span> *)<span class="number">-1</span>) </span><br><span class="line">      PFATAL(<span class="string">"shmat() failed"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>这里<strong>通过”trace_bits”和”virgin_bits”两个位图来分别记录当前的tuple信息及整体tuple信息</strong>（tuple在<a href="https://cata1oc.github.io/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/#afl-store">前一篇</a>提到过），其中<strong>“trace_bits”位于共享内存上，便于进行进程间通信</strong>。”virgin_tmout”和”virgin_crash”两个位图来记录fuzz过程中出现的所有目标程序超时以及崩溃的tuple信息</p>
<h3 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h3><p>这部分内容将count_class_lookup8换算成二进制后，就会好理解的多，这里参考了<a href="https://eternalsakura13.com/2020/08/23/afl/#comments" target="_blank" rel="noopener">sakura师傅</a>的说法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化count_class_lookup16数组，用于分支路径的规整 */</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/* 先来理解这里的count_class_lookup8，它的结构如下所示，这里将其转换为2进制来看会更清晰，</span></span><br><span class="line"><span class="comment">   它的存在是因为trace_bits是用一个字节来记录是否到达这个路径，以及这个路径被命中了多少次，</span></span><br><span class="line"><span class="comment">   这个次数在0~255之间，但如果一个循环，它循环5次和循环6次可能是完全一样的效果，为了避免被</span></span><br><span class="line"><span class="comment">   当成不同的路径，或者说尽可能减少因为命中次数导致的区别。在每次计算是否发现了新路径之前，先</span></span><br><span class="line"><span class="comment">   把这个路径命中数进行规整，比如把命中5次和6次都统一认为是命中了8次，如下所示 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = {</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,	     <span class="comment">/* 00000000 */</span>			</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,	     <span class="comment">/* 00000001 */</span>		</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,	     <span class="comment">/* 00000010 */</span>		</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,	     <span class="comment">/* 00000100 */</span>		</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,	     <span class="comment">/* 00001000 */</span>		</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,	     <span class="comment">/* 00010000 */</span>		</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,	     <span class="comment">/* 00100000 */</span>		</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,	     <span class="comment">/* 01000000 */</span>		</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span>	     <span class="comment">/* 10000000 */</span>		</span><br><span class="line">      </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 而为什么又需要用一个count_class_lookup16呢？是因为AFL中对于一条分支路径的表示是由一个</span></span><br><span class="line"><span class="comment">   二元组来表示的。例如路径"A->B->D->C->B->D"，就可以用[A,B][B,D][D,C][C,B]四个二元组</span></span><br><span class="line"><span class="comment">   表示，这里[B,D]执行了2次，其余执行了1次，这些会被映射到一张哈希表中，这个哈希表在afl-as.h</span></span><br><span class="line"><span class="comment">   的分析中提到过，是一个共享内存，在这里，其实就是前面提到的trace_bits。基于这种二元组的表示</span></span><br><span class="line"><span class="comment">   的效率考虑，于是在下面初始化了count_class_lookup16 */</span></span><br><span class="line"><span class="keyword">static</span> u16 count_class_lookup16[<span class="number">65536</span>];</span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_count_class16</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  u32 b1, b2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 < <span class="number">256</span>; b1++) </span><br><span class="line">    <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 < <span class="number">256</span>; b2++)</span><br><span class="line">      count_class_lookup16[(b1 << <span class="number">8</span>) + b2] = </span><br><span class="line">        (count_class_lookup8[b1] << <span class="number">8</span>) | count_class_lookup8[b2];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 准备output_dir以及相关的文件描述符 */</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_dirs_fds</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u8* tmp;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这部分代码用于设置输出文件夹：</span></span><br><span class="line"><span class="comment">     如果设置了sync_id(即参数包含'-M'或'-S')，则以读写权限(0700)创建sync_dir文件夹</span></span><br><span class="line"><span class="comment">        如果报错(mkdir返回0说明创建成功，出错返回-1)，并且报错类型不是EEXIST，则抛出异常</span></span><br><span class="line"><span class="comment">     以读写权限(0700)创建out_dir文件夹</span></span><br><span class="line"><span class="comment">        如果报错，并且报错类型不是EEXIST，则抛出异常</span></span><br><span class="line"><span class="comment">        如果报错，且报错类型是EEXIST，则说明文件夹已存在，调用maybe_delete_out_dir</span></span><br><span class="line"><span class="comment">        如果没报错，说明创建成功，则判断是否设置了in_place_resume(参数包含'-i'且in_dir为'-')</span></span><br><span class="line"><span class="comment">           如果设置了则抛出异常</span></span><br><span class="line"><span class="comment">           如果没设置，则以只读模式打开文件out_dir，并将文件描述符返回给out_dir_fd</span></span><br><span class="line"><span class="comment">           如果定义了宏__sun，则还会进一步检查打开out_dir是否失败？为out_dir建立互斥锁是否失败？ */</span>   </span><br><span class="line">  ACTF(<span class="string">"Setting up output directories..."</span>);</span><br><span class="line">  <span class="keyword">if</span> (sync_id && <span class="built_in">mkdir</span>(sync_dir, <span class="number">0700</span>) && errno != EEXIST)</span><br><span class="line">      PFATAL(<span class="string">"Unable to create '%s'"</span>, sync_dir);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(out_dir, <span class="number">0700</span>)) {</span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST) </span><br><span class="line">        PFATAL(<span class="string">"Unable to create '%s'"</span>, out_dir);</span><br><span class="line">    maybe_delete_out_dir();</span><br><span class="line">  } </span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">      FATAL(<span class="string">"Resume attempted but old output directory not found"</span>);</span><br><span class="line">    out_dir_fd = <span class="built_in">open</span>(out_dir, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __sun</span></span><br><span class="line">    <span class="keyword">if</span> (out_dir_fd < <span class="number">0</span> || flock(out_dir_fd, LOCK_EX | LOCK_NB))</span><br><span class="line">      PFATAL(<span class="string">"Unable to flock() output directory."</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Queue directory for any starting & discovered paths. </span></span><br><span class="line"><span class="comment">     Top-level directory for queue metadata used for session resume and related tasks.</span></span><br><span class="line"><span class="comment">     Directory for flagging queue entries that went through deterministic fuzzing in the past</span></span><br><span class="line"><span class="comment">     Directory with the auto-selected dictionary entries</span></span><br><span class="line"><span class="comment">     The set of paths currently deemed redundant</span></span><br><span class="line"><span class="comment">     The set of paths showing variable behavior</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/queue，用于保存任意开始和发现到的路径</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/queue/.state/，保存用于会话恢复及其相关任务的元数据</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/queue/.state/deterministic_done/，用于标记先前经过deterministic fuzzing(设置'-M')的队列条目</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/queue/.state/auto_extras/，用于保存带有自动选择的字典条目</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/queue/.state/reduntant_edges/，用于保存当前被认为是冗余的路径集</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/queue/.state/variable_behavior/，用于保存不同行为的路径集</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/queue"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/queue/.state/"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/queue/.state/deterministic_done/"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/queue/.state/auto_extras/"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/queue/.state/redundant_edges/"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/queue/.state/variable_behavior/"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 以读写权限创建文件夹out_dir/.synced/，用于跟踪共同工作的fuzzers</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/crashes，用于记录所有(unique)crashed</span></span><br><span class="line"><span class="comment">     以读写权限创建文件夹out_dir/hangs，用于记录所有超时的情况</span></span><br><span class="line"><span class="comment">     以读写模式打开/dev/null，并将文件描述符返回给dev_urandom_fd</span></span><br><span class="line"><span class="comment">     以只读模式打开/dev/urandom，并将文件描述符返回给dev_urandom_fd */</span></span><br><span class="line">  <span class="keyword">if</span> (sync_id) {</span><br><span class="line">    tmp = alloc_printf(<span class="string">"%s/.synced/"</span>, out_dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>) && (!in_place_resume || errno != EEXIST))</span><br><span class="line">      PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">    ck_free(tmp);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/crashes"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/hangs"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mkdir</span>(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  dev_null_fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_null_fd < <span class="number">0</span>) PFATAL(<span class="string">"Unable to open /dev/null"</span>);</span><br><span class="line">    </span><br><span class="line">  dev_urandom_fd = <span class="built_in">open</span>(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (dev_urandom_fd < <span class="number">0</span>) PFATAL(<span class="string">"Unable to open /dev/urandom"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 打开文件out_dir/plot_data，如果文件不存在就以读写模式(0600)创建文件</span></span><br><span class="line"><span class="comment">     打开文件后将"# unix_time, ...... ,execs_per_sec\n"写入到文件中 */</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">"%s/plot_data"</span>, out_dir);</span><br><span class="line">  fd = <span class="built_in">open</span>(tmp, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">"Unable to create '%s'"</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line">  plot_file = fdopen(fd, <span class="string">"w"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!plot_file) </span><br><span class="line">      PFATAL(<span class="string">"fdopen() failed"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(plot_file, <span class="string">"# unix_time, cycles_done, cur_path, paths_total, "</span></span><br><span class="line">                     <span class="string">"pending_total, pending_favs, map_size, unique_crashes, "</span></span><br><span class="line">                     <span class="string">"unique_hangs, max_depth, execs_per_sec\n"</span>);</span><br><span class="line">                     <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从input_dir中读取testcase到队列，然后调用add_to_queue()将testcase进行排队，</span></span><br><span class="line"><span class="comment">   该函数会在启动时进行调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_testcases</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* struct dirent {</span></span><br><span class="line"><span class="comment">        long d_ino;                 // 索引节点号</span></span><br><span class="line"><span class="comment">        off_t d_off;                // 在目录文件中的偏移</span></span><br><span class="line"><span class="comment">        unsigned short d_reclen;    // 文件名长</span></span><br><span class="line"><span class="comment">        unsigned char d_type;       // 文件类型</span></span><br><span class="line"><span class="comment">        char d_name[NAME_MAX+1];    // 文件名，最长255字节</span></span><br><span class="line"><span class="comment">     } </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">nl</span>;</span></span><br><span class="line">  s32 nl_cnt;</span><br><span class="line">  u32 i;</span><br><span class="line">  u8* fn;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 尝试访问in_dir/queue文件夹，如果存在就设置in_dir为in_dir/queue */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/queue"</span>, in_dir);</span><br><span class="line">  <span class="keyword">if</span> (!access(fn, F_OK)) </span><br><span class="line">      in_dir = fn; </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      ck_free(fn);</span><br><span class="line">  ACTF(<span class="string">"Scanning '%s'..."</span>, in_dir);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 函数原型：</span></span><br><span class="line"><span class="comment">     int scandir(</span></span><br><span class="line"><span class="comment">        const char *dirp,</span></span><br><span class="line"><span class="comment">        struct dirent ***namelist,</span></span><br><span class="line"><span class="comment">        int (*filter)(const struct dirent *),</span></span><br><span class="line"><span class="comment">        int (*compar)(const struct dirent **, const struct dirent **)</span></span><br><span class="line"><span class="comment">     );     </span></span><br><span class="line"><span class="comment">     int alphasort(</span></span><br><span class="line"><span class="comment">        const struct dirent **a,</span></span><br><span class="line"><span class="comment">        const struct dirent **b</span></span><br><span class="line"><span class="comment">     );   </span></span><br><span class="line"><span class="comment">     1.调用scandir扫描in_dir目录下的条目(不使用readdir是因为这样会导致测试用例随机而难以控制)，</span></span><br><span class="line"><span class="comment">       经alphasort排序后保存到nl里，nl是一个指向指针数组的指针</span></span><br><span class="line"><span class="comment">     2.nl_cnt记录扫描目录时选中的条目，如果条目小于0，则进行出错处理</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  nl_cnt = scandir(in_dir, &nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line">  <span class="keyword">if</span> (nl_cnt < <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line">      SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">           <span class="string">"The input directory does not seem to be valid - try again. The fuzzer needs\n"</span></span><br><span class="line">           <span class="string">"    one or more test case to start with - ideally, a small file under 1 kB\n"</span></span><br><span class="line">           <span class="string">"    or so. The cases must be stored as regular files directly in the input\n"</span></span><br><span class="line">           <span class="string">"    directory.\n"</span>);</span><br><span class="line">    PFATAL(<span class="string">"Unable to open '%s'"</span>, in_dir);</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果shuffle_queue存在(即设置了环境变量AFL_SHUFFLE_QUEUE)且nl_cnt大于1，</span></span><br><span class="line"><span class="comment">     则调用shuffle_ptrs，该函数会对传入的指针数组进行洗牌 */</span></span><br><span class="line">  <span class="keyword">if</span> (shuffle_queue && nl_cnt > <span class="number">1</span>) {</span><br><span class="line">    ACTF(<span class="string">"Shuffling queue..."</span>);</span><br><span class="line">    shuffle_ptrs((<span class="keyword">void</span>**)nl, nl_cnt);</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进入for循环，扫描数组中的每一项：</span></span><br><span class="line"><span class="comment">     1.读取nl[i]->d_name，并与in_dir拼接形成路径fn(in_dir/d_name)</span></span><br><span class="line"><span class="comment">     2.读取nl[i]->d_name，并与in_dir拼接形成路径dfn(in_dir/.state/deterministic_done/d_name)</span></span><br><span class="line"><span class="comment">     3.设置passed_det的值为0</span></span><br><span class="line"><span class="comment">     4.读取fn路径对应文件的状态到st中，并判断该文件是否可访问</span></span><br><span class="line"><span class="comment">     5.根据st_mode(文件保护模式)，st_size(文件总大小)，以及文件名，从而筛选掉一些无关文件</span></span><br><span class="line"><span class="comment">     6.检测st_size是否超过文件大小界限</span></span><br><span class="line"><span class="comment">     7.判断dfn路径指定的文件是否可访问，实际上这里是判断fn路径下对应的文件是否fuzz过，从而在恢复扫描时</span></span><br><span class="line"><span class="comment">     防止多余时间的消耗(如果fuzz过，就会被放到dfn路径指定的位置)：</span></span><br><span class="line"><span class="comment">        a.如果fuzz过，就设置passed_det的值为1</span></span><br><span class="line"><span class="comment">        b.如果没fuzz过，就维持passed_det的值为0</span></span><br><span class="line"><span class="comment">     8.调用add_to_queue将这个文件放入队列，同时附上该文件的大小和passed_det */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < nl_cnt; i++) {</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">      </span><br><span class="line">    u8* fn = alloc_printf(<span class="string">"%s/%s"</span>, in_dir, nl[i]->d_name);</span><br><span class="line">    u8* dfn = alloc_printf(<span class="string">"%s/.state/deterministic_done/%s"</span>, in_dir, nl[i]->d_name);</span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(nl[i]); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">"Unable to access '%s'"</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">"/README.testcases"</span>)) {</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      ck_free(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size > MAX_FILE) </span><br><span class="line">      FATAL(<span class="string">"Test case '%s' is too big (%s, limit is %s)"</span>, fn,</span><br><span class="line">            DMS(st.st_size), DMS(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(dfn, F_OK)) </span><br><span class="line">        passed_det = <span class="number">1</span>;</span><br><span class="line">    ck_free(dfn);</span><br><span class="line"></span><br><span class="line">    add_to_queue(fn, st.st_size, passed_det);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">free</span>(nl); </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 1.如果queued_paths的值为0，说明队列里没有用于测试的输入文件(testcase)了，则抛出异常</span></span><br><span class="line"><span class="comment">     2.设置last_path_time值为0</span></span><br><span class="line"><span class="comment">     3.用queued_paths的值更新原始输入文件的数量queued_at_start */</span></span><br><span class="line">  <span class="keyword">if</span> (!queued_paths) {</span><br><span class="line">    SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">         <span class="string">"Looks like there are no valid test cases in the input directory! The fuzzer\n"</span></span><br><span class="line">         <span class="string">"    needs one or more test case to start with - ideally, a small file under\n"</span></span><br><span class="line">         <span class="string">"    1 kB or so. The cases must be stored as regular files directly in the\n"</span></span><br><span class="line">         <span class="string">"    input directory.\n"</span>);</span><br><span class="line">    FATAL(<span class="string">"No usable test cases in '%s'"</span>, in_dir);</span><br><span class="line">  }</span><br><span class="line">  last_path_time = <span class="number">0</span>;</span><br><span class="line">  queued_at_start = queued_paths;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="add-to-queue"><a href="#add-to-queue" class="headerlink" title="add_to_queue"></a>add_to_queue</h3><h4 id="queue-entry结构体与部分相关变量"><a href="#queue-entry结构体与部分相关变量" class="headerlink" title="queue_entry结构体与部分相关变量"></a>queue_entry结构体与部分相关变量</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> {</span></span><br><span class="line">  u8* fname;                          <span class="comment">/* File name for the test case      */</span></span><br><span class="line">  u32 len;                            <span class="comment">/* Input length                     */</span></span><br><span class="line"></span><br><span class="line">  u8  cal_failed,                     <span class="comment">/* Calibration failed?              */</span></span><br><span class="line">      trim_done,                      <span class="comment">/* Trimmed?                         */</span></span><br><span class="line">      was_fuzzed,                     <span class="comment">/* Had any fuzzing done yet?        */</span></span><br><span class="line">      passed_det,                     <span class="comment">/* Deterministic stages passed?     */</span></span><br><span class="line">      has_new_cov,                    <span class="comment">/* Triggers new coverage?           */</span></span><br><span class="line">      var_behavior,                   <span class="comment">/* Variable behavior?               */</span></span><br><span class="line">      favored,                        <span class="comment">/* Currently favored?               */</span></span><br><span class="line">      fs_redundant;                   <span class="comment">/* Marked as redundant in the fs?   */</span></span><br><span class="line"></span><br><span class="line">  u32 bitmap_size,                    <span class="comment">/* Number of bits set in bitmap     */</span></span><br><span class="line">      exec_cksum;                     <span class="comment">/* Checksum of the execution trace  */</span></span><br><span class="line"></span><br><span class="line">  u64 exec_us,                        <span class="comment">/* Execution time (us)              */</span></span><br><span class="line">      handicap,                       <span class="comment">/* Number of queue cycles behind    */</span></span><br><span class="line">      depth;                          <span class="comment">/* Path depth                       */</span></span><br><span class="line"></span><br><span class="line">  u8* trace_mini;                     <span class="comment">/* Trace bytes, if kept             */</span></span><br><span class="line">  u32 tc_ref;                         <span class="comment">/* Trace bytes ref count     用于update_bitmap_score       */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">next</span>,           /* <span class="title">Next</span> <span class="title">element</span>, <span class="title">if</span> <span class="title">any</span>             */</span></span><br><span class="line"><span class="class">                     *<span class="title">next_100</span>;</span>       <span class="comment">/* 100 elements ahead               */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">queue</span>,     /* <span class="title">Fuzzing</span> <span class="title">queue</span> (<span class="title">linked</span> <span class="title">list</span>)      */</span></span><br><span class="line"><span class="class">                          *<span class="title">queue_cur</span>, /* <span class="title">Current</span> <span class="title">offset</span> <span class="title">within</span> <span class="title">the</span> <span class="title">queue</span>  */</span></span><br><span class="line"><span class="class">                          *<span class="title">queue_top</span>, /* <span class="title">Top</span> <span class="title">of</span> <span class="title">the</span> <span class="title">list</span>                  */</span></span><br><span class="line"><span class="class">                          *<span class="title">q_prev100</span>;</span> <span class="comment">/* Previous 100 marker              */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>*</span></span><br><span class="line"><span class="class">  <span class="title">top_rated</span>[<span class="title">MAP_SIZE</span>];</span>                <span class="comment">/* Top entries for bitmap bytes     */</span></span><br></pre></td></tr></tbody></table></figure></div>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将新的testcase添加到队列 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_to_queue</span><span class="params">(u8* fname, u32 len, u8 passed_det)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分配一个queue_entry结构，并进行初始化：</span></span><br><span class="line"><span class="comment">     1.fname设置testcase的为文件路径</span></span><br><span class="line"><span class="comment">     2.len设置为文件大小</span></span><br><span class="line"><span class="comment">     3.depth设置为cur_depth+1</span></span><br><span class="line"><span class="comment">     4.passed_det设置为传入的passed_det</span></span><br><span class="line"><span class="comment">     5.如果当前深度大于max_depth，则用当前深度替换max_depth</span></span><br><span class="line"><span class="comment">     6.判断queue_top是否存在：</span></span><br><span class="line"><span class="comment">          a.如果存在，将新初始化的q挂在queue_top单链表上，并将q设置为新的queue_top(链表尾)</span></span><br><span class="line"><span class="comment">          b.如果不存在，则将q分别设置为queue_top、queue、q_prev100这3个链表的首元素(链表头)</span></span><br><span class="line"><span class="comment">     7.队列中的测试用例数加1；待fuzz的测试用例数加1</span></span><br><span class="line"><span class="comment">     8.设置cycles_wo_finds的值为0，如果在某一轮fuzz时没有发现新的路径则会设置该值，这里是第一次</span></span><br><span class="line"><span class="comment">       遇到这个值，所以初始化为0 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> = <span class="title">ck_alloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">queue_entry</span>));</span></span><br><span class="line"></span><br><span class="line">  q->fname        = fname;</span><br><span class="line">  q->len          = len;</span><br><span class="line">  q->depth        = cur_depth + <span class="number">1</span>;</span><br><span class="line">  q->passed_det   = passed_det;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q->depth > max_depth) </span><br><span class="line">      max_depth = q->depth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_top) {</span><br><span class="line">    queue_top->next = q;</span><br><span class="line">    queue_top = q;</span><br><span class="line">  } <span class="keyword">else</span> </span><br><span class="line">      q_prev100 = <span class="built_in">queue</span> = queue_top = q;</span><br><span class="line"></span><br><span class="line">  queued_paths++;</span><br><span class="line">  pending_not_fuzzed++;</span><br><span class="line"></span><br><span class="line">  cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 每100个元素会设置一个next_100指针，用于更快速的迭代</span></span><br><span class="line"><span class="comment">     如果队列中已经有100个testcase对应的q(用testcase的信息初始化的queue_entry)：</span></span><br><span class="line"><span class="comment">     1.将q_prev100->next_100设置为新入队的q(例如第101个)，此时q_prev100下标为0，新入队的q下标</span></span><br><span class="line"><span class="comment">       为100，这个q_prev100链表串着每100个q里面的第一个q，这么做是为了能够更快的迭代</span></span><br><span class="line"><span class="comment">     2.接着将q_prev100也设置为q，即第101个q设置为q_prev100的链表尾</span></span><br><span class="line"><span class="comment">     最后将last_path_time设置为当前的系统时间</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="keyword">if</span> ((queued_paths - <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span> && queued_paths > <span class="number">1</span>) {</span><br><span class="line">    q_prev100->next_100 = q;</span><br><span class="line">    q_prev100 = q;</span><br><span class="line">  }</span><br><span class="line">  last_path_time = get_cur_time();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 加载自动生成的额外内容 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_auto</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进入主循环，遍历USE_AUTO_EXTRAS次，默认是50：</span></span><br><span class="line"><span class="comment">     1.拼接形成路径fn(in_dir/.state/auto_extras/auto_i)</span></span><br><span class="line"><span class="comment">     2.以只读模式打开路径fn指定的文件，将文件描述符返给fd；若打开失败，则抛出异常</span></span><br><span class="line"><span class="comment">     3.读取fd指定文件中MAX_AUTO_EXTRA+1个字节的内容(默认是32+1)，这里多读取1个字节来检测token</span></span><br><span class="line"><span class="comment">       是否过大:</span></span><br><span class="line"><span class="comment">          a.如果读取失败，则抛出异常</span></span><br><span class="line"><span class="comment">          b.如果读取成功，且读取的字节数在MIN_AUTO_EXTRA(默认为3)和MAX_AUTO_EXTRA(默认为32)</span></span><br><span class="line"><span class="comment">            之间，则调用maybe_add_auto */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < USE_AUTO_EXTRAS; i++) {</span><br><span class="line">    u8  tmp[MAX_AUTO_EXTRA + <span class="number">1</span>];</span><br><span class="line">    u8* fn = alloc_printf(<span class="string">"%s/.state/auto_extras/auto_%06u"</span>, in_dir, i);</span><br><span class="line">    s32 fd, len;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_RDONLY, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">if</span> (errno != ENOENT) PFATAL(<span class="string">"Unable to open '%s'"</span>, fn);</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">read</span>(fd, tmp, MAX_AUTO_EXTRA + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (len < <span class="number">0</span>)</span><br><span class="line">        PFATAL(<span class="string">"Unable to read from '%s'"</span>, fn);</span><br><span class="line">    <span class="keyword">if</span> (len >= MIN_AUTO_EXTRA && len <= MAX_AUTO_EXTRA)</span><br><span class="line">      maybe_add_auto(tmp, len);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 根据i是否存在，判断是否加载了自动生成的字典token */</span></span><br><span class="line">  <span class="keyword">if</span> (i) OKF(<span class="string">"Loaded %u auto-discovered dictionary tokens."</span>, i);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">"No auto-generated dictionary tokens to reuse."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="maybe-add-auto"><a href="#maybe-add-auto" class="headerlink" title="maybe_add_auto"></a>maybe_add_auto</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向自动生成的额外内容里面增加一些内容，mem为读取的auto_i文件，len为读取的长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maybe_add_auto</span><span class="params">(u8* mem, u32 len)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果MAX_AUTO_EXTRAS或USE_AUTO_EXTRAS没有设置，则直接return */</span></span><br><span class="line">  <span class="keyword">if</span> (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从mem[1]开始扫描，找到第一个与mem[0]不同的位置</span></span><br><span class="line"><span class="comment">     如果全都相同，则直接return */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i < len; i++)</span><br><span class="line">    <span class="keyword">if</span> (mem[<span class="number">0</span>] ^ mem[i]) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (i == len) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果mem的大小为2字节或者4字节，则用mem分别去与interesting_16或interesting_32进行比较，</span></span><br><span class="line"><span class="comment">     若存在相同的情况，则直接return掉。这里的interesting_16/32定义在afl-fuzz.c的开头；里面</span></span><br><span class="line"><span class="comment">     出现的INTERESTING_8/16/32定义在config.h；计算时用到的SWAP16/32算法定义在types.h */</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">2</span>) {</span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_16) >> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) </span><br><span class="line">      <span class="keyword">if</span> (*((u16*)mem) == interesting_16[i] ||</span><br><span class="line">          *((u16*)mem) == SWAP16(interesting_16[i])) <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">4</span>) {</span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_32) >> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) </span><br><span class="line">      <span class="keyword">if</span> (*((u32*)mem) == interesting_32[i] ||</span><br><span class="line">          *((u32*)mem) == SWAP32(interesting_32[i])) <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第一个循环：从已经读入的token里面找到第一个大小与mem相同的token下标，这么做是因为extras</span></span><br><span class="line"><span class="comment">               数组是会经过优化按照大小顺序排列</span></span><br><span class="line"><span class="comment">     第二个循环：从已经读入的token里面找到大小与mem相同的token，调用memcmp_nocase进行大小写</span></span><br><span class="line"><span class="comment">               不敏感的比较，若发现token与mem完全相同，则直接return，这一步和上面一样，还是</span></span><br><span class="line"><span class="comment">               筛选掉已经有的token */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < extras_cnt; i++)</span><br><span class="line">    <span class="keyword">if</span> (extras[i].len >= len) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (; i < extras_cnt && extras[i].len == len; i++)</span><br><span class="line">    <span class="keyword">if</span> (!memcmp_nocase(extras[i].data, mem, len)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 经过上面的校验，mem经过筛选，和interesting_16/32以及extras数组中的元素不同了，这时以同</span></span><br><span class="line"><span class="comment">     样的校验手法判断a_extras数组中是否有与mem相同的元素。如果存在相同的元素：</span></span><br><span class="line"><span class="comment">        1.令a_extras数组中该元素对应的hit_cnt字段加1，表示该语料被使用的次数增加1次</span></span><br><span class="line"><span class="comment">        2.接着跳转到sort_a_extras进行排序处理 */</span></span><br><span class="line">  auto_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < a_extras_cnt; i++) {</span><br><span class="line">    <span class="keyword">if</span> (a_extras[i].len == len && !memcmp_nocase(a_extras[i].data, mem, len)) {</span><br><span class="line">      a_extras[i].hit_cnt++;</span><br><span class="line">      <span class="keyword">goto</span> sort_a_extras;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果能走到这一步，说明interesting_8/16/32以及extras数组和a_extras数组中都没有匹配</span></span><br><span class="line"><span class="comment">     到这个mem元素，说明这是一个新的条目(entry)，为此，如果仍有空间的话，就把这个entry放到</span></span><br><span class="line"><span class="comment">     a_entras里面去；如果没有空间的话，就从a_extras数组的后半部分空间里，随机替换掉一个元素</span></span><br><span class="line"><span class="comment">     具体操作如下：</span></span><br><span class="line"><span class="comment">        1.如果a_extras_cnt < MAX_AUTO_EXTRAS，即余有空间：</span></span><br><span class="line"><span class="comment">           a.为a_extras数组增加一个extra_data空间</span></span><br><span class="line"><span class="comment">           b.设置新增extra_data.data为mem</span></span><br><span class="line"><span class="comment">           c.设置新增extra_data.len为len</span></span><br><span class="line"><span class="comment">           d.a_extra_cnt的值自增</span></span><br><span class="line"><span class="comment">        2.如果空间不足：</span></span><br><span class="line"><span class="comment">           a.从a_extras数组的后半部分空间里随机找到一个位置</span></span><br><span class="line"><span class="comment">           b.替换该位置上extra_data.data为mem</span></span><br><span class="line"><span class="comment">           c.替换该位置上extra_data.len为len</span></span><br><span class="line"><span class="comment">           d.将该位置上extra_data.hit_cnt的值置0 */</span></span><br><span class="line">  <span class="keyword">if</span> (a_extras_cnt < MAX_AUTO_EXTRAS) {</span><br><span class="line">    a_extras = ck_realloc_block(a_extras, (a_extras_cnt + <span class="number">1</span>) *</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct extra_data));</span><br><span class="line"></span><br><span class="line">    a_extras[a_extras_cnt].data = ck_memdup(mem, len);</span><br><span class="line">    a_extras[a_extras_cnt].len  = len;</span><br><span class="line">    a_extras_cnt++;</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    i = MAX_AUTO_EXTRAS / <span class="number">2</span> +</span><br><span class="line">        UR((MAX_AUTO_EXTRAS + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ck_free(a_extras[i].data);</span><br><span class="line"></span><br><span class="line">    a_extras[i].data    = ck_memdup(mem, len);</span><br><span class="line">    a_extras[i].len     = len;</span><br><span class="line">    a_extras[i].hit_cnt = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 函数原型：</span></span><br><span class="line"><span class="comment">     void qsort(void *base, size_t nmemb, size_t size, </span></span><br><span class="line"><span class="comment">        int (*compar)(const void *, const void *, void *), </span></span><br><span class="line"><span class="comment">        void *arg);</span></span><br><span class="line"><span class="comment">      作用：对数组大小为nmemb，每个元素大小为size，由base指定的数组，按照compar算法进行排序</span></span><br><span class="line"><span class="comment">      返回值：无 </span></span><br><span class="line"><span class="comment">      1.首先对a_extras所有元素按照元素大小进行降序排列(排序用的比较算法这里不展开，源码很简单)</span></span><br><span class="line"><span class="comment">      2.然后将a_extras中的前USE_AUTO_EXTRAS个元素按照其语料被使用次数进行降序排列 */</span></span><br><span class="line">sort_a_extras:</span><br><span class="line">  qsort(a_extras, a_extras_cnt, <span class="keyword">sizeof</span>(struct extra_data),</span><br><span class="line">        compare_extras_use_d);</span><br><span class="line">    </span><br><span class="line">  qsort(a_extras, MIN(USE_AUTO_EXTRAS, a_extras_cnt),</span><br><span class="line">        <span class="keyword">sizeof</span>(struct extra_data), compare_extras_len);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在out_dir/queue中为所有in_dir中的testcase创建硬链接 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pivot_inputs</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> = <span class="title">queue</span>;</span></span><br><span class="line">  u32 id = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  ACTF(<span class="string">"Creating hard links for all input files..."</span>);  </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (q) {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将q->fname中最后一个'/'后面的字符串赋给rsl；若没有'/'，就直接把fname赋给rsl */</span></span><br><span class="line">    u8  *nfn, *rsl = <span class="built_in">strrchr</span>(q->fname, <span class="string">'/'</span>);</span><br><span class="line">    u32 orig_id;</span><br><span class="line">    <span class="keyword">if</span> (!rsl) </span><br><span class="line">        rsl = q->fname; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        rsl++;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> CASE_PREFIX <span class="meta-string">"id:"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> CASE_PREFIX <span class="meta-string">"id_"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line">    <span class="comment">/* 如果原始文件名符合语法，并且文件名记录下的ID匹配上之前指定的ID，那么就使用原始文件名，</span></span><br><span class="line"><span class="comment">       这么做对于恢复fuzzing执行很有价值，具体需要满足的操作如下：</span></span><br><span class="line"><span class="comment">          1.rsl前3位为'id_'或'id:'(根据是否为SIMPLE_FILES进行判断)</span></span><br><span class="line"><span class="comment">          2.将rsl第4位开始的数字读取到orig_id，并且orig_id与id的值相等</span></span><br><span class="line"><span class="comment">       如果满足上述条件，则进行一些恢复操作，具体如下：</span></span><br><span class="line"><span class="comment">          a.设置resuming_fuzz的值为1</span></span><br><span class="line"><span class="comment">          b.拼接路径out_dir/queue/rsl，并赋值给nfn</span></span><br><span class="line"><span class="comment">          c.找到rsl第4位开始，第一个出现':'的位置，如果可以找到，就将':'后面开始的数字读取</span></span><br><span class="line"><span class="comment">            到src_id中，如果成功读取了src_id：</span></span><br><span class="line"><span class="comment">               1).从fuzzing队列头开始扫描，每扫描一个queue，与此同时src_id的值自减1</span></span><br><span class="line"><span class="comment">               2).如果src_id的值归0了，但queue还没到末尾。则通过被扫描的queue深度+1来</span></span><br><span class="line"><span class="comment">                  设置当前的queue</span></span><br><span class="line"><span class="comment">               3).判断max_depth是否发生了变化，并进行适当更新</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(rsl, CASE_PREFIX, <span class="number">3</span>) &&</span><br><span class="line">        <span class="built_in">sscanf</span>(rsl + <span class="number">3</span>, <span class="string">"%06u"</span>, &orig_id) == <span class="number">1</span> && orig_id == id) {</span><br><span class="line"></span><br><span class="line">      u8* src_str;</span><br><span class="line">      u32 src_id;</span><br><span class="line"></span><br><span class="line">      resuming_fuzz = <span class="number">1</span>;</span><br><span class="line">      nfn = alloc_printf(<span class="string">"%s/queue/%s"</span>, out_dir, rsl);</span><br><span class="line"></span><br><span class="line">      src_str = <span class="built_in">strchr</span>(rsl + <span class="number">3</span>, <span class="string">':'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (src_str && <span class="built_in">sscanf</span>(src_str + <span class="number">1</span>, <span class="string">"%06u"</span>, &src_id) == <span class="number">1</span>) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">s</span> = <span class="title">queue</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (src_id-- && s) </span><br><span class="line">            s = s->next;</span><br><span class="line">        <span class="keyword">if</span> (s) </span><br><span class="line">            q->depth = s->depth + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (max_depth < q->depth) </span><br><span class="line">            max_depth = q->depth;</span><br><span class="line">      }</span><br><span class="line">    } </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 如果不满足上述条件：</span></span><br><span class="line"><span class="comment">          a.如果不是SIMPLE_FILES:</span></span><br><span class="line"><span class="comment">             1).在rsl里搜索'orig:'，若能搜到，则将use_name设置为'orig:'后面的部分；否则</span></span><br><span class="line"><span class="comment">                直接将use_name设置为rsl</span></span><br><span class="line"><span class="comment">             2).拼接路径out_dir/queue/id:id,orig:use_name，并赋给nfn</span></span><br><span class="line"><span class="comment">          b.如果是SIMPLE_FILES:</span></span><br><span class="line"><span class="comment">             1).拼接路径out_dir/queue/id_id，并赋给nfn</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">#ifndef SIMPLE_FILES</span><br><span class="line">      u8* use_name = <span class="built_in">strstr</span>(rsl, <span class="string">",orig:"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (use_name) </span><br><span class="line">          use_name += <span class="number">6</span>; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">          use_name = rsl;</span><br><span class="line">      nfn = alloc_printf(<span class="string">"%s/queue/id:%06u,orig:%s"</span>, out_dir, id, use_name);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      nfn = alloc_printf(<span class="string">"%s/queue/id_%06u"</span>, out_dir, id);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 1.调用link_or_copy创建q->fname指定的输入测试用例文件到路径nfn的硬链接，内容也一并复制</span></span><br><span class="line"><span class="comment">       2.将q->fname原先指向的路径free掉，重新设置为nfn这个硬链接</span></span><br><span class="line"><span class="comment">       3.判断是否设置了passed_det的值，即是否fuzz过，如果fuzz过就调用mark_as_det_done打开</span></span><br><span class="line"><span class="comment">         或创建out_dir/queue/.state/deterministic_done/fname这个文件</span></span><br><span class="line"><span class="comment">       4.跳转到下一个q，用于外层循环的遍历</span></span><br><span class="line"><span class="comment">       5.id自增1 */</span></span><br><span class="line">    link_or_copy(q->fname, nfn);</span><br><span class="line">    ck_free(q->fname);</span><br><span class="line">    q->fname = nfn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q->passed_det)</span><br><span class="line">        mark_as_det_done(q);</span><br><span class="line">    q = q->next;</span><br><span class="line">    id++;</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果设置了in_place_resume，则调用nuke_resume_dir删除用于本地会话恢复的临时文件夹 */</span></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume) </span><br><span class="line">      nuke_resume_dir();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="nuke-resume-dir"><a href="#nuke-resume-dir" class="headerlink" title="nuke_resume_dir"></a>nuke_resume_dir</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除用于本地会话恢复的临时文件夹 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nuke_resume_dir</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u8* fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.删除out_dir/_resume/.state/deterministic_done目录下所有'id_'或'id:'前缀的文件</span></span><br><span class="line"><span class="comment">     2.删除out_dir/_resume/.state/auto_extras目录下所有'auto_'前缀的文件</span></span><br><span class="line"><span class="comment">     3.删除out_dir/_resume/.state/redundant_edges目录下所有'id_'或'id:'前缀的文件</span></span><br><span class="line"><span class="comment">     4.删除out_dir/_resume/.state/variable_behavior目录下所有'id_'或'id:'前缀的文件</span></span><br><span class="line"><span class="comment">     5.删除out_dir/_resume/.state/整个文件夹</span></span><br><span class="line"><span class="comment">     6.删除out_dir/_resume/目录下所有'id_'或'id:'前缀的文件 */</span></span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/_resume/.state/deterministic_done"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/_resume/.state/auto_extras"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, <span class="string">"auto_"</span>)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/_resume/.state/redundant_edges"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/_resume/.state/variable_behavior"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/_resume/.state"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">rmdir</span>(fn) && errno != ENOENT) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/_resume"</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (delete_files(fn, CASE_PREFIX)) <span class="keyword">goto</span> dir_cleanup_failed;</span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">dir_cleanup_failed:</span><br><span class="line">  FATAL(<span class="string">"_resume directory cleanup failed"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read extras from the extras directory and sort them by size.</span></span><br><span class="line"><span class="comment">   从extras目录读取额外的符号，并按照大小将它们排序 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_extras</span><span class="params">(u8* dir)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* struct dirent {</span></span><br><span class="line"><span class="comment">        long d_ino;                 // 索引节点号</span></span><br><span class="line"><span class="comment">        off_t d_off;                // 在目录文件中的偏移</span></span><br><span class="line"><span class="comment">        unsigned short d_reclen;    // 文件名长</span></span><br><span class="line"><span class="comment">        unsigned char d_type;       // 文件类型</span></span><br><span class="line"><span class="comment">        char d_name[NAME_MAX+1];    // 文件名，最长255字节</span></span><br><span class="line"><span class="comment">     } </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  DIR* d;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">de</span>;</span></span><br><span class="line">  u32 min_len = MAX_DICT_FILE, max_len = <span class="number">0</span>, dict_level = <span class="number">0</span>;</span><br><span class="line">  u8* x;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果dir中包含'@'，那么将'@'后面的字符串转换为数字，并赋值给dict_level */</span></span><br><span class="line">  <span class="keyword">if</span> ((x = <span class="built_in">strchr</span>(dir, <span class="string">'@'</span>))) {</span><br><span class="line">    *x = <span class="number">0</span>;</span><br><span class="line">    dict_level = atoi(x + <span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line">  ACTF(<span class="string">"Loading extra dictionary from '%s' (level %u)..."</span>, dir, dict_level);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 打开dir所在目录，如果不能打开且错误类型为ENOTDIR(说明不是一个目录文件)，则调用</span></span><br><span class="line"><span class="comment">     load_extras_file从文件中读取额外的符号，读取完毕后，跳转到check_and_sort排序 */</span>  </span><br><span class="line">  d = opendir(dir);</span><br><span class="line">  <span class="keyword">if</span> (!d) {</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTDIR) {</span><br><span class="line">      load_extras_file(dir, &min_len, &max_len, dict_level);</span><br><span class="line">      <span class="keyword">goto</span> check_and_sort;</span><br><span class="line">    }</span><br><span class="line">    PFATAL(<span class="string">"Unable to open '%s'"</span>, dir);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (x)</span><br><span class="line">      FATAL(<span class="string">"Dictionary levels not supported for directories."</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 走到这一步，说明传进来的dir是个目录。这里调用readdir来循环读取dir目录下的文件并进行如下操作：</span></span><br><span class="line"><span class="comment">        1.拼接路径dir/d_name，并赋值给dir</span></span><br><span class="line"><span class="comment">        2.读取fn路径对应文件的状态到st中，并判断该文件是否可访问</span></span><br><span class="line"><span class="comment">        3.根据st_mode(文件保护模式)、st_size(文件总大小)，筛选掉一些无关文件(参考read_testcases)</span></span><br><span class="line"><span class="comment">        4.判断st_size是否超过文件大小界限，并根据其大小设置min_len/max_len</span></span><br><span class="line"><span class="comment">        5.为extras数组增加一个extra_data的空间，并设置data的空间和len的值(参考maybe_add_auto)</span></span><br><span class="line"><span class="comment">        6.打开fn路径指向的文件，从该文件读取内容到extra_data.data</span></span><br><span class="line"><span class="comment">        7.关闭文件，free掉路径</span></span><br><span class="line"><span class="comment">        8.结束循环，关闭文件夹 */</span>  </span><br><span class="line">  <span class="keyword">while</span> ((de = readdir(d))) {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    u8* fn = alloc_printf(<span class="string">"%s/%s"</span>, dir, de->d_name);</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">"Unable to access '%s'"</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size) {</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size > MAX_DICT_FILE)</span><br><span class="line">      FATAL(<span class="string">"Extra '%s' is too big (%s, limit is %s)"</span>, fn,</span><br><span class="line">            DMS(st.st_size), DMS(MAX_DICT_FILE));</span><br><span class="line">    <span class="keyword">if</span> (min_len > st.st_size) </span><br><span class="line">        min_len = st.st_size;</span><br><span class="line">    <span class="keyword">if</span> (max_len < st.st_size) </span><br><span class="line">        max_len = st.st_size;</span><br><span class="line">    </span><br><span class="line">    extras = ck_realloc_block(extras, (extras_cnt + <span class="number">1</span>) *</span><br><span class="line">               <span class="keyword">sizeof</span>(struct extra_data));</span><br><span class="line">    extras[extras_cnt].data = ck_alloc(st.st_size);</span><br><span class="line">    extras[extras_cnt].len  = st.st_size;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"Unable to open '%s'"</span>, fn);</span><br><span class="line">    ck_read(fd, extras[extras_cnt].data, st.st_size, fn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line">    extras_cnt++;</span><br><span class="line">  }</span><br><span class="line">  closedir(d);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 下面这部分的核心就是调用qsort语句，对保存额外符号的extras数组，按照大小进行排序 */</span></span><br><span class="line">check_and_sort:</span><br><span class="line">  <span class="keyword">if</span> (!extras_cnt)</span><br><span class="line">      FATAL(<span class="string">"No usable files in '%s'"</span>, dir);</span><br><span class="line"></span><br><span class="line">  qsort(extras, extras_cnt, <span class="keyword">sizeof</span>(struct extra_data), compare_extras_len);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">"Loaded %u extra tokens, size range %s to %s."</span>, extras_cnt,</span><br><span class="line">      DMS(min_len), DMS(max_len));</span><br><span class="line">  <span class="keyword">if</span> (max_len > <span class="number">32</span>)</span><br><span class="line">    WARNF(<span class="string">"Some tokens are relatively large (%s) - consider trimming."</span>,</span><br><span class="line">          DMS(max_len));</span><br><span class="line">  <span class="keyword">if</span> (extras_cnt > MAX_DET_EXTRAS)</span><br><span class="line">    WARNF(<span class="string">"More than %u tokens - will use them probabilistically."</span>,</span><br><span class="line">          MAX_DET_EXTRAS);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 防止当“恢复会话”时，因为没有设置参数'-t'，而导致超时时间的不断调整的情况出现 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_timeout</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">4096</span>]; </span><br><span class="line"></span><br><span class="line">  u8  *fn, *off;</span><br><span class="line">  s32 fd, i;</span><br><span class="line">  u32 ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 主体流程：</span></span><br><span class="line"><span class="comment">     1.如果没有设置resuming_fuzz，直接return </span></span><br><span class="line"><span class="comment">     2.根据是否设置了in_place_resume，采取不同方式的路径拼接，并赋值给fn</span></span><br><span class="line"><span class="comment">     3.打开路径fn指定的文件，打开失败就return；打开成功就把文件描述符返回给fd</span></span><br><span class="line"><span class="comment">     4.从fd指定的文件中读取4095字节到tmp中；(void)i表示忽略读取是可能的错误；之后关闭文件</span></span><br><span class="line"><span class="comment">     5.从tmp中找到第一个出现字符串'exec_timeout   :'的位置：</span></span><br><span class="line"><span class="comment">        a.如果找不到，就直接return</span></span><br><span class="line"><span class="comment">        b.如果找到了，就将这个位置+20字节偏移后的字符串，转换为整数，并赋值给ret</span></span><br><span class="line"><span class="comment">           1).如果ret小于等于4，就直接return</span></span><br><span class="line"><span class="comment">           2).否则用ret赋值给exe_tmout</span></span><br><span class="line"><span class="comment">     6.设置timeout_given的值为3，给出指定的超时 */</span></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume) </span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/fuzzer_stats"</span>, out_dir);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/../fuzzer_stats"</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_RDONLY);</span><br><span class="line">  ck_free(fn);</span><br><span class="line">  <span class="keyword">if</span> (fd < <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  i = <span class="built_in">read</span>(fd, tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>); </span><br><span class="line">  (<span class="keyword">void</span>)i; </span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  off = <span class="built_in">strstr</span>(tmp, <span class="string">"exec_timeout      : "</span>);</span><br><span class="line">  <span class="keyword">if</span> (!off) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ret = atoi(off + <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret <= <span class="number">4</span>) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  exec_tmout = ret;</span><br><span class="line">  timeout_given = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检测参数中是否存在'@@'(对从文件读取输入的目标程序来说，要用'@@')，</span></span><br><span class="line"><span class="comment">   如果有就替换为拼接后的字符串；如果没有就直接return */</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">detect_file_args</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* getcwd == GET Current Working Directory */</span></span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  u8* cwd = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cwd)</span><br><span class="line">      PFATAL(<span class="string">"getcwd() failed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历所有参数，进行如下操作：</span></span><br><span class="line"><span class="comment">     1.在当前参数中找到，找到第一个出现'@@'的地方并赋值给aa_loc；如果没有找到就进行下一轮循环</span></span><br><span class="line"><span class="comment">     2.如果没有指定out_file，就将out_dir/.cur_input拼接后赋值给out_file</span></span><br><span class="line"><span class="comment">     3.判断out_file是否从'/'开始:</span></span><br><span class="line"><span class="comment">        a.如果是的话，就直接将out_file赋值给aa_subst</span></span><br><span class="line"><span class="comment">        b.否则将cwd/out_file拼接并赋值给aa_subst</span></span><br><span class="line"><span class="comment">     4.先将aa_loc(当前指向的值为'@@')的第一个'@'替换为空字节</span></span><br><span class="line"><span class="comment">     5.将现有的argv[i]、aa_subst、aa_loc第二个字节之后的字符串，进行拼接，返回给n_arg</span></span><br><span class="line"><span class="comment">     6.将现有的argv[i]用n_arg替换</span></span><br><span class="line"><span class="comment">     7.将aa_loc(当前指向的值为' @')的第一个空字节替换回'@'</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="keyword">while</span> (argv[i]) {</span><br><span class="line">    u8* aa_loc = <span class="built_in">strstr</span>(argv[i], <span class="string">"@@"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aa_loc) {</span><br><span class="line">      u8 *aa_subst, *n_arg;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!out_file)</span><br><span class="line">        out_file = alloc_printf(<span class="string">"%s/.cur_input"</span>, out_dir);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] == <span class="string">'/'</span>) </span><br><span class="line">          aa_subst = out_file;</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">          aa_subst = alloc_printf(<span class="string">"%s/%s"</span>, cwd, out_file);</span><br><span class="line"></span><br><span class="line">      *aa_loc = <span class="number">0</span>;</span><br><span class="line">      n_arg = alloc_printf(<span class="string">"%s%s%s"</span>, argv[i], aa_subst, aa_loc + <span class="number">2</span>);</span><br><span class="line">      argv[i] = n_arg;</span><br><span class="line">      *aa_loc = <span class="string">'@'</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] != <span class="string">'/'</span>) </span><br><span class="line">          ck_free(aa_subst);</span><br><span class="line">    }</span><br><span class="line">    i++;</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">free</span>(cwd); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果没有设置'-f'参数，就删除旧的out_dir/.cur_input文件，并创建一个同名的新文件 */</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_stdio_file</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 拼接out_dir/.cur_input作为路径赋值给fn；然后将该路径对应的文件删除 */</span>  </span><br><span class="line">  u8* fn = alloc_printf(<span class="string">"%s/.cur_input"</span>, out_dir);</span><br><span class="line">  unlink(fn); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据路径fn创建新的文件作为输出文件，并将文件描述符赋给out_fd */</span></span><br><span class="line">  out_fd = <span class="built_in">open</span>(fn, O_RDWR | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (out_fd < <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">"Unable to create '%s'"</span>, fn);</span><br><span class="line">  ck_free(fn);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h3><p>这个函数不是非常核心的部分，代码又过于冗长，这里仅摘取一小段，并介绍功能，我这里直接引用本文借鉴的大佬们对这个函数的分析，并在这保留了源码中的注释。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Do a PATH search and find target binary to see that it exists and</span></span><br><span class="line"><span class="comment">   isn't a shell script - a common and painful mistake. We also check for</span></span><br><span class="line"><span class="comment">   a valid ELF header and for evidence of AFL instrumentation. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sakura：check指定路径处要执行的程序是否存在，且它不能是一个shell script */</span></span><br><span class="line"><span class="comment">/* hollk：检查指定路径要执行的程序是否存在，是否为shell脚本，同时检查elf文件头是否合法及程序是否被插桩 */</span></span><br><span class="line"><span class="comment">/* ScUpax0s：检查目标文件有效性：是否是可执行文件，是否是Mach-O还是ELF还是一个生成的shell文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">check_binary</span><span class="params">(u8* fname)</span></span>{</span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="comment">/* 以下为对ELF文件和Mach-O文件格式特征的判断 */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> __APPLE__   </span></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] != <span class="number">0x7f</span> || <span class="built_in">memcmp</span>(f_data + <span class="number">1</span>, <span class="string">"ELF"</span>, <span class="number">3</span>))</span><br><span class="line">    FATAL(<span class="string">"Program '%s' is not an ELF binary"</span>, target_path);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">  <span class="keyword">if</span> (f_data[<span class="number">0</span>] != <span class="number">0xCF</span> || f_data[<span class="number">1</span>] != <span class="number">0xFA</span> || f_data[<span class="number">2</span>] != <span class="number">0xED</span>)</span><br><span class="line">    FATAL(<span class="string">"Program '%s' is not a 64-bit Mach-O binary"</span>, target_path);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!__APPLE__ */</span></span></span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="get-cur-time"><a href="#get-cur-time" class="headerlink" title="get_cur_time"></a>get_cur_time</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取unix系统的当前时间，单位为毫秒 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_cur_time</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    </span><br><span class="line">  gettimeofday(&tv, &tz);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> (tv.tv_sec * <span class="number">1000U</span>LL) + (tv.tv_usec / <span class="number">1000</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="get-qemu-argv"><a href="#get-qemu-argv" class="headerlink" title="get_qemu_argv"></a>get_qemu_argv</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果设置了参数'-Q'，即处于QEMU模式下，需要重写QEMU的参数。QEMU模式的fuzz，Shell语句可能如下所示：</span></span><br><span class="line"><span class="comment">   'afl-fuzz -i fuzz_in/ -o fuzz_out/ -Q ./normal_test' */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>** <span class="title">get_qemu_argv</span><span class="params">(u8* own_loc, <span class="keyword">char</span>** argv, <span class="keyword">int</span> argc)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 为存储新参数的new_argv数组申请空间 */</span>  </span><br><span class="line">  <span class="keyword">char</span>** new_argv = ck_alloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * (argc + <span class="number">4</span>));</span><br><span class="line">  u8 *tmp, *cp, *rsl, *own_copy;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 首先是QEMU稳定性故障的解决方法： </span></span><br><span class="line"><span class="comment">     1.(覆盖)设置环境变量QEMU_LOG的值为'nochain'</span></span><br><span class="line"><span class="comment">     2.将原先参数从第2个参数开始，依次复制到new_argv数组从第4个参数开始的位置</span></span><br><span class="line"><span class="comment">     3.将new_argv数组的第3个参数设置为'target_path'；第2个参数设置为'--'</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  setenv(<span class="string">"QEMU_LOG"</span>, <span class="string">"nochain"</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(new_argv + <span class="number">3</span>, argv + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * argc);</span><br><span class="line">  new_argv[<span class="number">2</span>] = target_path;</span><br><span class="line">  new_argv[<span class="number">1</span>] = <span class="string">"--"</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 接下来负责找到QEMU二进制程序，并将其作为第1个参数传给数组new_argv，</span></span><br><span class="line"><span class="comment">     这里有3种方法去实现这个操作，第一种方法：</span></span><br><span class="line"><span class="comment">     1.获取环境变量AFL_PATH的值，并赋值给tmp</span></span><br><span class="line"><span class="comment">     2.如果tmp存在：</span></span><br><span class="line"><span class="comment">          a.将tmp/afl-qemu-trace拼接成路径，并赋给cp</span></span><br><span class="line"><span class="comment">          b.如果路径cp可以访问，则将cp赋给new_argv数组的第一个参数，以及target_path</span></span><br><span class="line"><span class="comment">     3.如果tmp不存在：</span></span><br><span class="line"><span class="comment">          a.继续执行尝试第二种方法*/</span></span><br><span class="line">  tmp = getenv(<span class="string">"AFL_PATH"</span>);</span><br><span class="line">  <span class="keyword">if</span> (tmp) {</span><br><span class="line">    cp = alloc_printf(<span class="string">"%s/afl-qemu-trace"</span>, tmp);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (access(cp, X_OK))</span><br><span class="line">      FATAL(<span class="string">"Unable to find '%s'"</span>, tmp);</span><br><span class="line">    target_path = new_argv[<span class="number">0</span>] = cp;</span><br><span class="line">    <span class="keyword">return</span> new_argv;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 第二种方法：</span></span><br><span class="line"><span class="comment">     1.将own_loc的值赋给own_copy；这个own_loc就是原先传入的argv[0]，通常是'afl-fuzz的路径'</span></span><br><span class="line"><span class="comment">     2.接下来做的操作经常见，已经很熟悉了，其实就是在afl-fuzz的同一个目录下搜索afl-qemu-trace</span></span><br><span class="line"><span class="comment">     3.搜索到以后，就获取这个afl-qemu-trace的路径，然后赋值给new_argv第一个参数和target_path</span></span><br><span class="line"><span class="comment">     4.如果没能找到afl-qemu-trace，就继续执行，尝试第三种方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  own_copy = ck_strdup(own_loc);</span><br><span class="line">  rsl = <span class="built_in">strrchr</span>(own_copy, <span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rsl) {</span><br><span class="line">    *rsl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cp = alloc_printf(<span class="string">"%s/afl-qemu-trace"</span>, own_copy);</span><br><span class="line">    ck_free(own_copy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(cp, X_OK)) {</span><br><span class="line">      target_path = new_argv[<span class="number">0</span>] = cp;</span><br><span class="line">      <span class="keyword">return</span> new_argv;</span><br><span class="line">    }</span><br><span class="line">  } </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">      ck_free(own_copy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第三种方法：</span></span><br><span class="line"><span class="comment">     1.直接访问环境变量BIN_PATH与'/afl-qemu-trace'拼接的路径</span></span><br><span class="line"><span class="comment">     2.如果该路径可以访问，则将拼接后的路径赋给new_argv的第一个参数，并同时赋给target_path</span></span><br><span class="line"><span class="comment">     3.如果该路径不可以访问，说明3种获取方法afl-qemu-trace的方式都失败了，则打印错误信息、抛出异常</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!access(BIN_PATH <span class="string">"/afl-qemu-trace"</span>, X_OK)) {</span><br><span class="line">    target_path = new_argv[<span class="number">0</span>] = ck_strdup(BIN_PATH <span class="string">"/afl-qemu-trace"</span>);</span><br><span class="line">    <span class="keyword">return</span> new_argv;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">       <span class="string">"Oops, unable to find the 'afl-qemu-trace' binary. The binary must be built\n"</span></span><br><span class="line">       <span class="string">"    separately by following the instructions in qemu_mode/README.qemu. If you\n"</span></span><br><span class="line">       <span class="string">"    already have the binary installed, you may need to specify AFL_PATH in the\n"</span></span><br><span class="line">       <span class="string">"    environment.\n\n"</span></span><br><span class="line">       <span class="string">"    Of course, even without QEMU, afl-fuzz can still work with binaries that are\n"</span></span><br><span class="line">       <span class="string">"    instrumented at compile time with afl-gcc. It is also possible to use it as a\n"</span></span><br><span class="line">       <span class="string">"    traditional \"dumb\" fuzzer by specifying '-n' in the command line.\n"</span>);</span><br><span class="line">  FATAL(<span class="string">"Failed to locate 'afl-qemu-trace'."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行所有测试用例的试运行，以确保应用程序按照预取正常运行。这仅针对初始输入执行，并且仅执行一次 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_dry_run</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 变量初始化：</span></span><br><span class="line"><span class="comment">     1.q获取到fuzzing queue的链表头</span></span><br><span class="line"><span class="comment">     2.设置cal_failures的值为0(这里第一次出现，不是全局变量)</span></span><br><span class="line"><span class="comment">     3.获取环境变量AFL_SKIP_CRASHES，赋给skip_crashes</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> = <span class="title">queue</span>;</span></span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = getenv(<span class="string">"AFL_SKIP_CRASHES"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 遍历fuzzing queue的各个queue_entry：</span></span><br><span class="line"><span class="comment">     1.匹配到q->fname中最后一个'/'之后的字符串(测试用例文件名)并说明这是即将试运行的测试用例文件</span></span><br><span class="line"><span class="comment">     2.以只读模式打开q->fname路径指定测试用例文件，若打开失败则抛出异常</span></span><br><span class="line"><span class="comment">     3.根据测试用例文件的大小q->len，申请一块非零的空间，返回给use_mem</span></span><br><span class="line"><span class="comment">     4.将测试用例文件中的内容，读取到use_mem中</span></span><br><span class="line"><span class="comment">     5.调用calibrate(argv, q, use_mem, 0, 1)进行测试用例校准，将执行结果返回给变量res，然后</span></span><br><span class="line"><span class="comment">       free掉use_mem申请的空间</span></span><br><span class="line"><span class="comment">     7.如果设置了stop_soon，(当按下Ctrl-C时，会设置该值)，就直接return</span></span><br><span class="line"><span class="comment">     8.根据res的值进行相应处理，如果值为crash_mode或者FAULT_NOBITS，那么会打印出一些执行时的参</span></span><br><span class="line"><span class="comment">       数；如果为其它值，则进入下面的switch语句进行筛选处理 */</span></span><br><span class="line">  <span class="keyword">while</span> (q) {</span><br><span class="line">    u8* use_mem;</span><br><span class="line">    u8  res;</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q->fname, <span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    ACTF(<span class="string">"Attempting dry run with '%s'..."</span>, fn);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(q->fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"Unable to open '%s'"</span>, q->fname);</span><br><span class="line"></span><br><span class="line">    use_mem = ck_alloc_nozero(q->len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fd, use_mem, q->len) != q->len)</span><br><span class="line">      FATAL(<span class="string">"Short read from '%s'"</span>, q->fname);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">"    len = %u, map size = %u, exec speed = %llu us\n"</span> cRST, </span><br><span class="line">           q->len, q->bitmap_size, q->exec_us);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 9.Switch部分，依据res的结果查看错误类型进行判断：</span></span><br><span class="line"><span class="comment">          a.FAULT_NONE：</span></span><br><span class="line"><span class="comment">             1).如果q是头节点，即第一个测试用例，则调用check_map_coverage，对覆盖率进行评估：</span></span><br><span class="line"><span class="comment">                0x1：如果trace_bits发现的路径数小于100，就直接返回</span></span><br><span class="line"><span class="comment">                0x2：在trace_bits数组的后半段，如果有值就直接返回</span></span><br><span class="line"><span class="comment">             2).如果为crash_mode，则抛出异常，指出“测试用例不会导致crash”</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">          b.FAULT_TMOUT：</span></span><br><span class="line"><span class="comment">             1).如果设置了timeout_give(即指定了'-t'参数)，</span></span><br><span class="line"><span class="comment">                0x1：如果timeout_give>1：</span></span><br><span class="line"><span class="comment">                     *设置该测试用例的q->cal_failed值为CAL_CHANCES，表示校准失败</span></span><br><span class="line"><span class="comment">                     *令cal_failures(局部变量)的值加1</span></span><br><span class="line"><span class="comment">                0x2：否则显示警告并抛出异常</span></span><br><span class="line"><span class="comment">             2).如果没设置timeout_give，直接显示警告,并抛出异常指出“测试用例导致了超时”</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">          c.FAULT_CRASH：</span></span><br><span class="line"><span class="comment">             1).如果设置了crash_mode(参数指定'-C')，直接break掉</span></span><br><span class="line"><span class="comment">             2).如果skip_crashes存在(从环境变量AFL_SKIP_CRASHES获取)，那么先抛出警告，然后：</span></span><br><span class="line"><span class="comment">                0x1.设置q->cal_failed值为CAL_CHANCES，表示校准失败</span></span><br><span class="line"><span class="comment">                0x2.令cal_failures的值加1</span></span><br><span class="line"><span class="comment">             3).如果设置了mem_limit,则会抛出增加内存的建议</span></span><br><span class="line"><span class="comment">             4).抛出异常，指出“测试用例导致了crash”</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">          d.FAULT_ERROR：</span></span><br><span class="line"><span class="comment">             1).抛出异常，指出“无法执行目标程序”</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">          e.FAULT_NOINST：</span></span><br><span class="line"><span class="comment">             1).抛出异常，指出“没有检测到桩代码”</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">          f.FAULT_NOBITS：</span></span><br><span class="line"><span class="comment">             1).令useless_at_start(无用的开始路径)加1</span></span><br><span class="line"><span class="comment">             2).如果没有设置in_bitmap(即没有通过'-B'参数指定Input_bitmap)，并且shuffle_queue</span></span><br><span class="line"><span class="comment">                也不存在(即没有设置环境变量AFL_SHUFFLE_QUEUE)，则抛出警告，指出“没有新的桩代码输出，</span></span><br><span class="line"><span class="comment">                当前测试用例可能是无用的”。</span></span><br><span class="line"><span class="comment">             3).直接break掉，不抛出异常</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">switch</span> (res) {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NONE:</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="built_in">queue</span>)</span><br><span class="line">            check_map_coverage();</span><br><span class="line">        <span class="keyword">if</span> (crash_mode)</span><br><span class="line">            FATAL(<span class="string">"Test case '%s' does *NOT* crash"</span>, fn);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line">        <span class="keyword">if</span> (timeout_given) {</span><br><span class="line">          <span class="comment">/* The -t nn+ syntax in the command line sets timeout_given to '2' and</span></span><br><span class="line"><span class="comment">             instructs afl-fuzz to tolerate but skip queue entries that time</span></span><br><span class="line"><span class="comment">             out. */</span></span><br><span class="line">          <span class="keyword">if</span> (timeout_given > <span class="number">1</span>) {</span><br><span class="line">            WARNF(<span class="string">"Test case results in a timeout (skipping)"</span>);</span><br><span class="line">            q->cal_failed = CAL_CHANCES;</span><br><span class="line">            cal_failures++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">          SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">               <span class="string">"The program took more than %u ms to process one of the initial test cases.\n"</span></span><br><span class="line">               <span class="string">"    Usually, the right thing to do is to relax the -t option - or to delete it\n"</span></span><br><span class="line">               <span class="string">"    altogether and allow the fuzzer to auto-calibrate. That said, if you know\n"</span></span><br><span class="line">               <span class="string">"    what you are doing and want to simply skip the unruly test cases, append\n"</span></span><br><span class="line">               <span class="string">"    '+' at the end of the value passed to -t ('-t %u+').\n"</span>, exec_tmout,</span><br><span class="line">               exec_tmout);</span><br><span class="line">          FATAL(<span class="string">"Test case '%s' results in a timeout"</span>, fn);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">               <span class="string">"The program took more than %u ms to process one of the initial test cases.\n"</span></span><br><span class="line">               <span class="string">"    This is bad news; raising the limit with the -t option is possible, but\n"</span></span><br><span class="line">               <span class="string">"    will probably make the fuzzing process extremely slow.\n\n"</span></span><br><span class="line"></span><br><span class="line">               <span class="string">"    If this test case is just a fluke, the other option is to just avoid it\n"</span></span><br><span class="line">               <span class="string">"    altogether, and find one that is less of a CPU hog.\n"</span>, exec_tmout);</span><br><span class="line">          FATAL(<span class="string">"Test case '%s' results in a timeout"</span>, fn);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_CRASH:  </span><br><span class="line">        <span class="keyword">if</span> (crash_mode)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (skip_crashes) {</span><br><span class="line">          WARNF(<span class="string">"Test case results in a crash (skipping)"</span>);</span><br><span class="line">          q->cal_failed = CAL_CHANCES;</span><br><span class="line">          cal_failures++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem_limit) {</span><br><span class="line">          SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">               <span class="string">"Oops, the program crashed with one of the test cases provided. There are\n"</span></span><br><span class="line">               <span class="string">"    several possible explanations:\n\n"</span></span><br><span class="line"></span><br><span class="line">               <span class="string">"    - The test case causes known crashes under normal working conditions. If\n"</span></span><br><span class="line">               <span class="string">"      so, please remove it. The fuzzer should be seeded with interesting\n"</span></span><br><span class="line">               <span class="string">"      inputs - but not ones that cause an outright crash.\n\n"</span></span><br><span class="line"></span><br><span class="line">               <span class="string">"    - The current memory limit (%s) is too low for this program, causing\n"</span></span><br><span class="line">               <span class="string">"      it to die due to OOM when parsing valid files. To fix this, try\n"</span></span><br><span class="line">               <span class="string">"      bumping it up with the -m setting in the command line. If in doubt,\n"</span></span><br><span class="line">               <span class="string">"      try something along the lines of:\n\n"</span></span><br><span class="line"></span><br><span class="line">#ifdef RLIMIT_AS</span><br><span class="line">               <span class="string">"      ( ulimit -Sv $[%llu << 10]; /path/to/binary [...] <testcase )\n\n"< span></testcase></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">               <span class="string">"      ( ulimit -Sd $[%llu << 10]; /path/to/binary [...] <testcase )\n\n"< span></testcase></span><br><span class="line">#endif <span class="comment">/* ^RLIMIT_AS */</span></span><br><span class="line"></span><br><span class="line">               <span class="string">"      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"</span></span><br><span class="line">               <span class="string">"      estimate the required amount of virtual memory for the binary. Also,\n"</span></span><br><span class="line">               <span class="string">"      if you are using ASAN, see %s/notes_for_asan.txt.\n\n"</span></span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">  </span><br><span class="line">               <span class="string">"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"</span></span><br><span class="line">               <span class="string">"      break afl-fuzz performance optimizations when running platform-specific\n"</span></span><br><span class="line">               <span class="string">"      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"</span></span><br><span class="line"></span><br><span class="line">#endif <span class="comment">/* __APPLE__ */</span></span><br><span class="line"></span><br><span class="line">               <span class="string">"    - Least likely, there is a horrible bug in the fuzzer. If other options\n"</span></span><br><span class="line">               <span class="string">"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n"</lcamtuf@coredump.cx></span>,</span><br><span class="line">               DMS(mem_limit << <span class="number">20</span>), mem_limit - <span class="number">1</span>, doc_path);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            </span><br><span class="line">          SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">               <span class="string">"Oops, the program crashed with one of the test cases provided. There are\n"</span></span><br><span class="line">               <span class="string">"    several possible explanations:\n\n"</span></span><br><span class="line"></span><br><span class="line">               <span class="string">"    - The test case causes known crashes under normal working conditions. If\n"</span></span><br><span class="line">               <span class="string">"      so, please remove it. The fuzzer should be seeded with interesting\n"</span></span><br><span class="line">               <span class="string">"      inputs - but not ones that cause an outright crash.\n\n"</span></span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">  </span><br><span class="line">               <span class="string">"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"</span></span><br><span class="line">               <span class="string">"      break afl-fuzz performance optimizations when running platform-specific\n"</span></span><br><span class="line">               <span class="string">"      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"</span></span><br><span class="line"></span><br><span class="line">#endif <span class="comment">/* __APPLE__ */</span></span><br><span class="line"></span><br><span class="line">               <span class="string">"    - Least likely, there is a horrible bug in the fuzzer. If other options\n"</span></span><br><span class="line">               <span class="string">"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n"</lcamtuf@coredump.cx></span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">"Test case '%s' results in a crash"</span>, fn);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_ERROR:</span><br><span class="line">        FATAL(<span class="string">"Unable to execute target application ('%s')"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NOINST:</span><br><span class="line">        FATAL(<span class="string">"No instrumentation detected"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> FAULT_NOBITS: </span><br><span class="line">        useless_at_start++;</span><br><span class="line">        <span class="keyword">if</span> (!in_bitmap && !shuffle_queue)</span><br><span class="line">          WARNF(<span class="string">"No new instrumentation output, test case may be useless."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 10.如果q->var_behavior的值被设置，说明多次运行该测试用例，同等输入条件下，会表现出不同的行为</span></span><br><span class="line"><span class="comment">          ，则抛出警告，指出“该测试用例的路径输出可变”。最后读取下一个queue，回到循环开头继续执行 */</span></span><br><span class="line">    <span class="keyword">if</span> (q->var_behavior) </span><br><span class="line">        WARNF(<span class="string">"Instrumentation output varies across runs."</span>);</span><br><span class="line">    q = q->next;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果cal_failures的值被设置，说明测试用例导致了afl-fuzz超时或者Crash，开始进一步判断：</span></span><br><span class="line"><span class="comment">        1).如果cal_failures==queued_paths，说明所有的测试用例都超时或者Crash了，抛出异常</span></span><br><span class="line"><span class="comment">        2).如果cal_failures*5 > queued_paths，则抛出警告指出“有问题的测试用例比例超过20%，可能</span></span><br><span class="line"><span class="comment">           需要重新检查设置” */</span> </span><br><span class="line">  <span class="keyword">if</span> (cal_failures) {</span><br><span class="line">    <span class="keyword">if</span> (cal_failures == queued_paths)</span><br><span class="line">      FATAL(<span class="string">"All test cases time out%s, giving up!"</span>,</span><br><span class="line">            skip_crashes ? <span class="string">" or crash"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    WARNF(<span class="string">"Skipped %u test cases (%0.02f%%) due to timeouts%s."</span>, cal_failures,</span><br><span class="line">          ((<span class="keyword">double</span>)cal_failures) * <span class="number">100</span> / queued_paths,</span><br><span class="line">          skip_crashes ? <span class="string">" or crashes"</span> : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (cal_failures * <span class="number">5</span> > queued_paths)</span><br><span class="line">      WARNF(cLRD <span class="string">"High percentage of rejected test cases, check settings!"</span>);</span><br><span class="line">  }</span><br><span class="line">  OKF(<span class="string">"All test cases processed."</span>);</span><br><span class="line">}</span><br></span></span></pre></td></tr></tbody></table></figure></div>



<h3 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数将in_dir路径下的测试用例多次运行，评估是否存在异常行为，以便在早期就发现有问题的</span></span><br><span class="line"><span class="comment">   测试用例；并且在发现新路径时，评估新发现的测试用例的是否可变（这里的可变是指多次执行这个</span></span><br><span class="line"><span class="comment">   testcase，发现的路径不同）。该函数在perform_dry_run、save_if_interesting、</span></span><br><span class="line"><span class="comment">   fuzz_one函数中均有调用。此外，该函数也将初始化并启动fork server </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">calibrate_case</span><span class="params">(<span class="keyword">char</span>** argv, struct queue_entry* q, u8* use_mem,</span></span></span><br><span class="line"><span class="function"><span class="params">                         u32 handicap, u8 from_queue)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 部分局部变量概述：</span></span><br><span class="line"><span class="comment">     1.first_trace，将暂存trace_bits的值，也会用于var_bytes的设置</span></span><br><span class="line"><span class="comment">     2.如果q->exec_cksum为0，表示这个testcase是第一次运行，且来自in_dir文件夹，此时first_run置1</span></span><br><span class="line"><span class="comment">     3.old_sc/old_sm/old_sn用于暂存一些值，以便在程序出错时恢复</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line">  u8  fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>, hnb = <span class="number">0</span>,</span><br><span class="line">      first_run = (q->exec_cksum == <span class="number">0</span>);</span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8* old_sn = stage_name;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 1.如果free_queue为0（在perfrom_dry_run中为0，其它时候被调用为1），并且设置了resuming_fuzz</span></span><br><span class="line"><span class="comment">     ，那么这里会将use_tmout设置为一个更大的值</span></span><br><span class="line"><span class="comment">     2.q->cal_failed++</span></span><br><span class="line"><span class="comment">     3.设置stage_name为calibration，表明fuzz当前到了评估测试用例的阶段</span></span><br><span class="line"><span class="comment">     4.根据是否设置了fast_cal（环境变量AFL_FAST_CAL）来设置stage_max的值（CAL_CYCLES的值为8），</span></span><br><span class="line"><span class="comment">       这里的stage_max表示每个新测试用例（以及显示出可变行为的测试用例）的校准周期数，也就是说这个阶段</span></span><br><span class="line"><span class="comment">       （评估测试用例）需要执行（run_target）几次</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  q->cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">"calibration"</span>;</span><br><span class="line">  stage_max  = fast_cal ? <span class="number">3</span> : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 这部分代码确保在做任何事情之前，已经启动fork server：</span></span><br><span class="line"><span class="comment">     1.检查forkserver初始化条件，如果合适则调用init_forkserver来启动fork server：</span></span><br><span class="line"><span class="comment">        a.dumb_mode != 1（这里注意，设置'n'参数后，dumb_mode的值可能为1或2，由环境变量</span></span><br><span class="line"><span class="comment">          AFL_DUMB_FORKSRV决定）</span></span><br><span class="line"><span class="comment">        b.未设置no_forkserver（即未设置环境变量AFL_NO_FORKSRV）</span></span><br><span class="line"><span class="comment">        c.forksrv_pid不存在，即尚未初始化fork server</span></span><br><span class="line"><span class="comment">     2.判断q->exec_cksum的值是否存在（第一次执行时会被置0，之后会被设置为一个哈希值），</span></span><br><span class="line"><span class="comment">       如果存在，说明这个testcase不是来自己in_dir文件夹，则进行如下操作：</span></span><br><span class="line"><span class="comment">        a.将trace_bits的内容拷贝到first_trace中（如果路径可变，run_target后，first_trace</span></span><br><span class="line"><span class="comment">          与trace_bits中的值可能有所不同）</span></span><br><span class="line"><span class="comment">        b.调用has_new_bits判断是否有新的路径，并相应更新virgin_bits数组</span></span><br><span class="line"><span class="comment">        c.根据has_new_bits的返回值，判断是否需要设置new_bits（new_bits初始为0）</span></span><br><span class="line"><span class="comment">     3.获取进入循环前的开始时间</span></span><br><span class="line"><span class="comment">  */</span>    </span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> && !no_forkserver && !forksrv_pid)</span><br><span class="line">    init_forkserver(argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q->exec_cksum) {</span><br><span class="line">    <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">    hnb = has_new_bits(virgin_bits);</span><br><span class="line">    <span class="keyword">if</span> (hnb > new_bits) </span><br><span class="line">        new_bits = hnb;</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line">  start_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* calibrate_case的主循环，循环次数为stage_max，默认是8。如果设置了环境变量AFL_FAST_CAL，</span></span><br><span class="line"><span class="comment">     则会设置为3：</span></span><br><span class="line"><span class="comment">     1.如果不是第一次运行，并且到了状态更新的周期(stats_update_freq默认为1)，则调用show_stats</span></span><br><span class="line"><span class="comment">       显示fuzz状态界面</span></span><br><span class="line"><span class="comment">     2.调用write_to_testcase，将当前测试用例的内容(use_mem)写入到out_file(在detect_file_args</span></span><br><span class="line"><span class="comment">       中，out_file被设置为out_dir/.cur_input)</span></span><br><span class="line"><span class="comment">     3.调用run_target，该函数调用目标程序，监控出现超时的情况，并返回状态信息。被调用的程序会更新</span></span><br><span class="line"><span class="comment">       路径表trace_bits数组。同时这里也会通知fork server可以开始fork并fuzz</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur < stage_max; stage_cur++) {</span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first_run && !(stage_cur % stats_update_freq)) </span><br><span class="line">        show_stats();</span><br><span class="line"></span><br><span class="line">    write_to_testcase(use_mem, q->len);</span><br><span class="line">    fault = run_target(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1.如果摁下了Ctrl+C，或者run_target返回的错误类型不是crash_mode</span></span><br><span class="line"><span class="comment">          a.执行abort_calibration处的代码</span></span><br><span class="line"><span class="comment">       2.如果未设置dumb_mode，并且当前为第一次运行，并且trace_bits没有任何路径（这里的</span></span><br><span class="line"><span class="comment">         count_bytes函数用于计算共享内存里有多少字节被置位了）：</span></span><br><span class="line"><span class="comment">          a.将错误类型设置为FAULT_NOINST</span></span><br><span class="line"><span class="comment">          b.执行abort_calibration处的代码 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode) </span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode && !stage_cur && !count_bytes(trace_bits)) {</span><br><span class="line">      fault = FAULT_NOINST;</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1.计算hash32(trace_bits, MAP_SIZE, HASH_CONST)的结果，保存到cksum</span></span><br><span class="line"><span class="comment">       2.如果cksum与测试用例自身的q->exec_cksum不同，说明可能是第一次运行或者，这是一个路径可变</span></span><br><span class="line"><span class="comment">         的testcase，那么进行如下操作：</span></span><br><span class="line"><span class="comment">          a.调用has_new_bits判断是否有新的路径，并更新virgin_bits数组</span></span><br><span class="line"><span class="comment">          b.根据has_new_bits的返回值，决定是否更新new_bits的值</span></span><br><span class="line"><span class="comment">          c.判断q->exec_cksum的值</span></span><br><span class="line"><span class="comment">             1).如果q->exec_cksum不为0(说明可能是路径可变的testcase)：</span></span><br><span class="line"><span class="comment">                *.i从0~MAP_SIZE遍历，如果first_trace[i]不等于trace_bits[i]，代表发现了</span></span><br><span class="line"><span class="comment">                  可变testcase，且var_bytes为空，则将该字节设置为1</span></span><br><span class="line"><span class="comment">                *.将stage_max的值设置为CAL_CYCLES_LONG（CAL_CYCLES的值为40）</span></span><br><span class="line"><span class="comment">             2).如果q->exec_cksum值为0(说明是第一次执行)：</span></span><br><span class="line"><span class="comment">                *.设置q->exec_cksum的值为本次执行计算出来的cksum</span></span><br><span class="line"><span class="comment">                *.将trace_bits的内容直接复制到first_trace上             </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q->exec_cksum != cksum) {</span><br><span class="line"></span><br><span class="line">      hnb = has_new_bits(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb > new_bits)</span><br><span class="line">          new_bits = hnb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (q->exec_cksum) {</span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i < MAP_SIZE; i++) {</span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] && first_trace[i] != trace_bits[i]) {</span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">            stage_max    = CAL_CYCLES_LONG;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        var_detected = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        q->exec_cksum = cksum;</span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取退出循环后的时间，并计算评估过程中执行的时长和执行的总轮次 */</span>  </span><br><span class="line">  stop_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  total_cal_us     += stop_us - start_us;</span><br><span class="line">  total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 这部分主要是收集一些fuzzing执行时的统计信息：</span></span><br><span class="line"><span class="comment">     1.设置测试用例对应的queue的一些值，包括</span></span><br><span class="line"><span class="comment">        a.单次执行时间的平均值</span></span><br><span class="line"><span class="comment">        b.最后一次执行后所覆盖到的路径数</span></span><br><span class="line"><span class="comment">        c.执行轮数</span></span><br><span class="line"><span class="comment">        d.失败次数</span></span><br><span class="line"><span class="comment">     2.更新加上这个queue所覆盖到的路径数，以及用于计算路径的bitmap的个数加1</span></span><br><span class="line"><span class="comment">     3.调用update_bitmap_score，更新一些比如偏好因子的信息，包括进行对应的trace_bits压缩，</span></span><br><span class="line"><span class="comment">       以判断此判断此路径是否是更有利的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  q->exec_us     = (stop_us - start_us) / stage_max;</span><br><span class="line">  q->bitmap_size = count_bytes(trace_bits);</span><br><span class="line">  q->handicap    = handicap;</span><br><span class="line">  q->cal_failed  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size += q->bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  update_bitmap_score(q);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果没有从检测中得到new_bit，fault类型为FAULT_NONT，且该testcase是第一次执行，且不属于</span></span><br><span class="line"><span class="comment">     dumb_mode；则告诉父进程，这是一个无关紧要的问题，但是需要提醒用户。这里将错误类型设置为</span></span><br><span class="line"><span class="comment">     FAULT_NOBITS，交由处理perform_dry_run中的Switch语句进行处理 */</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode && first_run && !fault && !new_bits)</span><br><span class="line">      fault = FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果摁下Ctrl+C，或者遇到一些执行出错的情况，就会执行这里的abort_calibration，其主要工作如下：</span></span><br><span class="line"><span class="comment">     1.新路径出现的处理（has_new_bits的返回值如果为2，说明发现了新路径）</span></span><br><span class="line"><span class="comment">     2.测试用例造成可变路径的处理，这里会调用mark_as_variable，其操作如下：</span></span><br><span class="line"><span class="comment">        a.调用syslink创建符号链接out_dir/queue/.state/variable_behavior/fname</span></span><br><span class="line"><span class="comment">        b.设置q->var_behavior=1</span></span><br><span class="line"><span class="comment">     3.用先前保存的old_sn/sc/sm恢复stage_name/cur/max的值</span></span><br><span class="line"><span class="comment">     4.如果不是第一次执行，就打印一下状态栏</span></span><br><span class="line"><span class="comment">     5.最后返回错误类型</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> && !q->has_new_cov) {</span><br><span class="line">    q->has_new_cov = <span class="number">1</span>;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected) {</span><br><span class="line">    var_byte_count = count_bytes(var_bytes);</span><br><span class="line">    <span class="keyword">if</span> (!q->var_behavior) {</span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur  = old_sc;</span><br><span class="line">  stage_max  = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run) </span><br><span class="line">      show_stats();</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h3><p>理解这部分代码需要一些前置知识，包括<a href="https://blog.csdn.net/sweetfather/article/details/79457261" target="_blank" rel="noopener">Linux会话相关的系统调用</a>、<a href="https://zhuanlan.zhihu.com/p/58489873" target="_blank" rel="noopener">Linux管道通信的用法</a>以及<a href="https://www.cnblogs.com/GODYCA/archive/2013/01/05/2846197.html" target="_blank" rel="noopener">管道通信时涉及到dup/dup2函数的用法</a>。这里dup2的用法非常重要，因此作简单介绍（下面的说法源自《Unix环境高级编程》）：</p>
<h4 id="关于文件共享"><a href="#关于文件共享" class="headerlink" title="关于文件共享"></a>关于文件共享</h4><ol>
<li>每个进程在进程表中都有一个记录项，每个记录项中有一张打开文件描述符表，可将视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<ul>
<li>文件描述符标志</li>
<li>指向一个文件表项的指针</li>
</ul>
</li>
<li>内核为所有打开文件维持一张文件表。每个文件表项包含：<ul>
<li>文件状态标志(读、写、增写、同步、非阻塞等)</li>
<li>当前文件位移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
</li>
</ol>
<h4 id="dup-dup2的用途"><a href="#dup-dup2的用途" class="headerlink" title="dup/dup2的用途"></a>dup/dup2的用途</h4><p>系统调用dup和dup2能够复制文件描述符。dup返回新的文件文件描述符（没有用的文件描述符最小的编号）。<strong>dup2可以让用户指定返回的文件描述符的值</strong>，如果需要，则首先接近newfd的值，他<strong>通常用来重新打开或者重定向一个文件描述符</strong>。下面结合dup2与文件共享的关系，更好的理解dup2的用途。（图片来自<a href="https://www.cnblogs.com/GODYCA/archive/2013/01/05/2846197.html" target="_blank" rel="noopener">此文</a>）</p>
<a href="/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/dup_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/dup_1.png"></a>

<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Spin up fork server (instrumented mode only). </span></span><br><span class="line"><span class="comment">   In essence, the instrumentation allows us to skip execve(), and just keep</span></span><br><span class="line"><span class="comment">   cloning a stopped child. So, we just execute once, and then send commands</span></span><br><span class="line"><span class="comment">   through a pipe. The other part of this logic is in afl-as.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line">    </span><br><span class="line">  ACTF(<span class="string">"Spinning up the fork server..."</span>);    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 函数原型：int pipe(int pipefd[2]);  </span></span><br><span class="line"><span class="comment">     作用：创建一个可以用于进程间通信单项隧道。该方法将会创建出两个文件描述符，可以使用pipefd</span></span><br><span class="line"><span class="comment">          这个数组来引用这两个描述符进行文件操作。pipefd[0]是读方式打开，作为管道的读描述符。</span></span><br><span class="line"><span class="comment">          pipefd[1]是写方式打开，作为管道的写描述符。从管道写端写入的数据会被内核缓存直到有</span></span><br><span class="line"><span class="comment">          人从另一端读取为止。</span></span><br><span class="line"><span class="comment">     返回值：如果管道创建成功，返回0；如果出错返回-1</span></span><br><span class="line"><span class="comment">     源码含义：创建2个管道用于父子进程间通信，st_pipe用于传递状态，ctl_pipe用于传递命令</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe)) </span><br><span class="line">      PFATAL(<span class="string">"pipe() failed"</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 函数原型：pid_t fork(void);</span></span><br><span class="line"><span class="comment">     作用：通过复制调用它的进程来创建一个新进程</span></span><br><span class="line"><span class="comment">     返回值：如果是父进程，则返回值为子进程的PID；如果是子进程，则返回0</span></span><br><span class="line"><span class="comment">     源码含义：fork出一个子进程，根据返回值froksrv_pid来执行不同的代码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  forksrv_pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid < <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">"fork() failed"</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果当前进程为子进程，则进入if语句块继续执行 */</span>  </span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先是针对OpenBSD系统做的特殊处理，这部分可以忽略 */</span></span><br><span class="line">    <span class="keyword">if</span> (!getrlimit(RLIMIT_NOFILE, &r) && r.rlim_cur < FORKSRV_FD + <span class="number">2</span>) {</span><br><span class="line">      r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">      setrlimit(RLIMIT_NOFILE, &r); </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mem_limit) {</span><br><span class="line">      r.rlim_max = r.rlim_cur = ((<span class="keyword">rlim_t</span>)mem_limit) << <span class="number">20</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">      setrlimit(RLIMIT_AS, &r); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      setrlimit(RLIMIT_DATA, &r); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">    }</span><br><span class="line">    r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line">    setrlimit(RLIMIT_CORE, &r); </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 隔离进程并配置标准描述符。 如果指定了 out_file，则 stdin 为 /dev/null； 否则，将克隆 out_fd。</span></span><br><span class="line"><span class="comment">       从这里开始，为子进程将要进行的操作：</span></span><br><span class="line"><span class="comment">       1.调用setsid()创建新的会话，从而使子进程完全独立，脱离父进程控制。具体细节参考文末链接</span></span><br><span class="line"><span class="comment">       2.调用dup2重定向文件描述符1和2（在程序启动时，与流stdin、stdout、stderr关联的整数</span></span><br><span class="line"><span class="comment">         文件描述符分别是0、1、2）到dev_null_fd（定义为-1，指向/dev/null），即关闭子进程</span></span><br><span class="line"><span class="comment">         中的stdout和stderr，然后将其重定向到/dev/null中。相当于关闭了子进程的全部输出</span></span><br><span class="line"><span class="comment">       3.判断是否指定了out_file</span></span><br><span class="line"><span class="comment">          a.如果指定了out_file，就和第2步一样，调用dup2将子进程的stdin重定向到/dev/null</span></span><br><span class="line"><span class="comment">          b.如果没有指定，就先重定向到out_fd，再关闭out_fd，从而关闭stdin（out_file和</span></span><br><span class="line"><span class="comment">            out_fd指向的文件路径差不多，似乎都会被设置为out_dir/.cur_input）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">    dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_file) {</span><br><span class="line">      dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">close</span>(out_fd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 设置控制管道与状态管道，关闭不需要的原始文件描述符：</span></span><br><span class="line"><span class="comment">       1.通过调用dup2，分别重定向文件描述符FORKSRV_FD和FORKSRV_FD+1重定向到控制管道的读描述</span></span><br><span class="line"><span class="comment">         符与状态管道的写描述符；从而使得子进程只能读取控制管道中的命令，以及往状态管道中写入状态。</span></span><br><span class="line"><span class="comment">         这部分内容，我们在分析afl-as.h中的桩代码时已经提过，这里重定向的两个文件描述符刚好对应</span></span><br><span class="line"><span class="comment">         0xC6和0xC7，它们分别用来读取父进程发来的命令，以及将其自己的子进程fuzz返回的状态写入到</span></span><br><span class="line"><span class="comment">         状态管道中。</span></span><br><span class="line"><span class="comment">       2.接下来关闭子进程里一些不需要的文件描述符，在分析本函数之前已经简单解释过了dup2的原理，因</span></span><br><span class="line"><span class="comment">         此关闭这些文件描述符是不会影响到那些重定向到这些描述符的描述符</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"dup2() failed"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) < <span class="number">0</span>)</span><br><span class="line">        PFATAL(<span class="string">"dup2() failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(out_dir_fd);</span><br><span class="line">    <span class="built_in">close</span>(dev_null_fd);</span><br><span class="line">    <span class="built_in">close</span>(dev_urandom_fd);</span><br><span class="line">    <span class="built_in">close</span>(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 下面是一些琐碎的处理：</span></span><br><span class="line"><span class="comment">       1.若没设置环境变量LD_BIND_LAZY，则将环境变量LD_BIND_NOW设置为1；这么做能稍微</span></span><br><span class="line"><span class="comment">         提高性能，它会阻止链接器在fork之后做额外的工作 </span></span><br><span class="line"><span class="comment">       2.若没有特殊指定，接下来会通过环境变量ASAN_OPTIONS为ASAN设置合理的默认值</span></span><br><span class="line"><span class="comment">       3.类似的，为MSAN设置默认值</span></span><br><span class="line"><span class="comment">       4.调用execv执行目标二进制程序；除非执行出错，否则该函数不会返回。这里有一点很特殊，第一个</span></span><br><span class="line"><span class="comment">         target会进入__afl_maybe_log里的__afl_fork_wait_loop，并充当fork server，在整</span></span><br><span class="line"><span class="comment">         个fuzz的过程中，它都不会结束，每次要fuzz一次目标程序，都会从这个fork serve fork出来</span></span><br><span class="line"><span class="comment">         一个子进程（这个fork server本身也是init_forkserver里fork出来的子进程）去fuzz</span></span><br><span class="line"><span class="comment">       5.execv是不会返回的，如果执行到这里，说明execv执行失败了。这里使用一个独特的位图签名</span></span><br><span class="line"><span class="comment">         EXEC_FAIL_SIG（0xfee1dead）来告诉父进程execv()执行失败，并结束子进程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">"LD_BIND_LAZY"</span>)) </span><br><span class="line">        setenv(<span class="string">"LD_BIND_NOW"</span>, <span class="string">"1"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">"ASAN_OPTIONS"</span>, <span class="string">"abort_on_error=1:"</span></span><br><span class="line">                           <span class="string">"detect_leaks=0:"</span></span><br><span class="line">                           <span class="string">"symbolize=0:"</span></span><br><span class="line">                           <span class="string">"allocator_may_return_null=1"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">"MSAN_OPTIONS"</span>, <span class="string">"exit_code="</span> STRINGIFY(MSAN_ERROR) <span class="string">":"</span></span><br><span class="line">                           <span class="string">"symbolize=0:"</span></span><br><span class="line">                           <span class="string">"abort_on_error=1:"</span></span><br><span class="line">                           <span class="string">"allocator_may_return_null=1:"</span></span><br><span class="line">                           <span class="string">"msan_track_origins=0"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 以下为父进程进行的操作：</span></span><br><span class="line"><span class="comment">     1.关掉父进程不需要的控制管道的读描述符、状态管道的写描述符</span></span><br><span class="line"><span class="comment">     2.将控制管道的写描述符、状态管道的读描述符，分别赋值给对应的fork server全局变量</span></span><br><span class="line"><span class="comment">     3.设置等待fork server启动的时间，但是不能等待太久</span></span><br><span class="line"><span class="comment">     4.从fsrv_st_fd，也就状态管道中读取4个字节的状态信息。如果读取成功，则代表fork server</span></span><br><span class="line"><span class="comment">       成功启动，直接return</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">  setitimer(ITIMER_REAL, &it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  rlen = <span class="built_in">read</span>(fsrv_st_fd, &status, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">  setitimer(ITIMER_REAL, &it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) {</span><br><span class="line">    OKF(<span class="string">"All right - fork server is up."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 以下为进程启动失败、超时等异常情况的判断以及处理，主要的处理方式是给出提示并抛出异常。</span></span><br><span class="line"><span class="comment">     由于文章排版问题，这部分暂不阐述，可先参考hollk或初号机的分析文章 */</span>  </span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    FATAL(<span class="string">"Timeout while initializing fork server (adjusting -t may help)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, &status, <span class="number">0</span>) <= <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">"waitpid() failed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status)) {</span><br><span class="line">    <span class="keyword">if</span> (mem_limit && mem_limit < <span class="number">500</span> && uses_asan) {</span><br><span class="line">      SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">           <span class="string">"Whoops, the target binary crashed suddenly, before receiving any input\n"</span></span><br><span class="line">           <span class="string">"    from the fuzzer! Since it seems to be built with ASAN and you have a\n"</span></span><br><span class="line">           <span class="string">"    restrictive memory limit configured, this is expected; please read\n"</span></span><br><span class="line">           <span class="string">"    %s/notes_for_asan.txt for help.\n"</span>, doc_path);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) {</span><br><span class="line">      SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">           <span class="string">"Whoops, the target binary crashed suddenly, before receiving any input\n"</span></span><br><span class="line">           <span class="string">"    from the fuzzer! There are several probable explanations:\n\n"</span></span><br><span class="line">           <span class="string">"    - The binary is just buggy and explodes entirely on its own. If so, you\n"</span></span><br><span class="line">           <span class="string">"      need to fix the underlying problem or find a better replacement.\n\n"</span></span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">           <span class="string">"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"</span></span><br><span class="line">           <span class="string">"      break afl-fuzz performance optimizations when running platform-specific\n"</span></span><br><span class="line">           <span class="string">"      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"</span></span><br><span class="line">#endif <span class="comment">/* __APPLE__ */</span></span><br><span class="line"></span><br><span class="line">           <span class="string">"    - Less likely, there is a horrible bug in the fuzzer. If other options\n"</span></span><br><span class="line">           <span class="string">"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n"</lcamtuf@coredump.cx></span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">           <span class="string">"Whoops, the target binary crashed suddenly, before receiving any input\n"</span></span><br><span class="line">           <span class="string">"    from the fuzzer! There are several probable explanations:\n\n"</span></span><br><span class="line">           <span class="string">"    - The current memory limit (%s) is too restrictive, causing the\n"</span></span><br><span class="line">           <span class="string">"      target to hit an OOM condition in the dynamic linker. Try bumping up\n"</span></span><br><span class="line">           <span class="string">"      the limit with the -m setting in the command line. A simple way confirm\n"</span></span><br><span class="line">           <span class="string">"      this diagnosis would be:\n\n"</span></span><br><span class="line"></span><br><span class="line">#ifdef RLIMIT_AS</span><br><span class="line">           <span class="string">"      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">           <span class="string">"      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"</span></span><br><span class="line">#endif <span class="comment">/* ^RLIMIT_AS */</span></span><br><span class="line"></span><br><span class="line">           <span class="string">"      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"</span></span><br><span class="line">           <span class="string">"      estimate the required amount of virtual memory for the binary.\n\n"</span></span><br><span class="line">           <span class="string">"    - The binary is just buggy and explodes entirely on its own. If so, you\n"</span></span><br><span class="line">           <span class="string">"      need to fix the underlying problem or find a better replacement.\n\n"</span></span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line"></span><br><span class="line">           <span class="string">"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"</span></span><br><span class="line">           <span class="string">"      break afl-fuzz performance optimizations when running platform-specific\n"</span></span><br><span class="line">           <span class="string">"      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"</span></span><br><span class="line">#endif <span class="comment">/* __APPLE__ */</span></span><br><span class="line"></span><br><span class="line">           <span class="string">"    - Less likely, there is a horrible bug in the fuzzer. If other options\n"</span></span><br><span class="line">           <span class="string">"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n"</lcamtuf@coredump.cx></span>,</span><br><span class="line">           DMS(mem_limit << <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    FATAL(<span class="string">"Fork server crashed with signal %d"</span>, WTERMSIG(status));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*(u32*)trace_bits == EXEC_FAIL_SIG)</span><br><span class="line">    FATAL(<span class="string">"Unable to execute target application ('%s')"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem_limit && mem_limit < <span class="number">500</span> && uses_asan) {</span><br><span class="line">    SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">           <span class="string">"Hmm, looks like the target binary terminated before we could complete a\n"</span></span><br><span class="line">           <span class="string">"    handshake with the injected code. Since it seems to be built with ASAN and\n"</span></span><br><span class="line">           <span class="string">"    you have a restrictive memory limit configured, this is expected; please\n"</span></span><br><span class="line">           <span class="string">"    read %s/notes_for_asan.txt for help.\n"</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) {</span><br><span class="line">    SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">         <span class="string">"Hmm, looks like the target binary terminated before we could complete a\n"</span></span><br><span class="line">         <span class="string">"    handshake with the injected code. Perhaps there is a horrible bug in the\n"</span></span><br><span class="line">         <span class="string">"    fuzzer. Poke <lcamtuf@coredump.cx> for troubleshooting tips.\n"</lcamtuf@coredump.cx></span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    SAYF(<span class="string">"\n"</span> cLRD <span class="string">"[-] "</span> cRST</span><br><span class="line">         <span class="string">"Hmm, looks like the target binary terminated before we could complete a\n"</span></span><br><span class="line">         <span class="string">"    handshake with the injected code. There are %s probable explanations:\n\n"</span></span><br><span class="line">         <span class="string">"%s"</span></span><br><span class="line">         <span class="string">"    - The current memory limit (%s) is too restrictive, causing an OOM\n"</span></span><br><span class="line">         <span class="string">"      fault in the dynamic linker. This can be fixed with the -m option. A\n"</span></span><br><span class="line">         <span class="string">"      simple way to confirm the diagnosis may be:\n\n"</span></span><br><span class="line">         </span><br><span class="line">#ifdef RLIMIT_AS</span><br><span class="line">         <span class="string">"      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">         <span class="string">"      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"</span></span><br><span class="line">#endif <span class="comment">/* ^RLIMIT_AS */</span></span><br><span class="line">         </span><br><span class="line">         <span class="string">"      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"</span></span><br><span class="line">         <span class="string">"      estimate the required amount of virtual memory for the binary.\n\n"</span></span><br><span class="line">         <span class="string">"    - Less likely, there is a horrible bug in the fuzzer. If other options\n"</span></span><br><span class="line">         <span class="string">"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n"</lcamtuf@coredump.cx></span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ? <span class="string">"three"</span> : <span class="string">"two"</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ?</span><br><span class="line">         <span class="string">"    - You are using deferred forkserver, but __AFL_INIT() is never\n"</span></span><br><span class="line">         <span class="string">"      reached before the program terminates.\n\n"</span> : <span class="string">""</span>,</span><br><span class="line">         DMS(mem_limit << <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line">  FATAL(<span class="string">"Fork server handshake failed"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><p>根据上述对<code>init_forkserver</code>的分析，结合<a href="https://cata1oc.github.io/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/">前一篇</a>中对桩代码的分析，可以梳理出如下流程：（图片出自<a href="https://hicookie.me/2019/09/18/AFL-Learning/" target="_blank" rel="noopener">此处</a>）</p>
<a href="/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/init_forkserver_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/init_forkserver_1.png"></a>

<ol>
<li>afl-fuzz会创建两个管道（控制管道、状态管道），并在<code>init_forkserver</code>中fork出一个子进程</li>
<li>在子进程中调用<code>execv</code>执行afl-gcc编译出来的、已经被插桩的目标程序</li>
<li>由于已被插桩，目标程序的控制流会交到<code>__afl_maybe_log</code>手中</li>
<li><strong>如果fuzz是第一次运行，此时的子进程便成为了fuzz server。</strong>它会将状态写入状态管道（st_pipe），通知父进程准备ok。父进程会从状态管道中读取子进程的状态，从而知道fork server已经启动</li>
<li>之后进行fuzz时：<ol>
<li>子进程（fork server）会在<code>__afl_fork_wait_loop</code>等待父进程的指令</li>
<li>父进程会将fork指令写入控制管道（ctl_pipe）</li>
<li>子进程（fork server）会从控制管道中读取命令，并fork出一个它的子进程用于fuzz，并将它的子进程的结束状态通过写入状态管道，告知父进程</li>
</ol>
</li>
<li>上述进程间的关系可以参考下图</li>
</ol>
<a href="/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/init_forkserver_2.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/init_forkserver_2.png"></a>



<h3 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits"></a>has_new_bits</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在先前分析calibrate_case时经常遇到has_new_bits，在该函数内它的调用方式大致为：</span></span><br><span class="line"><span class="comment">   hnb = has_new_bits(virgin_bits);</span></span><br><span class="line"><span class="comment">   1.virgin_bits记录着整体tuple信息</span></span><br><span class="line"><span class="comment">   2.hub接收返回值并设置局部变量new_bits，然后通过new_bits的值判断是否发现了新的路径。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   这个函数主要是检查当前执行路径是否为表带来了任何新内容，通过对virgin_bits的更新来表现</span></span><br><span class="line"><span class="comment">   出这一点。如果发现了新的tuple，那么该函数将返回2；如果只是特定tuple的命中数增加，那么</span></span><br><span class="line"><span class="comment">   该函数将返回1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8* virgin_map)</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.根据系统位数，初始化变量current、virgin、i，并将ret置0</span></span><br><span class="line"><span class="comment">   2.这里的"MAP_SIZE>>3"即"MAP_SIZE/8"表示8个字节一组</span></span><br><span class="line"><span class="comment">   3.下面的"MAP_SIZE>>4"同理，本篇按照64位的角度来分析 </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  u64* current = (u64*)trace_bits;</span><br><span class="line">  u64* virgin  = (u64*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE >> <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  u32* current = (u32*)trace_bits;</span><br><span class="line">  u32* virgin  = (u32*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE >> <span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  u8   ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*  每次从current(trace_bits)和virgin(virgin_map)中取8个字节进行比较：</span></span><br><span class="line"><span class="comment">      1.如果current不为0（发现了新的路径）并且"*current&*virgin"也不为0（发现某条路径的执行次数</span></span><br><span class="line"><span class="comment">        和之前有所不同）：</span></span><br><span class="line"><span class="comment">         a.如果ret的值小于2：</span></span><br><span class="line"><span class="comment">            1).先将cur和vir分别指向current和virgin的第一个字节</span></span><br><span class="line"><span class="comment">            2).依次判断cur与vir开始的8个字节，是否满足：</span></span><br><span class="line"><span class="comment">               a).vir[i]==0xff，即之前从未被覆盖到（virgin_bits位图会初始为0xff）</span></span><br><span class="line"><span class="comment">               b).cur[i]存在，即trace_bits中对应的字节被命中</span></span><br><span class="line"><span class="comment">               如果这8组校验中，有任何1组满足上述条件，说明覆盖到了新的路径，将ret设置</span></span><br><span class="line"><span class="comment">               位2；否则说明只是某个tuple的命中次数的更新，将ret设置为1</span></span><br><span class="line"><span class="comment">         b.设置*virgin &= ~*current，这样做下次进行*current&*virgin时，就可以筛选出重复命中了</span></span><br><span class="line"><span class="comment">      2.current和virgin移动到下一组8个字节</span></span><br><span class="line"><span class="comment">      3.回到循环开始，直到MAPSIZE全被遍历完</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (i--) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*current) && unlikely(*current & *virgin)) {</span><br><span class="line">      <span class="keyword">if</span> (likely(ret < <span class="number">2</span>)) {</span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] && vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] && vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] && vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] && vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] && vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] && vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] && vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] && vir[<span class="number">7</span>] == <span class="number">0xff</span>)) </span><br><span class="line">            ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] && vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] && vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] && vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] && vir[<span class="number">3</span>] == <span class="number">0xff</span>)) </span><br><span class="line">            ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">      }</span><br><span class="line">      *virgin &= ~*current;</span><br><span class="line">    }</span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.如果传入给has_new_bits的参数virgin_map是virgin_bits（其它情况可能是virgin_tmout</span></span><br><span class="line"><span class="comment">       或者virgin_crash），并且ret的值不为0，说明发现新的路径或者某条路径的执行次数增加：</span></span><br><span class="line"><span class="comment">     2.那么就修改bitmap_changed的值为1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (ret && virgin_map == virgin_bits)</span><br><span class="line">      bitmap_changed = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>





<h3 id="count-bytes"><a href="#count-bytes" class="headerlink" title="count_bytes"></a>count_bytes</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* (_b) << 3 即 _b*8 </span></span><br><span class="line"><span class="comment">   FF(_b) 即 0x000000ff 左移 _b*8 位</span></span><br><span class="line"><span class="comment">   这里_b的取值范围为0、1、2、3，</span></span><br><span class="line"><span class="comment">   则最终结果取值范围为0xff000000、0x00ff0000、0x0000ff00、0x000000ff</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF(_b)  (0xff << ((_b) << 3))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 本函数用于计算bitmap中设置的字节数，主要是为了更新状态界面、样例评估、检测确认新路径：</span></span><br><span class="line"><span class="comment">   1.循环读取mem中的值，每次读取4个字节到变量v中</span></span><br><span class="line"><span class="comment">   2.初始化计算器ret的值为0</span></span><br><span class="line"><span class="comment">   3.依次将v与0xff000000、0x00ff0000、0x0000ff00、0x000000ff进行与操作 若结果不</span></span><br><span class="line"><span class="comment">     为0，则计数器ret加1.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">count_bytes</span><span class="params">(u8* mem)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u32* ptr = (u32*)mem;</span><br><span class="line">  u32  i   = (MAP_SIZE >> <span class="number">2</span>);</span><br><span class="line">  u32  ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) {</span><br><span class="line">    u32 v = *(ptr++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (v & FF(<span class="number">0</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v & FF(<span class="number">1</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v & FF(<span class="number">2</span>)) ret++;</span><br><span class="line">    <span class="keyword">if</span> (v & FF(<span class="number">3</span>)) ret++;</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="run-target"><a href="#run-target" class="headerlink" title="run_target"></a>run_target</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数调用目标程序，监控出现超时的情况，并返回状态信息。被调用的程序会更新路径表trace_bits */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span>** argv, u32 timeout)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">static</span> u32 prev_timed_out = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> u64 exec_ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">  u32 tb4;</span><br><span class="line"></span><br><span class="line">  child_timed_out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 首先调用memset将trace_bits清零。</span></span><br><span class="line"><span class="comment">     要注意的一点是，在这个memset之后，trace_bits[]实际上是不稳定的，所以我们必须防止任何早期</span></span><br><span class="line"><span class="comment">     的操作冒险进入这个领域。这里调用了MEM_BARRIER()，在types.h中可以看到其被定义为如下的宏：</span></span><br><span class="line"><span class="comment">     #define MEM_BARRIER() __asm__ volatile("" ::: "memory")</span></span><br><span class="line"><span class="comment">     volatile表明某个变量的值在外部可能被改变，因此对这些变量的存取不能缓存到寄存器，每次使用都</span></span><br><span class="line"><span class="comment">     要重新存取</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果在dumb_mode模式下允许，我们不能依赖编译到目标程序中的fork server逻辑，因此我们将要</span></span><br><span class="line"><span class="comment">     继续调用execve()，这部分和init_forkserver()中的代码有一些重复，but c'est la vie</span></span><br><span class="line"><span class="comment">     这里对重复的代码仅作简要注释，完整的可以参考上方的init_forkserver()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) {</span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"fork() failed"</span>);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 通过该if语句进入子进程的处理逻辑流程 */</span></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) {</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* 首先仍然是针对OpenBSD系统做的一些特殊处理，可以忽略 */</span>  </span><br><span class="line">      <span class="keyword">if</span> (mem_limit) {</span><br><span class="line">        r.rlim_max = r.rlim_cur = ((<span class="keyword">rlim_t</span>)mem_limit) << <span class="number">20</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">        setrlimit(RLIMIT_AS, &r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        setrlimit(RLIMIT_DATA, &r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">      }</span><br><span class="line">      r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line">      setrlimit(RLIMIT_CORE, &r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. </span></span><br><span class="line"><span class="comment">         1.调用setsid()创建新的会话，脱离父进程控制</span></span><br><span class="line"><span class="comment">         2.重定向stdout/stderr到dev_null_fd，从而关闭子进程的全部输出</span></span><br><span class="line"><span class="comment">         3.如果指定了out_file，则重定向stdin搭配dev_null_fd；如果没指定，就重定向到out_fd，</span></span><br><span class="line"><span class="comment">           再关闭out_fd描述符（out_file和out_fd指向的文件路径差不多）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      setsid();</span><br><span class="line"></span><br><span class="line">      dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">      dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file) {</span><br><span class="line">        dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">close</span>(out_fd);</span><br><span class="line">      }</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* 关闭子进程里一些不需要的文件描述符 */</span></span><br><span class="line">      <span class="built_in">close</span>(dev_null_fd);</span><br><span class="line">      <span class="built_in">close</span>(out_dir_fd);</span><br><span class="line">      <span class="built_in">close</span>(dev_urandom_fd);</span><br><span class="line">      <span class="built_in">close</span>(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* 1.若没有特殊指定，则通过环境变量为ASAN和MASN设置合理的默认值</span></span><br><span class="line"><span class="comment">         2.调用execv执行目标二进制程序；除非执行出错，否则该函数不会返回</span></span><br><span class="line"><span class="comment">         3.若execv执行失败，则用一个独特的位图签名EXEC_FAIL_SIG（0xfee1dead）来告诉父进程</span></span><br><span class="line"><span class="comment">           execv()执行失败，并结束子进程</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      setenv(<span class="string">"ASAN_OPTIONS"</span>, <span class="string">"abort_on_error=1:"</span></span><br><span class="line">                             <span class="string">"detect_leaks=0:"</span></span><br><span class="line">                             <span class="string">"symbolize=0:"</span></span><br><span class="line">                             <span class="string">"allocator_may_return_null=1"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">"MSAN_OPTIONS"</span>, <span class="string">"exit_code="</span> STRINGIFY(MSAN_ERROR) <span class="string">":"</span></span><br><span class="line">                             <span class="string">"symbolize=0:"</span></span><br><span class="line">                             <span class="string">"msan_track_origins=0"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">      *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">  }    </span><br><span class="line">  <span class="comment">/* 与init_forkserver中重复的部分至此结束 */</span>  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果dumb_mode不等于1，且已经启动并运行了fork server，那么进行如下流程：</span></span><br><span class="line"><span class="comment">     1.向控制管道写入prev_timed_out的值，命令fork server开始fork一个子进程进行fuzz</span></span><br><span class="line"><span class="comment">     2.从状态管道读取fork server返回的fork出的子进程的PID到child_pid中</span></span><br><span class="line"><span class="comment">     3.检查child_pid的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = <span class="built_in">write</span>(fsrv_ctl_fd, &prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) {</span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">"Unable to request new process from fork server (OOM?)"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = <span class="built_in">read</span>(fsrv_st_fd, &child_pid, <span class="number">4</span>)) != <span class="number">4</span>) {</span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">"Unable to request new process from fork server (OOM?)"</span>);</span><br><span class="line">    }</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (child_pid <= <span class="number">0</span>) </span><br><span class="line">        FATAL(<span class="string">"Fork server is misbehaving (OOM?)"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 1.根据用户的配置，调用setitimer设置超时时间。ITIMER_REAL按实际时间计时，计时到达将给进程</span></span><br><span class="line"><span class="comment">       发送SIGALRM信号（参考文末链接16）。先前的setup_signal_handlers已将SIGALRM信号的处</span></span><br><span class="line"><span class="comment">       理函数设置为handle_timeout，它将杀死子进程，并设置全局变量child_timed_out</span></span><br><span class="line"><span class="comment">     2.判断是否为dumb_mode，或无fork server的模式（以子进程的方式execve）</span></span><br><span class="line"><span class="comment">        a.如果是，则等待子进程结束返回的status</span></span><br><span class="line"><span class="comment">        b.如果不是，则从状态管道中读取fork server返回的status</span></span><br><span class="line"><span class="comment">     3.计算执行时间exec_ms</span></span><br><span class="line"><span class="comment">     4.重置timer</span></span><br><span class="line"><span class="comment">     5.execve()调用次数计数器，total_execs的值加1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  it.it_value.tv_sec = (timeout / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">  setitimer(ITIMER_REAL, &it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) {</span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &status, <span class="number">0</span>) <= <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"waitpid() failed"</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    s32 res;</span><br><span class="line">    <span class="keyword">if</span> ((res = <span class="built_in">read</span>(fsrv_st_fd, &status, <span class="number">4</span>)) != <span class="number">4</span>) {</span><br><span class="line">      <span class="keyword">if</span> (stop_soon)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">"Unable to communicate with fork server (OOM?)"</span>);  </span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!WIFSTOPPED(status)) </span><br><span class="line">      child_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  getitimer(ITIMER_REAL, &it);</span><br><span class="line">  exec_ms = (u64) timeout - (it.it_value.tv_sec * <span class="number">1000</span> +</span><br><span class="line">                             it.it_value.tv_usec / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">  setitimer(ITIMER_REAL, &it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  total_execs++;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 编译器不允许将trace_bits上的任何后续操作移至此处之后。</span></span><br><span class="line"><span class="comment">     越过这个位置，trace_bits的行为非常正常，不必被视为volatile */</span></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 1.将trace_bits前4字节的值赋值给局部变量tb4，用于后面检查处于dumb_mode或无fork server</span></span><br><span class="line"><span class="comment">       的模式时，子进程的execv()是否执行成功</span></span><br><span class="line"><span class="comment">     2.调用classify_counts对trace_bits的值进行规整</span></span><br><span class="line"><span class="comment">     3.用prev_timed_out保存child_timed_out的值</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  tb4 = *(u32*)trace_bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  classify_counts((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  classify_counts((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  prev_timed_out = child_timed_out;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 以下涉及到的处理进程退出状态的宏可以参考文末链接[17].</span></span><br><span class="line"><span class="comment">     1.调用WIFSIGNALED()判断子进程是否因为异常而结束，如果是，该函数返回真；并且不是因为</span></span><br><span class="line"><span class="comment">       !stop_soon（按下Ctrl+C）而结束子进程；则接下来调用WTERMSIG()获取导致子进程终止</span></span><br><span class="line"><span class="comment">       的信号，以判断异常退出的原因：</span></span><br><span class="line"><span class="comment">       a.如果终止信号为SIGKILL，并且child_timed_out被设置，则返回FAULT_TMOUT</span></span><br><span class="line"><span class="comment">       b.否则返回FAULT_CRASH</span></span><br><span class="line"><span class="comment">     2.如果设置了uses_asan，并且子进程异常退出时返回的错误码为MASN_ERROR，则将kill_signal</span></span><br><span class="line"><span class="comment">       置0，并返回FAULT_CRASH</span></span><br><span class="line"><span class="comment">     3.如果处于dumb_mode或无fork server的模式，并且trace_bits被设置为EXEC_FAIL_SIG，</span></span><br><span class="line"><span class="comment">       则返回FAULT_ERROR</span></span><br><span class="line"><span class="comment">     4.如果测试用例在用户定义的超时时间下（timeout），执行时间超过设置的最慢的执行时间，则</span></span><br><span class="line"><span class="comment">       重新设置最慢的执行时间，这里不返回</span></span><br><span class="line"><span class="comment">     5.如果执行到这仍未返回，则返回FAULT_NONE</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) && !stop_soon) {</span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line">    <span class="keyword">if</span> (child_timed_out && kill_signal == SIGKILL)</span><br><span class="line">        <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uses_asan && WEXITSTATUS(status) == MSAN_ERROR) {</span><br><span class="line">    kill_signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dumb_mode == <span class="number">1</span> || no_forkserver) && tb4 == EXEC_FAIL_SIG)</span><br><span class="line">    <span class="keyword">return</span> FAULT_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(timeout > exec_tmout) && (slowest_exec_ms < exec_ms)) {</span><br><span class="line">    slowest_exec_ms = exec_ms;</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> FAULT_NONE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="classify-count"><a href="#classify-count" class="headerlink" title="classify_count"></a>classify_count</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* classify_counts只出现了run_target中，被用作对trace_bits进程规整，这里我们只关心64位的版本 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">classify_counts</span><span class="params">(u64* mem)</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 1.每次从mem(trace_bits)读8个字节，一共i组</span></span><br><span class="line"><span class="comment">      2.判断每组的mem是否为空，为空就扫描下一组，不为空，就对这个组的内容进行规整</span></span><br><span class="line"><span class="comment">      3.每组的mem16[0]~mem16[3]，每个都是2字节，依次从count_class_lookup16中找到对应的</span></span><br><span class="line"><span class="comment">        count_class_lookup16[mem16[i]]并写入回mem16[i]。对count_class_lookup16这</span></span><br><span class="line"><span class="comment">        张表的初始化可以参考前文分析的init_count_class16</span></span><br><span class="line"><span class="comment">      4.规整完以后继续扫描下一组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  u32 i = MAP_SIZE >> <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (i--) {</span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) {</span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">      mem16[<span class="number">2</span>] = count_class_lookup16[mem16[<span class="number">2</span>]];</span><br><span class="line">      mem16[<span class="number">3</span>] = count_class_lookup16[mem16[<span class="number">3</span>]];</span><br><span class="line">    }</span><br><span class="line">    mem++;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数只在"calibrate_case"和"trim_case"中被调用 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   当我们遇到一条新路径时，调用它以查看该路径是否比任何现有路径看起来更"有利"。达到这个"有利条件"</span></span><br><span class="line"><span class="comment">   的标准是有一组最小的路径来触发，到目前位置在位图中看到的所有位。接下来，专注于这些"有利"路径进</span></span><br><span class="line"><span class="comment">   行模糊测试，忽略其他的。</span></span><br><span class="line"><span class="comment">   该过程的第一步是维护位图中每个字节的top_rated[]条目列表。如果没有先前的竞争者，或者如果当前</span></span><br><span class="line"><span class="comment">   竞争者有更"有利"的偏好因子(速度*大小)，则可以赢得该位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_bitmap_score</span><span class="params">(struct queue_entry* q)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 先计算出当前queue的偏好因子fav_factor，然后进入循环开始筛选</span></span><br><span class="line"><span class="comment">     循环会检查trace_bits的每个字节，查看是否有先前的胜者，然后将它的偏好因子与当前的queue对比</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q->exec_us * q->len;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < MAP_SIZE; i++)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 1.首先确保trace_bits[i]处有值，即命中该路径</span></span><br><span class="line"><span class="comment">       2.判断top_rated[i]处是否有值，即是否有先前的胜者：</span></span><br><span class="line"><span class="comment">          a.如果有则用当前queue的偏好因子fav_factor，与top_rated[i]算出的偏好因子比对。</span></span><br><span class="line"><span class="comment">            执行更快会更小测试用例会胜出。若是top_rateed[i]胜出，则回到循环开头，继续比对</span></span><br><span class="line"><span class="comment">            当前queue命中的下一个路径；若是当前queue胜出，则继续执行</span></span><br><span class="line"><span class="comment">          b.如果执行到这，说明当前queue要赢了，这里把输家的"top_rated[i]->tc_ref"减一，</span></span><br><span class="line"><span class="comment">            把"top_rated[i]->trace_mini"清空</span></span><br><span class="line"><span class="comment">       3.把当前queue插入top_rated[i]中作为新的胜者，并令q->tc_ref加1</span></span><br><span class="line"><span class="comment">       4.如果q->trace_mini为空，则申请MAP_SIZE>>3大小的空间，然后则将trace_bits经过</span></span><br><span class="line"><span class="comment">         minimize_bits压缩后存到trace_mini中</span></span><br><span class="line"><span class="comment">       5.设置score_changed的值为1，表明胜者发生了变化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) {</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) {</span><br><span class="line">         <span class="keyword">if</span> (fav_factor > top_rated[i]->exec_us * top_rated[i]->len) </span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]->tc_ref) {</span><br><span class="line">           ck_free(top_rated[i]->trace_mini);</span><br><span class="line">           top_rated[i]->trace_mini = <span class="number">0</span>;</span><br><span class="line">         }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       top_rated[i] = q;</span><br><span class="line">       q->tc_ref++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!q->trace_mini) {</span><br><span class="line">         q->trace_mini = ck_alloc(MAP_SIZE >> <span class="number">3</span>);</span><br><span class="line">         minimize_bits(q->trace_mini, trace_bits);</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="minimize-bits"><a href="#minimize-bits" class="headerlink" title="minimize_bits"></a>minimize_bits</h3><p>在阅读这部分代码之前，建议先参考一下<a href="https://blog.csdn.net/lxlmycsdnfree/article/details/78926359" target="_blank" rel="noopener">此文</a>对数据压缩算法的介绍，非常优雅。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 场景：仅在update_bitmap_score中被调用，将trace_bits压缩到大小只有其1/8的trace_mini中</span></span><br><span class="line"><span class="comment">   作用：将trace_bits数组压缩成更小的位图。由于压缩后仅使用1比特存储路径，因此经过压缩后计数信</span></span><br><span class="line"><span class="comment">        息将被删除。当然，这只在发现新路径时才进行调用，并不频繁</span></span><br><span class="line"><span class="comment">   算法：1.进入循环，共MAP_SIZE轮</span></span><br><span class="line"><span class="comment">        2.*(src++)用来取trace_bits数组中元素的值，取完后自增1，到下一个元素的位置</span></span><br><span class="line"><span class="comment">        3.判断*(src++)处是否有值，若有值，则进行如下操作：</span></span><br><span class="line"><span class="comment">           a.i>>3，即i在trace_mini中的索引号，换句话说，就是在trace_mini中的第几个字节上</span></span><br><span class="line"><span class="comment">           b.i&7相当于i%8，只保留低3bits，即trace_mini中的第几个字节上的第几个bit的位置</span></span><br><span class="line"><span class="comment">           c.将1左移i%8个比特后，再和以前的数据做|运算，这样，它所在的这个bit 位置就替换成1了</span></span><br><span class="line"><span class="comment">        4.若没有值，或已完成上述操作，则进入下轮循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minimize_bits</span><span class="params">(u8* dst, u8* src)</span> </span>{</span><br><span class="line">    </span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i < MAP_SIZE) {</span><br><span class="line">    <span class="keyword">if</span> (*(src++)) </span><br><span class="line">        dst[i >> <span class="number">3</span>] |= <span class="number">1</span> << (i & <span class="number">7</span>);</span><br><span class="line">    i++;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 遍历top_rated[]条目，然后按顺序抓取先前未见过、并且在这一轮成为获胜者的字节（temp_v），</span></span><br><span class="line"><span class="comment">   在下一轮运行前，将它们标记为"有利"的。在所有模糊测试的步骤中，这些"有利"的条目有着更多的</span></span><br><span class="line"><span class="comment">   播出时间（air time）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cull_queue</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.如果处于dumb_mode或者score_changed为0（即没有新的胜者进入top_rated），就直接返回 </span></span><br><span class="line"><span class="comment">     2.将score_changed置0</span></span><br><span class="line"><span class="comment">     3.将temp_v数组（大小为MAP_SIZE/8）的每个字节设置为0xff。这里和前面minimize_bits的思</span></span><br><span class="line"><span class="comment">       路是一样的。将用字节表示的路径压缩到temp_v数组上的每个bit上。这里用0xff先将所有bit置1</span></span><br><span class="line"><span class="comment">       ，后面若发现被覆盖到，则用0替换</span></span><br><span class="line"><span class="comment">     4.初始化queue_favored和pending_favored为0</span></span><br><span class="line"><span class="comment">     5.遍历fuzzing queue链表，将q->favored均设置为0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span>;</span></span><br><span class="line">  <span class="keyword">static</span> u8 temp_v[MAP_SIZE >> <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE >> <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line">  <span class="keyword">while</span> (q) {</span><br><span class="line">    q->favored = <span class="number">0</span>;</span><br><span class="line">    q = q->next;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let's see if anything in the bitmap isn't captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let's use it. </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     这个迭代的目的就是筛选出一组queue，它们能够覆盖到所有现在已经覆盖到的路径</span></span><br><span class="line"><span class="comment">     1.遍历top_rated，判断top_rated[i]对应在temp_v上的bit有没有置位</span></span><br><span class="line"><span class="comment">     2.如果top_rated[i]有值，且该path在temp_v中对应的bit被置位</span></span><br><span class="line"><span class="comment">        a.就从temp_v中清除掉（也可以理解为标记出，置0后，其它case有着相同路径的情况下，就不会通过</span></span><br><span class="line"><span class="comment">          这个if筛选了）所有top_rated[i]覆盖到的path，将对应的bit置为0</span></span><br><span class="line"><span class="comment">        b.然后将top_rated[i]->favored置1，计数器queued_favored加1</span></span><br><span class="line"><span class="comment">        c.如果top_rated[i]还没有被fuzz过，则令计数器pending_favored加1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] && (temp_v[i >> <span class="number">3</span>] & (<span class="number">1</span> << (i & <span class="number">7</span>)))) {</span><br><span class="line">      u32 j = MAP_SIZE >> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]->trace_mini[j])</span><br><span class="line">          temp_v[j] &= ~top_rated[i]->trace_mini[j];</span><br><span class="line"></span><br><span class="line">      top_rated[i]->favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]->was_fuzzed) </span><br><span class="line">          pending_favored++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 遍历所有的fuzzing queue链表，调用mark_as_redundant筛选掉不是favored的queue，</span></span><br><span class="line"><span class="comment">     也就是说，如果不是favored的case，就被标记为redundant_edges */</span></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line">  <span class="keyword">while</span> (q) {</span><br><span class="line">    mark_as_redundant(q, !q->favored);</span><br><span class="line">    q = q->next;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>为了更好的理解该过程，这里选择网上公开的一个例子进行讲解（这部分取自<a href="https://paper.seebug.org/1732" target="_blank" rel="noopener">此文</a>）</p>
<p>现假设有如下tuple和seed信息：</p>
<ul>
<li><strong>tuple</strong>: t0, t1, t2, t3, t4</li>
<li><strong>seed</strong>: s0, s1, s2</li>
<li>初始化<code>temp_v = [1,1,1,1,1]</code></li>
<li>s1可覆盖t2, t3，s2覆盖t0, t1, t4，并且top_rated[0] = s2，top_rated[2]=s1</li>
</ul>
<p>将按照如下过程进行筛选和判断：</p>
<ol>
<li>首先判断 temp_v[0]=1，说明t0没有被覆盖；</li>
<li>top_rated[0] 存在 (s2) -> 判断s2可以覆盖的范围 -> <code>trace_mini = [1,1,0,0,1]</code>；</li>
<li>更新 <code>temp_v=[0,0,1,1,0]</code>， 标记s2为 “favored”；</li>
<li>继续判断 temp_v[1]=0，说明t1此时已经被覆盖，跳过；</li>
<li>继续判断 temp_v[2]=1，说明t2没有被覆盖；</li>
<li>top_rated[2] 存在 (s1) -> 判断s1可以覆盖的范围 -> <code>trace_mini=[0,0,1,1,0]</code>；</li>
<li>更新 <code>temp_v=[0,0,0,0,0]</code>，标记s1为 “favored”；</li>
<li>此时所有tuple都被覆盖，具备”favored’标记的为s1, s2，过程结束。</li>
</ol>
<h3 id="mark-as-reduntant"><a href="#mark-as-reduntant" class="headerlink" title="mark_as_reduntant"></a>mark_as_reduntant</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标记/取消标记是否为冗余(仅针对边)。这么做不是用于恢复状态，但可能对后处理数据集有用 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_as_redundant</span><span class="params">(struct queue_entry* q, u8 state)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u8* fn;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.如果state==q->fs_redundant，就直接返回</span></span><br><span class="line"><span class="comment">     2.用state(!q->favored)设置q->fs_redundant的值</span></span><br><span class="line"><span class="comment">     3.找到q->fname字符串最后一个'/'出现的位置</span></span><br><span class="line"><span class="comment">     4.将q->fname最后一个'/'后面的字符串拼接成"out_dir/queue/.state/redundant_edges/fname"</span></span><br><span class="line"><span class="comment">       并赋值给fn</span></span><br><span class="line"><span class="comment">     5.如果state为1，则创建文件out_dir/queue/.state/redundant_edges/fname</span></span><br><span class="line"><span class="comment">     6.如果state为0，则删除文件out_dir/queue/.state/redundant_edges/fname</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (state == q->fs_redundant) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  q->fs_redundant = state;</span><br><span class="line"></span><br><span class="line">  fn = <span class="built_in">strrchr</span>(q->fname, <span class="string">'/'</span>);</span><br><span class="line">  fn = alloc_printf(<span class="string">"%s/queue/.state/redundant_edges/%s"</span>, out_dir, fn + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state) {</span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"Unable to create '%s'"</span>, fn);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">      </span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (unlink(fn))</span><br><span class="line">        PFATAL(<span class="string">"Unable to remove '%s'"</span>, fn);</span><br><span class="line">  }</span><br><span class="line">  ck_free(fn);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在处理输入目录结束时（一些校准的东西也在这里结束了），显示快速统计信息，以及一堆警告 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show_init_stats</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> = <span class="title">queue</span>;</span></span><br><span class="line">  u32 min_bits = <span class="number">0</span>, max_bits = <span class="number">0</span>;</span><br><span class="line">  u64 min_us = <span class="number">0</span>, max_us = <span class="number">0</span>;</span><br><span class="line">  u64 avg_us = <span class="number">0</span>;</span><br><span class="line">  u32 max_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里根据calibrate_case中计算出来的total_cal_us和total_cal_cycles，计算出单轮执行的</span></span><br><span class="line"><span class="comment">     时间arv_us */</span></span><br><span class="line">  <span class="keyword">if</span> (total_cal_cycles) </span><br><span class="line">      avg_us = total_cal_us / total_cal_cycles;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) {</span><br><span class="line">    <span class="keyword">if</span> (!min_us || q->exec_us < min_us) min_us = q->exec_us;</span><br><span class="line">    <span class="keyword">if</span> (q->exec_us > max_us) max_us = q->exec_us;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!min_bits || q->bitmap_size < min_bits) min_bits = q->bitmap_size;</span><br><span class="line">    <span class="keyword">if</span> (q->bitmap_size > max_bits) max_bits = q->bitmap_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q->len > max_len) max_len = q->len;</span><br><span class="line"></span><br><span class="line">    q = q->next;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断avg_us的值，如果大于10000，就抛出警告"The target binary is pretty slow!"</span></span><br><span class="line"><span class="comment">     1.如果avg_us大于50000，设置havoc_div为10</span></span><br><span class="line"><span class="comment">     2.如果avg_us大于20000，设置havoc_div为5</span></span><br><span class="line"><span class="comment">     3.如果avg_us大于10000，设置havoc_div为2</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (avg_us > (qemu_mode ? <span class="number">50000</span> : <span class="number">10000</span>)) </span><br><span class="line">    WARNF(cLRD <span class="string">"The target binary is pretty slow! See %s/perf_tips.txt."</span>,</span><br><span class="line">          doc_path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (avg_us > <span class="number">50000</span>) havoc_div = <span class="number">10</span>;     <span class="comment">/* 0-19 execs/sec   */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us > <span class="number">20000</span>) havoc_div = <span class="number">5</span>; <span class="comment">/* 20-49 execs/sec  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us > <span class="number">10000</span>) havoc_div = <span class="number">2</span>; <span class="comment">/* 50-100 execs/sec */</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 如果不是resuming_fuzz下，则根据queue的大小、个数等属性存在的问题，抛出相应的警告。</span></span><br><span class="line"><span class="comment">     然后显示一些较为有用的状态信息 */</span></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) {</span><br><span class="line">    <span class="keyword">if</span> (max_len > <span class="number">50</span> * <span class="number">1024</span>)</span><br><span class="line">      WARNF(cLRD <span class="string">"Some test cases are huge (%s) - see %s/perf_tips.txt!"</span>,</span><br><span class="line">            DMS(max_len), doc_path);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (max_len > <span class="number">10</span> * <span class="number">1024</span>)</span><br><span class="line">      WARNF(<span class="string">"Some test cases are big (%s) - see %s/perf_tips.txt."</span>,</span><br><span class="line">            DMS(max_len), doc_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useless_at_start && !in_bitmap)</span><br><span class="line">      WARNF(cLRD <span class="string">"Some test cases look useless. Consider using a smaller set."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queued_paths > <span class="number">100</span>)</span><br><span class="line">      WARNF(cLRD <span class="string">"You probably have far too many input files! Consider trimming down."</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (queued_paths > <span class="number">20</span>)</span><br><span class="line">      WARNF(<span class="string">"You have lots of input files; try starting small."</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">"Here are some useful stats:\n\n"</span></span><br><span class="line"></span><br><span class="line">      cGRA <span class="string">"    Test case count : "</span> cRST <span class="string">"%u favored, %u variable, %u total\n"</span></span><br><span class="line">      cGRA <span class="string">"       Bitmap range : "</span> cRST <span class="string">"%u to %u bits (average: %0.02f bits)\n"</span></span><br><span class="line">      cGRA <span class="string">"        Exec timing : "</span> cRST <span class="string">"%s to %s us (average: %s us)\n"</span>,</span><br><span class="line">      queued_favored, queued_variable, queued_paths, min_bits, max_bits, </span><br><span class="line">      ((<span class="keyword">double</span>)total_bitmap_size) / (total_bitmap_entries ? total_bitmap_entries : <span class="number">1</span>),</span><br><span class="line">      DI(min_us), DI(max_us), DI(avg_us));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 找到适当的超时时间。找出适当的超时时间。 基本思想是：平均5倍或最大1倍，四舍五入到EXEC_TM_ROUND</span></span><br><span class="line"><span class="comment">     毫秒，并以 1 秒为上限。如果程序很慢，则乘数会降低到2倍或3倍，因为随机调度器抖动不太可能产生任何影响</span></span><br><span class="line"><span class="comment">     1.如果timeout_given值为0，即未指定'-t'参数：</span></span><br><span class="line"><span class="comment">        a.根据avg_us，计算出exec_tmout（avg_us单位是微秒，exec_tmout单位是毫秒，所以要除以1000）</span></span><br><span class="line"><span class="comment">        b.将计算出的exec_tmout与max_us/1000，取最大值赋给exec_tmout</span></span><br><span class="line"><span class="comment">        c.然后四舍五入到EXEC_TM_ROUND毫秒</span></span><br><span class="line"><span class="comment">        d.再将exec_tmout设置为exec_tmout、EXEC_TIMEOUT中的最大值</span></span><br><span class="line"><span class="comment">        e.打印未指定'-t'参数的相关提示信息，设置timeout_given值为1</span></span><br><span class="line"><span class="comment">     2.如果timeout_given值为3，代表这是resuming_fuzz，此时的timeout_given是从历史记录里读取的，</span></span><br><span class="line"><span class="comment">       并打印相应的提示信息</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) {</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (avg_us > <span class="number">50000</span>) </span><br><span class="line">        exec_tmout = avg_us * <span class="number">2</span> / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (avg_us > <span class="number">10000</span>) </span><br><span class="line">        exec_tmout = avg_us * <span class="number">3</span> / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        exec_tmout = avg_us * <span class="number">5</span> / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    exec_tmout = MAX(exec_tmout, max_us / <span class="number">1000</span>);</span><br><span class="line">    exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exec_tmout > EXEC_TIMEOUT) </span><br><span class="line">        exec_tmout = EXEC_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">"No -t option specified, so I'll use exec timeout of %u ms."</span>, </span><br><span class="line">         exec_tmout);</span><br><span class="line"></span><br><span class="line">    timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (timeout_given == <span class="number">3</span>) {</span><br><span class="line">    ACTF(<span class="string">"Applying timeout settings from resumed session (%u ms)."</span>, exec_tmout);</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在dumb_mode下，且未设置环境变量AFL_HANG_TMOUT时。重新运行每个超时测试用例的时间限制</span></span><br><span class="line"><span class="comment">     是非常昂贵的，所以让我们选择一个更保守的默认值 */</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode && !getenv(<span class="string">"AFL_HANG_TMOUT"</span>))</span><br><span class="line">    hang_tmout = MIN(EXEC_TIMEOUT, exec_tmout * <span class="number">2</span> + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">"All set and ready to roll!"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* resuming_fuzz时，尝试找到要从其开始的队列位置；只在resuming_fuzz、并且可以找到</span></span><br><span class="line"><span class="comment">  原始的fuzzer_stats时才有意义 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">find_start_position</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">4096</span>]; </span><br><span class="line"></span><br><span class="line">  u8  *fn, *off;</span><br><span class="line">  s32 fd, i;</span><br><span class="line">  u32 ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不是resuming_fuzz，直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果设置了in_place_resume，则打开out_dir/fuzzer_stats文件；否则</span></span><br><span class="line"><span class="comment">     打开in_dir/../fuzzer_stats文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/fuzzer_stats"</span>, out_dir);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/../fuzzer_stats"</span>, in_dir);</span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_RDONLY);</span><br><span class="line">  ck_free(fn);</span><br><span class="line">  <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 1.将文件的内容读取到tmp中</span></span><br><span class="line"><span class="comment">     2.在tmp中找到字符串"cur_path        :"，并将其对应的值转换为整数，赋给ret</span></span><br><span class="line"><span class="comment">     3.判断ret的值是否超过queued_paths，如果超过则将ret置0</span></span><br><span class="line"><span class="comment">     4.返回ret</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  i = <span class="built_in">read</span>(fd, tmp, <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>); (<span class="keyword">void</span>)i; </span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  off = <span class="built_in">strstr</span>(tmp, <span class="string">"cur_path          : "</span>);</span><br><span class="line">  <span class="keyword">if</span> (!off) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ret = atoi(off + <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret >= queued_paths) </span><br><span class="line">      ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h3><p>该函数中格式化的状态属性有部分为fuzz_one中计算出的内容，这些内容暂时引用sakura师傅的结论。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 更新状态文件以对fuzzing过程进行监控 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_stats_file</span><span class="params">(<span class="keyword">double</span> bitmap_cvg, <span class="keyword">double</span> stability, <span class="keyword">double</span> eps)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> last_bcvg, last_stab, last_eps;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> <span class="title">usage</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建out_dir/fuzzer_stats文件，准备写入统计信息 */</span></span><br><span class="line">  u8* fn = alloc_printf(<span class="string">"%s/fuzzer_stats"</span>, out_dir);</span><br><span class="line">  s32 fd;</span><br><span class="line">  FILE* f;</span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd < <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">"Unable to create '%s'"</span>, fn);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  f = fdopen(fd, <span class="string">"w"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!f) </span><br><span class="line">      PFATAL(<span class="string">"fdopen() failed"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果bitmap_cvg、stability、eps都为0，则用last_bcvg、last_stab、last_eps去设置它们</span></span><br><span class="line"><span class="comment">     否则（仅在show_stats中被调用时不为空）将它们保存到last_bcvg、last_stab、last_eps中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!bitmap_cvg && !stability && !eps) {</span><br><span class="line">    bitmap_cvg = last_bcvg;</span><br><span class="line">    stability  = last_stab;</span><br><span class="line">    eps        = last_eps;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    last_bcvg = bitmap_cvg;</span><br><span class="line">    last_stab = stability;</span><br><span class="line">    last_eps  = eps;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(f, <span class="string">"start_time        : %llu\n"</span>  <span class="comment">// start_time / 1000，fuzz运行的开始时间</span></span><br><span class="line">             <span class="string">"last_update       : %llu\n"</span>  <span class="comment">// get_cur_time() / 1000，当前时间</span></span><br><span class="line">             <span class="string">"fuzzer_pid        : %u\n"</span>    <span class="comment">// getpid()，获取当前pid</span></span><br><span class="line">             <span class="string">"cycles_done       : %llu\n"</span>  <span class="comment">// queue_cycle ? (queue_cycle - 1) : 0，表示queue队列被完全变异一次的次数</span></span><br><span class="line">             <span class="string">"execs_done        : %llu\n"</span>  <span class="comment">// total_execs，target的总的执行次数，每次run_target的时候会增加1</span></span><br><span class="line">             <span class="string">"execs_per_sec     : %0.02f\n"</span><span class="comment">// eps，每秒执行的次数</span></span><br><span class="line">             <span class="string">"paths_total       : %u\n"</span>    <span class="comment">// queued_paths，每次add_to_queue的时候会增加1，代表queue里的样例总数</span></span><br><span class="line">             <span class="string">"paths_favored     : %u\n"</span>    <span class="comment">// queued_favored，"有利"的路径总数，在cull_queue中计算出来</span></span><br><span class="line">             <span class="string">"paths_found       : %u\n"</span>    <span class="comment">// queued_discovered，在每次common_fuzz_stuff去执行一次fuzz时，发现新的interesting case的时候会增加1，代表在fuzz运行期间发现的新queue entry</span></span><br><span class="line">             <span class="string">"paths_imported    : %u\n"</span>    <span class="comment">// queued_imported，master-slave模式下，如果sync过来的case是interesting的，就增加1</span></span><br><span class="line">             <span class="string">"max_depth         : %u\n"</span>    <span class="comment">// max_depth，最大路径深度</span></span><br><span class="line">             <span class="string">"cur_path          : %u\n"</span>    <span class="comment">// current_entry，current_entry一般情况下代表的是正在执行的queue entry的整数ID，queue首节点的ID是0，必须符合find_start_position() </span></span><br><span class="line">             <span class="string">"pending_favs      : %u\n"</span>    <span class="comment">// pending_favored，等待fuzz的favored paths数</span></span><br><span class="line">             <span class="string">"pending_total     : %u\n"</span>    <span class="comment">// pending_not_fuzzed，在queue中等待fuzz的case数</span></span><br><span class="line">             <span class="string">"variable_paths    : %u\n"</span>    <span class="comment">// queued_variable，导致可变路径的case数</span></span><br><span class="line">             <span class="string">"stability         : %0.02f%%\n"</span> </span><br><span class="line">             <span class="string">"bitmap_cvg        : %0.02f%%\n"</span> </span><br><span class="line">             <span class="string">"unique_crashes    : %llu\n"</span>  <span class="comment">// 在save_if_interesting时，如果fault是FAULT_CRASH，则unique_crashes计数器加1</span></span><br><span class="line">             <span class="string">"unique_hangs      : %llu\n"</span>  <span class="comment">// 在save_if_interesting时，如果fault是FAULT_TMOUT，且exec_tmout小于hang_tmout，就以hang_tmout为超时时间再执行一次，如果还超时，就让unique_hangs计数器加一</span></span><br><span class="line">             <span class="string">"last_path         : %llu\n"</span>  <span class="comment">// last_path_time / 1000，当add_to_queue将一个新case加入queue时，就设置一次last_path_time为当前时间</span></span><br><span class="line">             <span class="string">"last_crash        : %llu\n"</span>  <span class="comment">// last_crash_time / 1000，在unique_crashes加一的时候，last_crash更新为当前时间</span></span><br><span class="line">             <span class="string">"last_hang         : %llu\n"</span>  <span class="comment">// last_hang_time / 1000，在unique_hangs加一的时候，last_hang更新为当前时间</span></span><br><span class="line">             <span class="string">"execs_since_crash : %llu\n"</span>  <span class="comment">// total_execs - last_crash_execs，表示在上一次crash之后总计执行了多少次</span></span><br><span class="line">             <span class="string">"exec_timeout      : %u\n"</span>    <span class="comment">// exec_tmout，配置好的超时时间，必须符合find_timeout()</span></span><br><span class="line">             <span class="string">"afl_banner        : %s\n"</span>  </span><br><span class="line">             <span class="string">"afl_version       : "</span> VERSION <span class="string">"\n"</span>  </span><br><span class="line">             <span class="string">"target_mode       : %s%s%s%s%s%s%s\n"</span>  <span class="comment">// fuzz时采用的所有执行模式</span></span><br><span class="line">             <span class="string">"command_line      : %s\n"</span>    <span class="comment">// 原始参数，在save_cmdline中保存</span></span><br><span class="line">             <span class="string">"slowest_exec_ms   : %llu\n"</span>, <span class="comment">// 单个用例最慢执行时间，在run_target中设置</span></span><br><span class="line">             start_time / <span class="number">1000</span>, get_cur_time() / <span class="number">1000</span>, getpid(),</span><br><span class="line">             queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps,</span><br><span class="line">             queued_paths, queued_favored, queued_discovered, queued_imported,</span><br><span class="line">             max_depth, current_entry, pending_favored, pending_not_fuzzed,</span><br><span class="line">             queued_variable, stability, bitmap_cvg, unique_crashes,</span><br><span class="line">             unique_hangs, last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>,</span><br><span class="line">             last_hang_time / <span class="number">1000</span>, total_execs - last_crash_execs,</span><br><span class="line">             exec_tmout, use_banner,</span><br><span class="line">             qemu_mode ? <span class="string">"qemu "</span> : <span class="string">""</span>, dumb_mode ? <span class="string">" dumb "</span> : <span class="string">""</span>,</span><br><span class="line">             no_forkserver ? <span class="string">"no_forksrv "</span> : <span class="string">""</span>, crash_mode ? <span class="string">"crash "</span> : <span class="string">""</span>,</span><br><span class="line">             persistent_mode ? <span class="string">"persistent "</span> : <span class="string">""</span>, deferred_mode ? <span class="string">"deferred "</span> : <span class="string">""</span>,</span><br><span class="line">             (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">              persistent_mode || deferred_mode) ? <span class="string">""</span> : <span class="string">"default"</span>,</span><br><span class="line">             orig_cmdline, slowest_exec_ms);</span><br><span class="line">             <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计子进程的资源用量。在调用getrusage之前需要保证杀死fork server进程，并调用了waitpid */</span></span><br><span class="line">  <span class="keyword">if</span> (getrusage(RUSAGE_CHILDREN, &usage)) {</span><br><span class="line">      WARNF(<span class="string">"getrusage failed"</span>);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (usage.ru_maxrss == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">"peak_rss_mb       : not available while afl is running\n"</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">"peak_rss_mb       : %zu\n"</span>, usage.ru_maxrss >> <span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">"peak_rss_mb       : %zu\n"</span>, usage.ru_maxrss >> <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  }</span><br><span class="line">  fclose(f);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 保存自动生成的extras(token) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_auto</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果auto_changed为0，就直接return；否则，就将其置0 */</span></span><br><span class="line">  <span class="keyword">if</span> (!auto_changed)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  auto_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.拼接路径out_dir/queue/.state/auto_extras/auto_i，并赋值给fn</span></span><br><span class="line"><span class="comment">     2.创建路径fn指定的文件</span></span><br><span class="line"><span class="comment">     3.将a_extras写入创建的文件中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < MIN(USE_AUTO_EXTRAS, a_extras_cnt); i++) {</span><br><span class="line">      </span><br><span class="line">    u8* fn = alloc_printf(<span class="string">"%s/queue/.state/auto_extras/auto_%06u"</span>, out_dir, i);</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"Unable to create '%s'"</span>, fn);</span><br><span class="line"></span><br><span class="line">    ck_write(fd, a_extras[i].data, a_extras[i].len, fn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p><strong>完结撒花 (๑•̀ㅂ•́)و✧</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a href="https://eternalsakura13.com/2020/08/23/afl/" target="_blank" rel="noopener"><strong>skr：sakuraのAFL源码全注释</strong></a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_41202237/article/details/121419250?spm=1001.2014.3001.5501" target="_blank" rel="noopener"><strong>hollk：AFL源码分析之afl-fuzz.c详细注释</strong></a></p>
</li>
<li><p><a href="https://bbs.pediy.com/thread-265936.htm" target="_blank" rel="noopener"><strong>ScUpax0s：AFL源码阅读笔记之gcc与fuzz部分</strong></a></p>
</li>
<li><p><a href="https://paper.seebug.org/1732/" target="_blank" rel="noopener"><strong>Seebug：AFL 二三事——源码分析</strong></a></p>
</li>
<li><p><strong><a href="https://github.com/google/AFL/blob/master/afl-fuzz.c" target="_blank" rel="noopener">AFL：afl-fuzz.c</a></strong></p>
</li>
<li><p><a href="https://hicookie.me/2019/09/18/AFL-Learning/" target="_blank" rel="noopener">HICOOKIE：AFL-Learning</a></p>
</li>
<li><p><a href="http://rk700.github.io/2017/12/28/afl-internals/" target="_blank" rel="noopener">AFL内部实现细节小记</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/52php/p/5813867.html" target="_blank" rel="noopener">博客园：Linux进程间通信（一）：信号signal()、sigaction()</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/52php/p/5861372.html" target="_blank" rel="noopener">博客园：Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/58489873" target="_blank" rel="noopener">知乎：Linux 的进程间通信-管道</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/GODYCA/archive/2013/01/05/2846197.html" target="_blank" rel="noopener">博客园：进程间通信管道进阶篇-linux下dup/dup2函数的用法</a></p>
</li>
<li><p><a href="https://cata1oc.github.io/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/">AFL源码分析03：afl-as.h</a></p>
</li>
<li><p><a href="https://blog.csdn.net/sweetfather/article/details/79457261" target="_blank" rel="noopener">CSDN：setsid的作用</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/gx-303841541/p/3360071.html" target="_blank" rel="noopener">博客园：Linux–setsid()与进程组、会话、守护进程</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/wanghetao/archive/2011/10/28/2227513.html" target="_blank" rel="noopener">博客园：C语言中volatile关键字与汇编</a></p>
</li>
<li><p><a href="https://blog.csdn.net/gmq_syy/article/details/73800652" target="_blank" rel="noopener">CSDN：linux系统编程之信号（八）：三种时间结构及定时器setitimer()详解</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/jikexianfeng/p/6312768.html" target="_blank" rel="noopener">博客园：WIFEXITED WEXITSTATUS WIFSIGNALED</a></p>
</li>
<li><p><a href="https://blog.csdn.net/lxlmycsdnfree/article/details/78926359" target="_blank" rel="noopener">CSDN：经典算法系列之(一) - BitMap [数据的压缩存储]</a></p>
</li>
</ol>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">cataLoc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://cata1oc.github.io/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/">http://cata1oc.github.io/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全    </a><a class="post-meta__tags" href="/tags/Fuzzing/">Fuzzing    </a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/cover0x53.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/"><img class="prev_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/cover0x54.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>AFL源码分析05：fuzz_one</span></div></a></div><div class="next-post pull_right"><a href="/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/cover0x52.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>AFL源码分析03：afl-as.h</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/01/02/AFL源码分析01/" title="AFL源码分析01：afl-gcc.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/02/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001/cover0x50.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-02</div><div class="relatedPosts_title">AFL源码分析01：afl-gcc.c</div></div></a></div><div class="relatedPosts_item"><a href="/2021/12/22/AFL环境搭建/" title="AFL环境搭建"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/12/22/AFL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/cover0x4F.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-12-22</div><div class="relatedPosts_title">AFL环境搭建</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/05/AFL源码分析02/" title="AFL源码分析02：afl-as.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/05/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/cover0x51.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-05</div><div class="relatedPosts_title">AFL源码分析02：afl-as.c</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/07/AFL源码分析03/" title="AFL源码分析03：afl-as.h"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/cover0x52.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-07</div><div class="relatedPosts_title">AFL源码分析03：afl-as.h</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/12/AFL源码分析05/" title="AFL源码分析05：fuzz_one"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/cover0x54.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-03-12</div><div class="relatedPosts_title">AFL源码分析05：fuzz_one</div></div></a></div><div class="relatedPosts_item"><a href="/2021/10/31/初探GOT与PLT/" title="初探GOT与PLT"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/10/31/%E5%88%9D%E6%8E%A2GOT%E4%B8%8EPLT/cover0x4C.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-31</div><div class="relatedPosts_title">初探GOT与PLT</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By cataLoc</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>