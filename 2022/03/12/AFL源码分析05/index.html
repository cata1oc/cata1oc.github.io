<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>AFL源码分析05：fuzz_one | cataLoc's Blog</title><meta name="description" content="AFL源码分析05：fuzz_one"><meta name="keywords" content="二进制安全,Fuzzing"><meta name="author" content="cataLoc"><meta name="copyright" content="cataLoc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="AFL源码分析05：fuzz_one"><meta name="twitter:description" content="AFL源码分析05：fuzz_one"><meta name="twitter:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/cover0x54.png"><meta property="og:type" content="article"><meta property="og:title" content="AFL源码分析05：fuzz_one"><meta property="og:url" content="http://cata1oc.github.io/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/"><meta property="og:site_name" content="cataLoc's Blog"><meta property="og:description" content="AFL源码分析05：fuzz_one"><meta property="og:image" content="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/cover0x54.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'true'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://cata1oc.github.io/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/"><link rel="prev" title="KCTF2022春季赛第二题" href="http://cata1oc.github.io/2022/05/13/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98/"><link rel="next" title="AFL源码分析04：afl-fuzz.c" href="http://cata1oc.github.io/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">cataLoc's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/Substitute.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">146</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键变量"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">关键变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#核心函数"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">核心函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#main-fuzz主循环部分"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">main(fuzz主循环部分)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sync-fuzzers"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">sync_fuzzers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#save-if-interesting"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">save_if_interesting</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#simplify-trace"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">simplify_trace</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#trim-case"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">trim_case</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#calculate-score"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">calculate_score</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#common-fuzz-stuff"><span class="toc_mobile_items-number">3.7.</span> <span class="toc_mobile_items-text">common_fuzz_stuff</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#choose-block-len"><span class="toc_mobile_items-number">3.8.</span> <span class="toc_mobile_items-text">choose_block_len</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#fuzz-one"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">fuzz_one</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#初始化阶段"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">初始化阶段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SIMPLE-BITFLIP-dictionary-construction-阶段"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">SIMPLE BITFLIP (+dictionary construction)阶段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ARITHMETIC-INC-DEC-阶段"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">ARITHMETIC INC&#x2F;DEC 阶段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#INTERESTING-VALUES阶段"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">INTERESTING VALUES阶段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#DICTIONARY-STUFF阶段"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">DICTIONARY STUFF阶段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#RANDOM-HAVOC（随机毁灭）阶段"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">RANDOM HAVOC（随机毁灭）阶段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SPLICING阶段"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">SPLICING阶段</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#交互运作"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">交互运作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考资料"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键变量"><span class="toc-number">2.</span> <span class="toc-text">关键变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心函数"><span class="toc-number">3.</span> <span class="toc-text">核心函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main-fuzz主循环部分"><span class="toc-number">3.1.</span> <span class="toc-text">main(fuzz主循环部分)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-fuzzers"><span class="toc-number">3.2.</span> <span class="toc-text">sync_fuzzers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#save-if-interesting"><span class="toc-number">3.3.</span> <span class="toc-text">save_if_interesting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#simplify-trace"><span class="toc-number">3.4.</span> <span class="toc-text">simplify_trace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trim-case"><span class="toc-number">3.5.</span> <span class="toc-text">trim_case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calculate-score"><span class="toc-number">3.6.</span> <span class="toc-text">calculate_score</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#common-fuzz-stuff"><span class="toc-number">3.7.</span> <span class="toc-text">common_fuzz_stuff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#choose-block-len"><span class="toc-number">3.8.</span> <span class="toc-text">choose_block_len</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fuzz-one"><span class="toc-number">4.</span> <span class="toc-text">fuzz_one</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化阶段"><span class="toc-number">4.1.</span> <span class="toc-text">初始化阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIMPLE-BITFLIP-dictionary-construction-阶段"><span class="toc-number">4.2.</span> <span class="toc-text">SIMPLE BITFLIP (+dictionary construction)阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARITHMETIC-INC-DEC-阶段"><span class="toc-number">4.3.</span> <span class="toc-text">ARITHMETIC INC&#x2F;DEC 阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTERESTING-VALUES阶段"><span class="toc-number">4.4.</span> <span class="toc-text">INTERESTING VALUES阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DICTIONARY-STUFF阶段"><span class="toc-number">4.5.</span> <span class="toc-text">DICTIONARY STUFF阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RANDOM-HAVOC（随机毁灭）阶段"><span class="toc-number">4.6.</span> <span class="toc-text">RANDOM HAVOC（随机毁灭）阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPLICING阶段"><span class="toc-number">4.7.</span> <span class="toc-text">SPLICING阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交互运作"><span class="toc-number">5.</span> <span class="toc-text">交互运作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/cover0x54.png)"><div id="post-info"><div id="post-title"><div class="posttitle">AFL源码分析05：fuzz_one</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2022-03-12<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2022-05-17</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇作为AFL源码分析的最后一篇，完成了对fuzz执行过程中的核心函数fuzz_one及其辅助函数（均位于文件afl-fuzz.c中，上一篇分析的主要是该文件中的fuzz初始化部分）的分析。在完整跟完一遍AFL源码后，不禁感叹于作者在代码设计上的巧妙以及将遗传算法应用在fuzz领域的绝佳构思。相信读者在阅读完这部分源码分析后也会有着相同的感受。</p>
<h2 id="关键变量"><a href="#关键变量" class="headerlink" title="关键变量"></a>关键变量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u32 exec_tmout = EXEC_TIMEOUT; <span class="comment">/* Configurable exec timeout (ms)   */</span></span><br><span class="line"><span class="keyword">static</span> u32 hang_tmout = EXEC_TIMEOUT; <span class="comment">/* Timeout used for hang det (ms)   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u32 stats_update_freq = <span class="number">1</span>;     <span class="comment">/* Stats update frequency (execs)   */</span></span><br><span class="line"></span><br><span class="line">EXP_ST u8  skip_deterministic,        <span class="comment">/* Skip deterministic stages?       */</span></span><br><span class="line">           force_deterministic,       <span class="comment">/* Force deterministic stages?      */</span></span><br><span class="line">           use_splicing,              <span class="comment">/* Recombine input files?           */</span></span><br><span class="line">           skip_requested,            <span class="comment">/* Skip request, via SIGUSR1        */</span></span><br><span class="line"></span><br><span class="line">EXP_ST u32 cur_skipped_paths,         <span class="comment">/* Abandoned inputs in cur cycle    */</span> </span><br><span class="line">           current_entry,             <span class="comment">/* Current queue entry ID           */</span></span><br><span class="line">           queued_with_cov,           <span class="comment">/* Paths with new coverage bytes    */</span></span><br><span class="line">           queued_discovered,         <span class="comment">/* Items discovered during this run */</span></span><br><span class="line">           pending_favored,           <span class="comment">/* Pending favored paths            */</span></span><br><span class="line">           pending_not_fuzzed,        <span class="comment">/* Queued but not done yet          */</span></span><br><span class="line">    </span><br><span class="line">EXP_ST u64 queue_cycle,               <span class="comment">/* Queue round counter              */</span></span><br><span class="line">           cycles_wo_finds,           <span class="comment">/* Cycles without any new paths     */</span></span><br><span class="line">           total_tmouts,              <span class="comment">/* Total number of timeouts         */</span></span><br><span class="line">           unique_hangs,              <span class="comment">/* Hangs with unique signatures     */</span></span><br><span class="line">           bytes_trim_in,             <span class="comment">/* Bytes coming into the trimmer    */</span></span><br><span class="line">           bytes_trim_out,            <span class="comment">/* Bytes coming outa the trimmer    */</span></span><br><span class="line">           trim_execs,                <span class="comment">/* Execs done to trim input files   */</span></span><br><span class="line">           bytes_trim_in,             <span class="comment">/* Bytes coming into the trimmer    */</span></span><br><span class="line">           bytes_trim_out,            <span class="comment">/* Bytes coming outa the trimmer    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u32 subseq_tmouts;             <span class="comment">/* Number of timeouts in a row      */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> u8 *stage_name = <span class="string">"init"</span>,       <span class="comment">/* Name of the current fuzz stage   */</span></span><br><span class="line">          *stage_short,               <span class="comment">/* Short stage name                 */</span></span><br><span class="line">          *syncing_party;             <span class="comment">/* Currently syncing with...        */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> s32 stage_cur, stage_max;      <span class="comment">/* Stage progression                */</span></span><br><span class="line"><span class="keyword">static</span> s32 splicing_with = <span class="number">-1</span>;        <span class="comment">/* Splicing with which test case?   */</span></span><br></pre></td></tr></tbody></table></figure></div>



<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="main-fuzz主循环部分"><a href="#main-fuzz主循环部分" class="headerlink" title="main(fuzz主循环部分)"></a>main(fuzz主循环部分)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">u32 seek_to;</span><br><span class="line">seek_to = find_start_position();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1.首先调用cull_queue精简队列，筛选掉不是favored的case</span></span><br><span class="line"><span class="comment">       2.如果queue_cur为空，说明所有queue都被执行完一轮，则：</span></span><br><span class="line"><span class="comment">          a.为新一轮fuzz做些准备：</span></span><br><span class="line"><span class="comment">            1).设置计数器queue_cycle加1，表示所有queue被完整执行了多少轮</span></span><br><span class="line"><span class="comment">            2).将用于表示当前queue下标的current_entry清零</span></span><br><span class="line"><span class="comment">            3).将用于统计此轮fuzz废弃掉case个数的计数器cur_skipped_paths清零</span></span><br><span class="line"><span class="comment">            4).令queue_cur指向fuzzing queue列表的第一个queue，准备开始新一轮fuzz</span></span><br><span class="line"><span class="comment">          b.如果seek_to不为空，说明此时为resuming_fuzz，则进入循环：</span></span><br><span class="line"><span class="comment">            1).把queue_cur定位到seek_to指向的位置</span></span><br><span class="line"><span class="comment">            2).同时current_entry也更新到queue_cur所在位置的下标</span></span><br><span class="line"><span class="comment">          c.调用show_stats()刷新展示界面</span></span><br><span class="line"><span class="comment">          d.如果不是终端模式（not_on_tty==1），则输出当前是第几轮fuzz</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cull_queue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) {</span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) {</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur->next;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      show_stats();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) {</span><br><span class="line">        ACTF(<span class="string">"Entering queue cycle %llu."</span>, queue_cycle);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* 如果完整的一轮fuzz没有发现新的路径，那么接下来尝试调整策略</span></span><br><span class="line"><span class="comment">         1.判断queued_paths与prev_queued是否相等：</span></span><br><span class="line"><span class="comment">            a.若相等，表明在刚刚结束的一轮fuzz中没有发现新的路径（如果发现新的路径，则会在</span></span><br><span class="line"><span class="comment">              save_if_interesting中会调用add_to_queue修改queued_paths的值），那么</span></span><br><span class="line"><span class="comment">              接下来判断是否设置了use_splicing（如果没有指定'-M'或指定了'-d'则会设置其值）：</span></span><br><span class="line"><span class="comment">               1).如果设置了，则将cycles_wo_finds加1</span></span><br><span class="line"><span class="comment">               2).如果没设置，则设置use_spicing为1，表示接下来要通过splicing进行队列重组</span></span><br><span class="line"><span class="comment">            b.若不等，说明有新路径发现，则设置cycle_wo_finds为0</span></span><br><span class="line"><span class="comment">         2.用queued_paths去设置prev_queued的值</span></span><br><span class="line"><span class="comment">         3.如果设置了sync_id（参数指定'-M'或'-S'），且queue_cycle为1，且设置了环境变量</span></span><br><span class="line"><span class="comment">           AFL_IMPORT_FIRST；则调用sync_fuzzers从其它sync文件下的fuzzer中读取interesting</span></span><br><span class="line"><span class="comment">           的case到自己的queue中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) {</span><br><span class="line">        <span class="keyword">if</span> (use_splicing) </span><br><span class="line">            cycles_wo_finds++; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            use_splicing = <span class="number">1</span>;</span><br><span class="line">      } <span class="keyword">else</span></span><br><span class="line">          cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id && queue_cycle == <span class="number">1</span> && getenv(<span class="string">"AFL_IMPORT_FIRST"</span>))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 1.调用fuzz_one对queue_cur进行一次变异测试（fuzz_one并不一定真的执行当前queue_cur，它有</span></span><br><span class="line"><span class="comment">         一定的策略；如果不执行，就直接返回1，否则返回0），</span></span><br><span class="line"><span class="comment">         上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完</span></span><br><span class="line"><span class="comment">         成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队</span></span><br><span class="line"><span class="comment">         列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行</span></span><br><span class="line"><span class="comment">         "deterministic fuzzing"了。如果用户不停止AFL，seed文件将会一遍遍的变异下去。</span></span><br><span class="line"><span class="comment">       2.如果没有设置stop_soon，但是设置了sync_id，且fuzz_one返回0：</span></span><br><span class="line"><span class="comment">          a.令sync_interval_cnt加1（main函数开始时初始化为0）</span></span><br><span class="line"><span class="comment">          b.如果sync_interval_cnt能够被SYNC_INTERVAL(在config.h中定义为5)整除，那么调用</span></span><br><span class="line"><span class="comment">            sync_fuzzers来同步其它fuzzer</span></span><br><span class="line"><span class="comment">       3.如果没有设置stop_soon，但是设置了exit_1，则将stop_soon设置为2，并break出fuzz主循环</span></span><br><span class="line"><span class="comment">       4.queue_cur指向fuzzing queue队列中的下一个queue，current_entry也随之自增1。准备测试</span></span><br><span class="line"><span class="comment">         下一个queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon && sync_id && !skipped_fuzz) {     </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon && exit_1)</span><br><span class="line">        stop_soon = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur->next;</span><br><span class="line">    current_entry++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数的主要作用是进行queue同步，先读取有哪些fuzzer文件夹，然后读取其它fuzzer文件夹下的queue</span></span><br><span class="line"><span class="comment">   文件夹中的测试用例，并依次执行一遍。如果执行过程中，发现这些测试用例可以触发新路径，则将测试用例保存</span></span><br><span class="line"><span class="comment">   到自己的queue文件夹中，并将最后一个同步的测试用例的case_id写入到".synced/d_name"的文件中，以</span></span><br><span class="line"><span class="comment">   避免重复运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct dirent {</span></span><br><span class="line"><span class="comment">      long d_ino;                 // 索引节点号</span></span><br><span class="line"><span class="comment">      off_t d_off;                // 在目录文件中的偏移</span></span><br><span class="line"><span class="comment">      unsigned short d_reclen;    // 文件名长</span></span><br><span class="line"><span class="comment">      unsigned char d_type;       // 文件类型</span></span><br><span class="line"><span class="comment">      char d_name[NAME_MAX+1];    // 文件名，最长255字节</span></span><br><span class="line"><span class="comment">   } </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sync_fuzzers</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">  DIR* sd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">sd_ent</span>;</span></span><br><span class="line">  u32 sync_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 首先打开sync_dir文件夹 */</span></span><br><span class="line">  sd = opendir(sync_dir);</span><br><span class="line">  <span class="keyword">if</span> (!sd) </span><br><span class="line">      PFATAL(<span class="string">"Unable to open '%s'"</span>, sync_dir);</span><br><span class="line"></span><br><span class="line">  stage_max = stage_cur = <span class="number">0</span>;</span><br><span class="line">  cur_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环读取sync_dir目录下的所有文件（重点是其它fuzzer创建的文件夹）</span></span><br><span class="line"><span class="comment">     1.跳过.开头的和当前fuzzer创建的文件（sync_dir != sd_ent->d_name）</span></span><br><span class="line"><span class="comment">     2.跳过任何不包含queue子目录的文件夹，通过尝试打开"sync_dir/d_name/queue"文件夹。若打开失败，</span></span><br><span class="line"><span class="comment">       说明不包含queue子目录</span></span><br><span class="line"><span class="comment">     3.打开out_dir/.synced/d_name文件，读取前4个字节到变量min_accept中，然后调用lseek</span></span><br><span class="line"><span class="comment">       调整文件内指针到开头，并设置next_min_accept的值为min_accept，这个值代表之前从这个</span></span><br><span class="line"><span class="comment">       (queue)文件夹里读取到的最后一个queue的id</span></span><br><span class="line"><span class="comment">     4.调整sync_cnt的值，显示现在同步到的阶段。并将stage_cur与stage_max清零</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> ((sd_ent = readdir(sd))) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> u8 stage_tmp[<span class="number">128</span>];</span><br><span class="line">    DIR* qd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">qd_ent</span>;</span></span><br><span class="line">    u8 *qd_path, *qd_synced_path;</span><br><span class="line">    u32 min_accept = <span class="number">0</span>, next_min_accept;</span><br><span class="line">    s32 id_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sd_ent->d_name[<span class="number">0</span>] == <span class="string">'.'</span> || !<span class="built_in">strcmp</span>(sync_id, sd_ent->d_name))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    qd_path = alloc_printf(<span class="string">"%s/%s/queue"</span>, sync_dir, sd_ent->d_name);</span><br><span class="line">    <span class="keyword">if</span> (!(qd = opendir(qd_path))) {</span><br><span class="line">      ck_free(qd_path);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    qd_synced_path = alloc_printf(<span class="string">"%s/.synced/%s"</span>, out_dir, sd_ent->d_name);</span><br><span class="line">    id_fd = <span class="built_in">open</span>(qd_synced_path, O_RDWR | O_CREAT, <span class="number">0600</span>);     </span><br><span class="line">    <span class="keyword">if</span> (id_fd < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"Unable to create '%s'"</span>, qd_synced_path);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(id_fd, &min_accept, <span class="keyword">sizeof</span>(u32)) > <span class="number">0</span>) </span><br><span class="line">      lseek(id_fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    next_min_accept = min_accept;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(stage_tmp, <span class="string">"sync %u"</span>, ++sync_cnt);</span><br><span class="line">    stage_name = stage_tmp;</span><br><span class="line">    stage_cur  = <span class="number">0</span>;</span><br><span class="line">    stage_max  = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接下来利用一个while循环检查此fuzzer对应的queue队列中的每个用例，解析ID并检查我们之前是否</span></span><br><span class="line"><span class="comment">       查看过它；如果没有，则执行这个测试用例：</span></span><br><span class="line"><span class="comment">       1.跳过.开头的文件和标识小于min_accept的文件（即已经sync过的文件）</span></span><br><span class="line"><span class="comment">       2.如果标识syncing_case >= next_min_accept，就设置next_min_accept的值为syncing_case+1</span></span><br><span class="line"><span class="comment">       3.开始同步case，先打开这个case文件，并获取文件状态   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> ((qd_ent = readdir(qd))) {</span><br><span class="line"></span><br><span class="line">      u8* path;</span><br><span class="line">      s32 fd;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (qd_ent->d_name[<span class="number">0</span>] == <span class="string">'.'</span> ||</span><br><span class="line">          <span class="built_in">sscanf</span>(qd_ent->d_name, CASE_PREFIX <span class="string">"%06u"</span>, &syncing_case) != <span class="number">1</span> || </span><br><span class="line">          syncing_case < min_accept)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (syncing_case >= next_min_accept)</span><br><span class="line">        next_min_accept = syncing_case + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      path = alloc_printf(<span class="string">"%s/%s"</span>, qd_path, qd_ent->d_name);</span><br><span class="line">      fd = <span class="built_in">open</span>(path, O_RDONLY);</span><br><span class="line">      <span class="keyword">if</span> (fd < <span class="number">0</span>) {</span><br><span class="line">         ck_free(path);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (fstat(fd, &st))</span><br><span class="line">          PFATAL(<span class="string">"fstat() failed"</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* 略过大小为0以及大小超过MAX_FILE（默认为1M）的文件， 然后对这个case作进一步判断：</span></span><br><span class="line"><span class="comment">           a.调用mmap映射这个case文件到mem中</span></span><br><span class="line"><span class="comment">           b.调用write_to_testcase将这个case写入到out_file(在detect_file_args中，out_file</span></span><br><span class="line"><span class="comment">             被设置为out_dir/.cur_input)</span></span><br><span class="line"><span class="comment">           c.调用run_target执行目标程序，监控超时情况，返回状态信息</span></span><br><span class="line"><span class="comment">           d.判断一次stop_soon，如果设置了就返回</span></span><br><span class="line"><span class="comment">           e.设置syncing_party为这个case在目录中的文件名</span></span><br><span class="line"><span class="comment">           f.调用save_if_interesting来决定是否要导入这个文件到自己的queue里；如果发现了新的path</span></span><br><span class="line"><span class="comment">             就导入。如果导入了会返回1，就令计数器queued_imported加1。</span></span><br><span class="line"><span class="comment">           g.调用munmap解除这个case的映射</span></span><br><span class="line"><span class="comment">           h.如果到了状态更新的周期(stats_update_freq默认为1)，则调用show_stats刷新一次界面</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_size && st.st_size <= MAX_FILE) {</span><br><span class="line">        u8  fault;</span><br><span class="line">        u8* mem = mmap(<span class="number">0</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED)</span><br><span class="line">            PFATAL(<span class="string">"Unable to mmap '%s'"</span>, path);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        write_to_testcase(mem, st.st_size);</span><br><span class="line">          </span><br><span class="line">        fault = run_target(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stop_soon) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        syncing_party = sd_ent->d_name;</span><br><span class="line">        </span><br><span class="line">        queued_imported += save_if_interesting(argv, mem, st.st_size, fault);</span><br><span class="line">        syncing_party = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        munmap(mem, st.st_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(stage_cur++ % stats_update_freq))</span><br><span class="line">            show_stats();</span><br><span class="line">      }</span><br><span class="line">      ck_free(path);</span><br><span class="line">      <span class="built_in">close</span>(fd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将当前的next_min_accept写入到id_fd指向的文件，也就是out_dir/.synced/d_name对应的文件</span></span><br><span class="line"><span class="comment">       ，方便下次sync的时候，判断找到最后一个sync的case，以避免重复运行 */</span></span><br><span class="line">    ck_write(id_fd, &next_min_accept, <span class="keyword">sizeof</span>(u32), qd_synced_path);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(id_fd);</span><br><span class="line">    closedir(qd);</span><br><span class="line">    ck_free(qd_path);</span><br><span class="line">    ck_free(qd_synced_path);</span><br><span class="line">    </span><br><span class="line">  }  </span><br><span class="line">  closedir(sd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检查mem映射的这个case是否是interesting的，如果是，则将其保存到queue中，并返回1；否则返回0 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">save_if_interesting</span><span class="params">(<span class="keyword">char</span>** argv, <span class="keyword">void</span>* mem, u32 len, u8 fault)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u8  *fn = <span class="string">""</span>;</span><br><span class="line">  u8  hnb;</span><br><span class="line">  s32 fd;</span><br><span class="line">  u8  keeping = <span class="number">0</span>, res;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 判断传入的参数fault是否为crash_mode，若是，则作进一步处理：</span></span><br><span class="line"><span class="comment">     1.调用has_new_bits判断这个case是否触发了新的路径或者命中了已有的路径；若都没有触发，则判断是否</span></span><br><span class="line"><span class="comment">       设置了crash_mode：</span></span><br><span class="line"><span class="comment">          a.如果设置了crash_mode，则令total_crashes加1，然后return 0</span></span><br><span class="line"><span class="comment">          b.如果没设置crash_mode，直接return 0</span></span><br><span class="line"><span class="comment">     2.拼接路径fn为"out_dir/queue/id:00000queued_paths, describe_op(hub)"</span></span><br><span class="line"><span class="comment">     3.调用add_to_queue将case添加到队列里</span></span><br><span class="line"><span class="comment">     4.如果hub值为2，说明发现了新的路径：</span></span><br><span class="line"><span class="comment">        a.将刚刚入队的q->has_new_cov的值设置为1</span></span><br><span class="line"><span class="comment">        b.计数器queued_with_cov的值加1</span></span><br><span class="line"><span class="comment">     5.计算trace_bits（当前run_target之后的tuple信息）的哈希值，保存到q->exec_cksum</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="keyword">if</span> (fault == crash_mode) {</span><br><span class="line">    <span class="keyword">if</span> (!(hnb = has_new_bits(virgin_bits))) {</span><br><span class="line">      <span class="keyword">if</span> (crash_mode) </span><br><span class="line">          total_crashes++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">    fn = alloc_printf(<span class="string">"%s/queue/id:%06u,%s"</span>, out_dir, queued_paths, describe_op(hnb));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    fn = alloc_printf(<span class="string">"%s/queue/id_%06u"</span>, out_dir, queued_paths);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line">      </span><br><span class="line">    add_to_queue(fn, len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hnb == <span class="number">2</span>) {</span><br><span class="line">      queue_top->has_new_cov = <span class="number">1</span>;</span><br><span class="line">      queued_with_cov++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    queue_top->exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 6.调用calibrate_case评估这个case，</span></span><br><span class="line"><span class="comment">       7.若错误类型为FAULT_ERROR，则直接抛出异常"无法执行目标程序"</span></span><br><span class="line"><span class="comment">       8.否则，创建fn路径指定的文件，并将case写入文件中</span></span><br><span class="line"><span class="comment">       9.将keeping值设置为1（函数开始时被初始化为0）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    res = calibrate_case(argv, queue_top, mem, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">"Unable to execute target application"</span>);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"Unable to create '%s'"</span>, fn);</span><br><span class="line">    ck_write(fd, mem, len, fn);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    keeping = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 以上为fault类型为crash_mode时的处理方式。其它fault类型，则进入switch中进行处理 */</span>  </span><br><span class="line">  <span class="keyword">switch</span> (fault) {</span><br><span class="line">          </span><br><span class="line">    <span class="comment">/* 我们对导致超时的case不是那么有兴趣，但我们仍然有义务保留少量样本，我们将特定于超时的位图中新位</span></span><br><span class="line"><span class="comment">       的置位来作为唯一的信号；但是在dumb_mode下，保留所有case。具体操作如下：</span></span><br><span class="line"><span class="comment">       1.total_tmouts计数器加1</span></span><br><span class="line"><span class="comment">       2.如果unique_hangs >= KEEP_UNIQUE_HANG(能保存的最大数量，这个值在config.h中设置为500)</span></span><br><span class="line"><span class="comment">         ，就直接返回keeping(函数开始处初始化为0)</span></span><br><span class="line"><span class="comment">       3.如果不是dumb_mode：</span></span><br><span class="line"><span class="comment">          a.调用simlify_trace对trace_bits进行规整(一种简化跟踪的操作，以加快执行速度)</span></span><br><span class="line"><span class="comment">          b.调用has_new_bits判断是否有新的超时路径，如果没有，直接返回keeping</span></span><br><span class="line"><span class="comment">       4.令unique_tmouts计数器加1，如果不是dumb_mode，说明case发现了新的超时路径；对于dumb_mode</span></span><br><span class="line"><span class="comment">         ，则是保存发现的所有超时的case</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:          </span><br><span class="line">      total_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_hangs >= KEEP_UNIQUE_HANG) </span><br><span class="line">          <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) {</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        simplify_trace((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        simplify_trace((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!has_new_bits(virgin_tmout)) </span><br><span class="line">            <span class="keyword">return</span> keeping;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      unique_tmouts++;</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">      <span class="comment">/* 在保存case之前，我们通过使用一个更大的超时时间重新执行程序，以确保它是一个真正的挂起（除非</span></span><br><span class="line"><span class="comment">         默认超时已经很长），具体操作如下：</span></span><br><span class="line"><span class="comment">         1.如果hang_tmout大于exec_tmout，则先将case的内容写到out_file中，然后以hang_tmout</span></span><br><span class="line"><span class="comment">           为timeout，重新执行一次run_target</span></span><br><span class="line"><span class="comment">            a.如果没设置stop_soon，但是返回结果是FAULT_CRASH，则跳转到keep_as_crash；这是因</span></span><br><span class="line"><span class="comment">              为增加超时时间可能会发现崩溃，这么做是为了确保不丢弃这个case</span></span><br><span class="line"><span class="comment">            b.如果设置了stop_soon，或者返回结果不是FAULT_TMOUT，就直接返回keeping</span></span><br><span class="line"><span class="comment">         2.对于其它返回结果，则继续执行，首先拼接路径fn，用于将case写入</span></span><br><span class="line"><span class="comment">         3.令unique_hangs计数器加1</span></span><br><span class="line"><span class="comment">         4.更新last_hang_time为当前时间，然后从switch中break</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (exec_tmout < hang_tmout) {</span><br><span class="line"></span><br><span class="line">        u8 new_fault;</span><br><span class="line">        write_to_testcase(mem, len);</span><br><span class="line">        new_fault = run_target(argv, hang_tmout);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (!stop_soon && new_fault == FAULT_CRASH) </span><br><span class="line">            <span class="keyword">goto</span> keep_as_crash;</span><br><span class="line">        <span class="keyword">if</span> (stop_soon || new_fault != FAULT_TMOUT) </span><br><span class="line">            <span class="keyword">return</span> keeping;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/hangs/id:%06llu,%s"</span>, out_dir, unique_hangs, describe_op(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/hangs/id_%06llu"</span>, out_dir, unique_hangs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_hangs++;</span><br><span class="line"></span><br><span class="line">      last_hang_time = get_cur_time();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* CRASH的处理与超时的处理方式大体相似，除了略有不同的限制并且不需要重新运行测试用例。除此之外</span></span><br><span class="line"><span class="comment">       当在超时处理中增加超时时间重新执行程序导致FAULT_CRASH时，也会进入这里进行处理:</span></span><br><span class="line"><span class="comment">       1.total_crashes计数器加1</span></span><br><span class="line"><span class="comment">       2.如果unique_crashes >= KEEP_UNIQUE_CRASH(能保存的最大数量，这个值在config.h中设</span></span><br><span class="line"><span class="comment">         置为5000)，则直接返回keeping</span></span><br><span class="line"><span class="comment">       3.与超时中的处理类似，如果不是dumb_mode，则调用simplify_trace对trace_bits进行规整；</span></span><br><span class="line"><span class="comment">         接着调用has_new_bits判断这个case是否发现了新的crash路径，若没有就直接返回keeping</span></span><br><span class="line"><span class="comment">       4.如果unique_crashes的值为0，则调用write_crash_readme显示一些crash目录的信息</span></span><br><span class="line"><span class="comment">       5.拼接路径fn，用于后续将case写入</span></span><br><span class="line"><span class="comment">       6.unique_crashes计数器加1</span></span><br><span class="line"><span class="comment">       7.更新last_crash_time和last_crash_execs，然后从switch中break</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line">keep_as_crash:</span><br><span class="line"></span><br><span class="line">      total_crashes++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_crashes >= KEEP_UNIQUE_CRASH) </span><br><span class="line">          <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) {</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        simplify_trace((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        simplify_trace((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!has_new_bits(virgin_crash)) </span><br><span class="line">            <span class="keyword">return</span> keeping;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!unique_crashes) </span><br><span class="line">          write_crash_readme();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/crashes/id:%06llu,sig:%02u,%s"</span>, out_dir,</span><br><span class="line">                        unique_crashes, kill_signal, describe_op(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      fn = alloc_printf(<span class="string">"%s/crashes/id_%06llu_%02u"</span>, out_dir, unique_crashes,</span><br><span class="line">                        kill_signal);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_crashes++;</span><br><span class="line"></span><br><span class="line">      last_crash_time = get_cur_time();</span><br><span class="line">      last_crash_execs = total_execs;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果fault类型是FAULT_ERROR，则直接抛出异常</span></span><br><span class="line"><span class="comment">       其它情况，直接返回keeping */</span></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR: </span><br><span class="line">          FATAL(<span class="string">"Unable to execute target application"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">          <span class="keyword">return</span> keeping;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果执行到这，显然是想保存导致crash或者hang的case，这里创建并打开fn路径指定的文件，并将</span></span><br><span class="line"><span class="comment">     case的内容写入文件，最后返回keeping(这里keeping好像还是0，因此不会加入queue?)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">"Unable to create '%s'"</span>, fn);</span><br><span class="line">  ck_write(fd, mem, len, fn);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> keeping;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="simplify-trace"><a href="#simplify-trace" class="headerlink" title="simplify_trace"></a>simplify_trace</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用0x80/0x01表示替换原本tuple中表示路径是否被命中的信息，进而简化跟踪；这么做是为了在每次crash</span></span><br><span class="line"><span class="comment">   或timeout被调用时加快执行速度。这里依旧只分析64位的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 simplify_lookup[<span class="number">256</span>] = { </span><br><span class="line">  [<span class="number">0</span>]         = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">1</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simplify_trace</span><span class="params">(u64* mem)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.8个字节为1组，每轮循环依次从trace_bits取出</span></span><br><span class="line"><span class="comment">     2.如果mem不为空（即这一组8个字节中至少有一个字节有值），则利用simplify_lookup表对其进行规整。</span></span><br><span class="line"><span class="comment">       如果路径没有命中，就设置为0x1；如果路径命中了，就设置为0x80</span></span><br><span class="line"><span class="comment">     3.否则，将mem设置为0x0101010101010101，即所有8个字节代表的路径都没有命中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  u32 i = MAP_SIZE >> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) {</span><br><span class="line">      u8* mem8 = (u8*)mem;</span><br><span class="line"></span><br><span class="line">      mem8[<span class="number">0</span>] = simplify_lookup[mem8[<span class="number">0</span>]];</span><br><span class="line">      mem8[<span class="number">1</span>] = simplify_lookup[mem8[<span class="number">1</span>]];</span><br><span class="line">      mem8[<span class="number">2</span>] = simplify_lookup[mem8[<span class="number">2</span>]];</span><br><span class="line">      mem8[<span class="number">3</span>] = simplify_lookup[mem8[<span class="number">3</span>]];</span><br><span class="line">      mem8[<span class="number">4</span>] = simplify_lookup[mem8[<span class="number">4</span>]];</span><br><span class="line">      mem8[<span class="number">5</span>] = simplify_lookup[mem8[<span class="number">5</span>]];</span><br><span class="line">      mem8[<span class="number">6</span>] = simplify_lookup[mem8[<span class="number">6</span>]];</span><br><span class="line">      mem8[<span class="number">7</span>] = simplify_lookup[mem8[<span class="number">7</span>]];</span><br><span class="line">    } <span class="keyword">else</span> </span><br><span class="line">        *mem = <span class="number">0x0101010101010101</span>ULL;</span><br><span class="line">    mem++;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h3><p>在fuzz_one中(5119行)被调用</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在进行确定性检查(deterministic checks)时，修剪所有新的测试用例以节省周期。微调器将使用</span></span><br><span class="line"><span class="comment">   1/1024~1/16之间的一个二次幂增量，使得执行周期变得简短而又温馨，至少它很简短。这里的参数</span></span><br><span class="line"><span class="comment">   in_buf，实际上就是calibrate_case中的参数use_mem，也就是q->len */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">trim_case</span><span class="params">(<span class="keyword">char</span>** argv, struct queue_entry* q, u8* in_buf)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">static</span> u8 clean_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  needs_write = <span class="number">0</span>, fault = <span class="number">0</span>;</span><br><span class="line">  u32 trim_exec = <span class="number">0</span>;</span><br><span class="line">  u32 remove_len;</span><br><span class="line">  u32 len_p2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 虽然当检测到可变行为时，修剪器的用处不大，但它仍然会在一定程度上起作用，所以我们不检查这个</span></span><br><span class="line"><span class="comment">     1.如果case的len小于5字节，就不需要修剪，直接返回</span></span><br><span class="line"><span class="comment">     2.令stage_name指向tmp数组首位；修剪字节计数器bytes_trim_in的值增加q->len个大小</span></span><br><span class="line"><span class="comment">     3.选择初始块len_p2的长度，其值是大于等于q->len的第一个2的幂次(如果len是666，len_p2就是1024)</span></span><br><span class="line"><span class="comment">     4.设置起始步长remove_len的值，从"len_p2/16"和"4"中选取最大的那个。这里用到的两个宏都可在</span></span><br><span class="line"><span class="comment">       config.h中找到</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (q->len < <span class="number">5</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_name = tmp;</span><br><span class="line">  bytes_trim_in += q->len;</span><br><span class="line"></span><br><span class="line">  len_p2 = next_p2(q->len);</span><br><span class="line"></span><br><span class="line">  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 进入循环，直至步长remove_len(每轮循环会除2)小于终止步长MAX(len_p2/1024, 4)时停止：</span></span><br><span class="line"><span class="comment">     1.remove_pos保存当前的remove_len</span></span><br><span class="line"><span class="comment">     2.格式化remove_len到tmp中，相当于令stage_name = "trim remove_len/remove_len"，需要注意一点</span></span><br><span class="line"><span class="comment">       前面已经将stage_name指向了tmp的首地址</span></span><br><span class="line"><span class="comment">     3.将stage_cur置零，stage_max设置为q->len/remove_len(如果remove_len是用TRIM_START_SETPS</span></span><br><span class="line"><span class="comment">       计算出来的，那么这个值为8~15之间的一个数)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">while</span> (remove_len >= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) {</span><br><span class="line">    u32 remove_pos = remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">"trim %s/%s"</span>, DI(remove_len), DI(remove_len));</span><br><span class="line"></span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = q->len / remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进入内层循环，每次前进remove_len个步长，直至整个文件都遍历完(remove_pos >= q->len)为止</span></span><br><span class="line"><span class="comment">       1.设置trim_avail为一块较小的片段长度</span></span><br><span class="line"><span class="comment">       2.调用write_with_gap()，具体操作为，由in_buf中remove_pos处开始，向后跳过remove_len个字</span></span><br><span class="line"><span class="comment">         节，写入到.cur_input里</span></span><br><span class="line"><span class="comment">       3.调用run_target运行一次目标程序，trim_execs计数器加1，然后处理潜在的错误（可以理解为，将</span></span><br><span class="line"><span class="comment">         case删除了一小段。然后再执行下，看看对跟踪是否产生影响，若无影响，则保将删除后的case，尽管</span></span><br><span class="line"><span class="comment">         这么做对可变路径variable-path来说并不完美）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (remove_pos < q->len) {</span><br><span class="line"></span><br><span class="line">      u32 trim_avail = MIN(remove_len, q->len - remove_pos);</span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      write_with_gap(in_buf, q->len, remove_pos, trim_avail);</span><br><span class="line"></span><br><span class="line">      fault = run_target(argv, exec_tmout);</span><br><span class="line">      trim_execs++;</span><br><span class="line">      <span class="keyword">if</span> (stop_soon || fault == FAULT_ERROR) </span><br><span class="line">          <span class="keyword">goto</span> abort_trimming;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 4.用当前的trace_bits计算出一个哈希值，保存到cksum中。（注意，原生的AFL在此处不会跟踪崩溃</span></span><br><span class="line"><span class="comment">           或挂起）</span></span><br><span class="line"><span class="comment">         5.判断cksum和q->exec_cksum的值是否相等，即将case删减一小段后是否对trace产生影响：</span></span><br><span class="line"><span class="comment">            a.如果相等，说明不产生影响，则：</span></span><br><span class="line"><span class="comment">               1).计算in_buf中从remove_pos开始，到结尾剩余的长度（删除trim_avail后），并将其赋给</span></span><br><span class="line"><span class="comment">                  局部变量move_tail</span></span><br><span class="line"><span class="comment">               2).重新设置q->len和len_p2，即从case删除trim_avail剩余的长度，这里的对len_p2的修</span></span><br><span class="line"><span class="comment">                  改可能会触发外层循环的终止条件</span></span><br><span class="line"><span class="comment">               3).调用memmove，安全的将case中trim_avail片段之后，move_tail大小的内容附加到原先从</span></span><br><span class="line"><span class="comment">                  trim_avail开始的位置</span></span><br><span class="line"><span class="comment">               4).如果未设置needs_write，则将其置1；然后用一个干净的clean_trace保存trace_bits中</span></span><br><span class="line"><span class="comment">                  的值，一旦完成修剪操作后，updata_bitmap_score就会根据trace_bits和偏好因子进一</span></span><br><span class="line"><span class="comment">                  步筛选queue，并对trace_bits进行压缩</span></span><br><span class="line"><span class="comment">            b.如果不相等，说明case删减会对trace产生影响，则这段不删减，remove_pos加上步长的值</span></span><br><span class="line"><span class="comment">         6.由于trim过程可能比较慢，所以如果达到stats_update_freq更新周期，就调用show_stats()刷新</span></span><br><span class="line"><span class="comment">           一次并显示界面（由于stats_update_freq的值为1，所以时不时就刷新一次）；同时，trim_exec</span></span><br><span class="line"><span class="comment">           的值自增1，表示执行了一次修剪。</span></span><br><span class="line"><span class="comment">         7.stage_cur的值加1，然后进入下一轮内层循环</span></span><br><span class="line"><span class="comment">         8.令循环步长remove_len除2，然后进入下一轮外层循环</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum == q->exec_cksum) {</span><br><span class="line">        u32 move_tail = q->len - remove_pos - trim_avail;</span><br><span class="line"></span><br><span class="line">        q->len -= trim_avail;</span><br><span class="line">        len_p2  = next_p2(q->len);</span><br><span class="line"></span><br><span class="line">        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, </span><br><span class="line">                move_tail);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needs_write) {</span><br><span class="line">          needs_write = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> </span><br><span class="line">          remove_pos += remove_len;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(trim_exec++ % stats_update_freq)) </span><br><span class="line">          show_stats();</span><br><span class="line">      stage_cur++;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    remove_len >>= <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果对in_buf做了修改（说明trim后不影响，不然就不修改了），那也要对磁盘中保存的case版本进行更新：</span></span><br><span class="line"><span class="comment">     1.删除原来的q->fname，创建一个新的q->fname，将in_buf里的内容写入q-></span></span><br><span class="line"><span class="comment">     2.用clean_trace恢复trace_bits的值；调用update_bitmap_score根据偏好因子更新bitmap</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (needs_write) {</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    unlink(q->fname); <span class="comment">/* ignore errors */</span></span><br><span class="line">    fd = <span class="built_in">open</span>(q->fname, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>)</span><br><span class="line">        PFATAL(<span class="string">"Unable to create '%s'"</span>, q->fname);</span><br><span class="line">    ck_write(fd, in_buf, q->len, q->fname);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);</span><br><span class="line">    update_bitmap_score(q);</span><br><span class="line">  }</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 对fault的一些处理，字节修剪计数器bytes_trim_out的值增加q->len个大小 */</span></span><br><span class="line">abort_trimming:</span><br><span class="line">    </span><br><span class="line">  bytes_trim_out += q->len;</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a>calculate_score</h3><p>在fuzz_one中(5143行)被调用</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据queue entry的执行速度、覆盖到的path数和路径深度来评估出一个得分，这个得分perf_score在后面havoc的    时候使用 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">calculate_score</span><span class="params">(struct queue_entry* q)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u32 avg_exec_us = total_cal_us / total_cal_cycles;</span><br><span class="line">  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;</span><br><span class="line">  u32 perf_score = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 基于case的执行速度对得分perf_score进行调整，将case执行速度与系数相乘（0.1~4）后再与平均值</span></span><br><span class="line"><span class="comment">    （total_cal_us/total_cal_cycles）进行对比。由于快速输入的fuzz成本更低，因而会给他们更多</span></span><br><span class="line"><span class="comment">     的air time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (q->exec_us * <span class="number">0.1</span> > avg_exec_us) perf_score = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->exec_us * <span class="number">0.25</span> > avg_exec_us) perf_score = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->exec_us * <span class="number">0.5</span> > avg_exec_us) perf_score = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->exec_us * <span class="number">0.75</span> > avg_exec_us) perf_score = <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->exec_us * <span class="number">4</span> < avg_exec_us) perf_score = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->exec_us * <span class="number">3</span> < avg_exec_us) perf_score = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->exec_us * <span class="number">2</span> < avg_exec_us) perf_score = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 基于case的bitmap覆盖率对得分perf_score进行调整，原理是更好的覆盖率可以转化为更好的目标；</span></span><br><span class="line"><span class="comment">     具体操作与上面基于执行速度的类似，这里不展开</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (q->bitmap_size * <span class="number">0.3</span> > avg_bitmap_size) perf_score *= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->bitmap_size * <span class="number">0.5</span> > avg_bitmap_size) perf_score *= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->bitmap_size * <span class="number">0.75</span> > avg_bitmap_size) perf_score *= <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->bitmap_size * <span class="number">3</span> < avg_bitmap_size) perf_score *= <span class="number">0.25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->bitmap_size * <span class="number">2</span> < avg_bitmap_size) perf_score *= <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q->bitmap_size * <span class="number">1.5</span> < avg_bitmap_size) perf_score *= <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 基于handicap调整得分perf_score，handicap表示相对于其它case，这个case迟了多久我们才能了解它</span></span><br><span class="line"><span class="comment">     的路径（这个值仅在calibrate_case中被设置，初始为0，后为queue_cycle-1），迟到者可以多跑一段时</span></span><br><span class="line"><span class="comment">     间，直到赶上其他人。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (q->handicap >= <span class="number">4</span>) {</span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    q->handicap -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (q->handicap) {</span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    q->handicap--;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 基于输入深度对得分最出最终调整，这里假设在进行模糊测试时，更深入的测试用例更有可能发现传统模拟器无</span></span><br><span class="line"><span class="comment">     法发现的东西。这个cur_depth是一个全局变量，初始为0；每次add_to_queue时，会设置cur_depth+1：</span></span><br><span class="line"><span class="comment">     1.处理输入时：</span></span><br><span class="line"><span class="comment">       在read_testcases时会调用add_to_queue，此时所有的input_case的q->depth都会被设置为1</span></span><br><span class="line"><span class="comment">     2.fuzz_one时：</span></span><br><span class="line"><span class="comment">       在fuzz_one时，会先设置cur_depth为当前queue的q->depth，然后这个queue经过mutate之后调用</span></span><br><span class="line"><span class="comment">       save_if_interesting；如果是interesting_case，就会被add_to_queue，此时就建立起了queue</span></span><br><span class="line"><span class="comment">       之间的关联关系，所以由当前queue经过mutate后加入的新queue，深度都在当前queue的基础上再增加</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">switch</span> (q->depth) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">3</span>:   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> ... <span class="number">7</span>:   perf_score *= <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">13</span>:  perf_score *= <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span> ... <span class="number">25</span>: perf_score *= <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:        perf_score *= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 确保得分perf_score不会超过限制，然后返回得分 */</span></span><br><span class="line">  <span class="keyword">if</span> (perf_score > HAVOC_MAX_MULT * <span class="number">100</span>) </span><br><span class="line">      perf_score = HAVOC_MAX_MULT * <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> perf_score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h3><p>在fuzz_one中(5188行)多次被调用，首次出现在5188行</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 编写修改后的testcase，运行程序，处理结果以及异常情况。如需退出，则返回1，这同样是fuzz_one中</span></span><br><span class="line"><span class="comment">   的一个辅助函数。这里的out_buf，同样可以理解为use_mem，参考前面的trim_case */</span></span><br><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="keyword">char</span>** argv, u8* out_buf, u32 len)</span> </span>{</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果设置了post_handler（在setup_post中设置），就通过post_handler处理一下out_buf；处理</span></span><br><span class="line"><span class="comment">     后判断out_buf及len的值，若有一个为0，则直接返回0。sakura指出 "如果需要对变异完的queue，做</span></span><br><span class="line"><span class="comment">     一层wrapper再写入的时候，这里其实很有价值" */</span></span><br><span class="line">  <span class="keyword">if</span> (post_handler) {</span><br><span class="line">    out_buf = post_handler(out_buf, &len);</span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.调用write_to_testcase将当前case写入到out_file</span></span><br><span class="line"><span class="comment">     2.执行一次run_target</span></span><br><span class="line"><span class="comment">     3.判断fault类型：</span></span><br><span class="line"><span class="comment">        a.如果是FAULT_TMOUT。则令连续超时数计数器subseq_tmouts的值加1，如果大于TMOUT_LIMIT</span></span><br><span class="line"><span class="comment">         （默认250），则令当前cycle被抛弃inputs计数器cur_skipped_paths的值加1；然后直接返回1</span></span><br><span class="line"><span class="comment">        b.其它fault类型，则将subseq_tmouts置零</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  write_to_testcase(out_buf, len);</span><br><span class="line">  fault = run_target(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) {</span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ > TMOUT_LIMIT) {</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> </span><br><span class="line">      subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果用户通过SIGUSR1来请求抛弃当前的input，则会设置skip_requested值；若设置了该值，则：</span></span><br><span class="line"><span class="comment">     1.将skip_requested清零</span></span><br><span class="line"><span class="comment">     2.令当前cycle被抛弃inputs计数器cur_skipped_paths的值加1</span></span><br><span class="line"><span class="comment">     3.返回1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) {</span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接下来处理FAULT_ERROR：</span></span><br><span class="line"><span class="comment">     1.调用一次save_if_interesting，如果返回1，即该case被认为是"有趣的"，则queued_discovered加1</span></span><br><span class="line"><span class="comment">     2.如果进入了更新周期，则调用show_stats更新展示界面</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  queued_discovered += save_if_interesting(argv, out_buf, len, fault);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">      show_stats();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="choose-block-len"><a href="#choose-block-len" class="headerlink" title="choose_block_len"></a>choose_block_len</h3><p>在fuzz_one中多次被调用，首次出现在6352行</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该函数用于帮助fuzz_one中的块操作选择随机块的长度，会返回一个大于0的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">choose_block_len</span><span class="params">(u32 limit)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.设置rlim的值为queue_cycle和3中更小的那一个</span></span><br><span class="line"><span class="comment">     2.如果run_over10m为0（这个值表示是否超时超过10min），则设置rlim的值为1</span></span><br><span class="line"><span class="comment">     3.接下来进入switch语句，对不同分支进行判断。这里的UR定义在afl-fuzz.c的371行，用于生成一个（范围</span></span><br><span class="line"><span class="comment">       在0~rlim-1）随机数：</span></span><br><span class="line"><span class="comment">          case 0: 设置min_value为1，max_value为32</span></span><br><span class="line"><span class="comment">          case 1: 设置min_value为32，max_value为128</span></span><br><span class="line"><span class="comment">          default: 有9/10的概率，设置min_value为128，max_value为1500</span></span><br><span class="line"><span class="comment">                   有1/10的概率，设置min_value为1500，max_value为32768</span></span><br><span class="line"><span class="comment">     4.如果min_value >= 传入的参数limit，则设置min_value的值为0</span></span><br><span class="line"><span class="comment">     5.min_value加上一个随机值作为返回值，因为返回值 >= 1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  u32 min_value, max_value;</span><br><span class="line">  u32 rlim = MIN(queue_cycle, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!run_over10m) </span><br><span class="line">      rlim = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (UR(rlim)) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  min_value = <span class="number">1</span>;</span><br><span class="line">             max_value = HAVOC_BLK_SMALL;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  min_value = HAVOC_BLK_SMALL;</span><br><span class="line">             max_value = HAVOC_BLK_MEDIUM;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">             <span class="keyword">if</span> (UR(<span class="number">10</span>)) {</span><br><span class="line">               min_value = HAVOC_BLK_MEDIUM;</span><br><span class="line">               max_value = HAVOC_BLK_LARGE;</span><br><span class="line"></span><br><span class="line">             } <span class="keyword">else</span> {</span><br><span class="line">               min_value = HAVOC_BLK_LARGE;</span><br><span class="line">               max_value = HAVOC_BLK_XL;</span><br><span class="line">             }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (min_value >= limit) </span><br><span class="line">      min_value = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> min_value + UR(MIN(max_value, limit) - min_value + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h2><p>AFL中最长的函数(4999~6690)，也是fuzz执行流程中最核心函数。这里按照阶段分布展开分析</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>这部分主要是fuzz前最后的一些准备。包括了一些变量的初始化，映射case等，以及CALIBRATION阶段、TRIMMING阶段和PERFORMANCE SCORE阶段这三个比较简短的准备阶段</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take the current entry from the queue, fuzz it for a while. This</span></span><br><span class="line"><span class="comment">   function is a tad too long... returns 0 if fuzzed successfully, 1 if</span></span><br><span class="line"><span class="comment">   skipped or bailed out. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用fuzz_one对queue_cur进行一次变异测试（fuzz_one并不一定真的执行当前queue_cur，</span></span><br><span class="line"><span class="comment">   它有一定的策略；如果不执行，就直接返回1，否则返回0） */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">fuzz_one</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>{</span><br><span class="line"></span><br><span class="line">  s32 len, fd, temp_len, i, j;</span><br><span class="line">  u8  *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = <span class="number">0</span>;</span><br><span class="line">  u64 havoc_queued,  orig_hit_cnt, new_hit_cnt;</span><br><span class="line">  u32 splice_cycle = <span class="number">0</span>, perf_score = <span class="number">100</span>, orig_perf, prev_cksum, eff_cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  u8  ret_val = <span class="number">1</span>, doing_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  a_collect[MAX_AUTO_EXTRA];</span><br><span class="line">  u32 a_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IGNORE_FINDS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In IGNORE_FINDS mode, skip any entries that weren't in the</span></span><br><span class="line"><span class="comment">     initial data set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur->depth > <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断pending_favored的值：（这里用到的常量可以在config.h找到）</span></span><br><span class="line"><span class="comment">     1.如果为0，对于queue_cur被fuzz过或者不是favored的，有99%的概率不执行，直接返回1</span></span><br><span class="line"><span class="comment">     2.如果不为0，并且不是dumb_mode、不是favored的、queued_paths>10：</span></span><br><span class="line"><span class="comment">        a.如果queue_cycle大于1，且没有被fuzz过，那么有95%的概率不执行，直接返回1</span></span><br><span class="line"><span class="comment">        b.否则，有75%的概率不执行，直接返回1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (pending_favored) {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">       possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">       cases. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((queue_cur->was_fuzzed || !queue_cur->favored) &&</span><br><span class="line">        UR(<span class="number">100</span>) < SKIP_TO_NEW_PROB) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode && !queue_cur->favored && queued_paths > <span class="number">10</span>) {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">       The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">       lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_cycle > <span class="number">1</span> && !queue_cur->was_fuzzed) {</span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) < SKIP_NFAV_NEW_PROB) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) < SKIP_NFAV_OLD_PROB) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^IGNORE_FINDS */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不是tty模式，输出提示信息并刷新stdout缓冲区 */</span></span><br><span class="line">  <span class="keyword">if</span> (not_on_tty) {</span><br><span class="line">    ACTF(<span class="string">"Fuzzing test case #%u (%u total, %llu uniq crashes found)..."</span>,</span><br><span class="line">         current_entry, queued_paths, unique_crashes);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map the test case into memory. */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 这部分主要将case映射到内存的处理：</span></span><br><span class="line"><span class="comment">     1.设置len为queue_cur->len</span></span><br><span class="line"><span class="comment">     2.打开case对应的文件，并通过mmap映射到内存里，将地址赋值给in_buf和orig_in</span></span><br><span class="line"><span class="comment">     3.分配len大小的内存，并初始化为全0，然后将地址赋值给out_buf</span></span><br><span class="line"><span class="comment">     4.将连续超时计数器subseq_tmout清零</span></span><br><span class="line"><span class="comment">     5.设置cur_depth为queue_cur->depth</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  fd = <span class="built_in">open</span>(queue_cur->fname, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">"Unable to open '%s'"</span>, queue_cur->fname);</span><br><span class="line"></span><br><span class="line">  len = queue_cur->len;</span><br><span class="line"></span><br><span class="line">  orig_in = in_buf = mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orig_in == MAP_FAILED)</span><br><span class="line">      PFATAL(<span class="string">"Unable to mmap '%s'"</span>, queue_cur->fname);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every</span></span><br><span class="line"><span class="comment">     single byte anyway, so it wouldn't give us any performance or memory usage</span></span><br><span class="line"><span class="comment">     benefits. */</span></span><br><span class="line"></span><br><span class="line">  out_buf = ck_alloc_nozero(len);</span><br><span class="line">  subseq_tmouts = <span class="number">0</span>;</span><br><span class="line">  cur_depth = queue_cur->depth;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment">   * CALIBRATION (only if failed earlier on) *</span></span><br><span class="line"><span class="comment">   *******************************************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里开始进入CALIBRATION阶段：</span></span><br><span class="line"><span class="comment">     1.假如当前项有校准错误，并且校准错误次数小于3次，那么就调用calibrate_case再次校准</span></span><br><span class="line"><span class="comment">     2.如果设置了stop_soon，或者res不等于crash_mode：</span></span><br><span class="line"><span class="comment">        a.计数器cur_skipped_paths加1</span></span><br><span class="line"><span class="comment">        b.进入abandon_entry作后续处理</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cur->cal_failed) {</span><br><span class="line"></span><br><span class="line">    u8 res = FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_cur->cal_failed < CAL_CHANCES) {</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Reset exec_cksum to tell calibrate_case to re-execute the testcase</span></span><br><span class="line"><span class="comment">         avoiding the usage of an invalid trace_bits.</span></span><br><span class="line"><span class="comment">         For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span></span><br><span class="line"></span><br><span class="line">      queue_cur->exec_cksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">        FATAL(<span class="string">"Unable to execute target application"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || res != crash_mode) {</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/************</span></span><br><span class="line"><span class="comment">   * TRIMMING *</span></span><br><span class="line"><span class="comment">   ************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里开始进入TRIMMING阶段：</span></span><br><span class="line"><span class="comment">     1.如果不处于dumb_mode，且当前项没有被裁剪：</span></span><br><span class="line"><span class="comment">        a.调用trim_case对queue_cur进行trim</span></span><br><span class="line"><span class="comment">        b.设置queue_cur->trim_done的值为1</span></span><br><span class="line"><span class="comment">        c.重新用queue_cur->len去设置len的值</span></span><br><span class="line"><span class="comment">     2.将in_buf拷贝len个字节到out_buf中（注意in_buf是trim_case的参数，得到了裁剪）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode && !queue_cur->trim_done) {</span><br><span class="line"></span><br><span class="line">    u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">"Unable to execute target application"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) {</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">    queue_cur->trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len != queue_cur->len) </span><br><span class="line">        len = queue_cur->len;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*********************</span></span><br><span class="line"><span class="comment">   * PERFORMANCE SCORE *</span></span><br><span class="line"><span class="comment">   *********************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里开始进入PERFORMANCE SCORE阶段：</span></span><br><span class="line"><span class="comment">     1.对当前项调用calculate_score，算出得分并设置orig_perf和perf_score</span></span><br><span class="line"><span class="comment">     2.如果设置了skip_deterministic，或者当前项被fuzz过，或者passed_det为1（好像也是被fuzz过）</span></span><br><span class="line"><span class="comment">       ，那么跳转到havoc_stage去执行</span></span><br><span class="line"><span class="comment">     3.如果执行路径校验和，超过此主实例的范围，那么也跳转到havoc_stage去执行</span></span><br><span class="line"><span class="comment">     4.若没跳走，设置doing_det的值为1（位于fuzz_one中的一个局部变量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  orig_perf = perf_score = calculate_score(queue_cur);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span></span><br><span class="line"><span class="comment">     this entry ourselves (was_fuzzed), or if it has gone through deterministic</span></span><br><span class="line"><span class="comment">     testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic || queue_cur->was_fuzzed || queue_cur->passed_det)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">     for this master instance. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (master_max && (queue_cur->exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  doing_det = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="SIMPLE-BITFLIP-dictionary-construction-阶段"><a href="#SIMPLE-BITFLIP-dictionary-construction-阶段" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)阶段"></a>SIMPLE BITFLIP (+dictionary construction)阶段</h3><p>在比特反转，根据目标大小的不同，分为了多个不同的阶段：</p>
<ul>
<li>bitflip 1/1 && collect tokens -> 按位取反 && 搜集token</li>
<li>bitflip 2/1 相邻两位进行取反</li>
<li>bitflip 4/1 相邻四位进行取反</li>
<li>bitflip 8/8 && effector map -> 按字节取反 && 构建effector map</li>
<li>bitflip 16/8 连续两byte翻转</li>
<li>bitflip 32/8 连续四byte翻转</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*********************************************</span></span><br><span class="line"><span class="comment">   * SIMPLE BITFLIP (+dictionary construction) *</span></span><br><span class="line"><span class="comment">   *********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里开始进入SIMPLE BITFILP阶段，先来品一下FLIP_BIT这个宏，它的最后一条指令很有味道：</span></span><br><span class="line"><span class="comment">   1.等式右边：</span></span><br><span class="line"><span class="comment">      a.(_bf) & 7)相当于对8取模，得到0~7中的一个数</span></span><br><span class="line"><span class="comment">      b.128的二进制为10000000</span></span><br><span class="line"><span class="comment">      c.128 >> ((_bf) & 7)也就是在00000000这8个bit位上中的某个位置1，具体哪一位由_bf决定</span></span><br><span class="line"><span class="comment">   2.等式左边：</span></span><br><span class="line"><span class="comment">      a.(_bf) >> 3，是对_bf除8，想一想，这里为什么是除8而不是模8？其实算一下就能明白，假设_bf的</span></span><br><span class="line"><span class="comment">        取值范围是0~7，那么模8后得到的值的范围也是0~7，而除8得到的值只有0。而1个字节又有8bit，假</span></span><br><span class="line"><span class="comment">        设被除数有两个字节/16bit，除8意味着，前8次计算，都指向第一个字节的位置，后8次计算，都指向</span></span><br><span class="line"><span class="comment">        第二个字节的位置。这样是不是就好理解了。然后再往下看</span></span><br><span class="line"><span class="comment">      b._arf[(_bf) >> 3]，_arf是u8*类型，而u8就是char类型，也就是1字节。因此这里(_bf) >> 3</span></span><br><span class="line"><span class="comment">        得到的就是在_arf数组里的下标。再往后看</span></span><br><span class="line"><span class="comment">      c._arf[(_bf) >> 3] ^= (128 >> ((_bf) & 7))，前面提到，(_bf) >> 3，会导致连续（假设</span></span><br><span class="line"><span class="comment">        在循环中依次递增_bf）8次指向某一个字节的位置，而等式右边刚好可以在8次内将单个字节上的8个比</span></span><br><span class="line"><span class="comment">        特依次置位。之后后再进行异或运算。</span></span><br><span class="line"><span class="comment">    3.因此可以得出结论，这个FLIP_BIT就是对参数_ar指向的数组每个字节的每个比特进行翻转；而参数_b必</span></span><br><span class="line"><span class="comment">      须是一个8的倍数的数。这部分仍未理解明白可以去参考hollk师傅的文章，链接贴在文末</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLIP_BIT(_ar, _b) do { \</span></span><br><span class="line">    u8* _arf = (u8*)(_ar); \</span><br><span class="line">    u32 _bf = (_b); \</span><br><span class="line">    _arf[(_bf) >> <span class="number">3</span>] ^= (<span class="number">128</span> >> ((_bf) & <span class="number">7</span>)); \</span><br><span class="line">  } <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Single walking bit. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 理解了FLIP_BIT这个宏，下面来看bitflip的每个阶段，首先是bitflip 1/1：</span></span><br><span class="line"><span class="comment">     1.设置循环次数stage_max为len << 3，因为len得到的是大小是字节，乘8后就可以在循环中对每个字节</span></span><br><span class="line"><span class="comment">       的每个比特进行翻转</span></span><br><span class="line"><span class="comment">     2.设置stage_name为bitflip 1/1</span></span><br><span class="line"><span class="comment">     3.进入循环，通过FLIP_BIT依次对out_buf的每个位翻转</span></span><br><span class="line"><span class="comment">     4.然后执行一次common_fuzz_stuff</span></span><br><span class="line"><span class="comment">     5.然后再调用FLIP_BIT翻转回来</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_short = <span class="string">"flip1"</span>;</span><br><span class="line">  stage_max   = len << <span class="number">3</span>;</span><br><span class="line">  stage_name  = <span class="string">"bitflip 1/1"</span>;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  prev_cksum = queue_cur->exec_cksum;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur < stage_max; stage_cur++) {</span><br><span class="line">      </span><br><span class="line">    stage_cur_byte = stage_cur >> <span class="number">3</span>;</span><br><span class="line">      </span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) </span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While flipping the least significant bit in every byte, pull of an extra</span></span><br><span class="line"><span class="comment">       trick to detect possible syntax tokens. In essence, the idea is that if</span></span><br><span class="line"><span class="comment">       you have a binary blob like this:</span></span><br><span class="line"><span class="comment">       xxxxxxxxIHDRxxxxxxxx</span></span><br><span class="line"><span class="comment">       ...and changing the leading and trailing bytes causes variable or no</span></span><br><span class="line"><span class="comment">       changes in program flow, but touching any character in the "IHDR" string</span></span><br><span class="line"><span class="comment">       always produces the same, distinctive path, it's highly likely that</span></span><br><span class="line"><span class="comment">       "IHDR" is an atomically-checked magic value of special significance to</span></span><br><span class="line"><span class="comment">       the fuzzed format.</span></span><br><span class="line"><span class="comment">       We do this here, rather than as a separate stage, because it's a nice</span></span><br><span class="line"><span class="comment">       way to keep the operation approximately "free" (i.e., no extra execs).</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       Empirically, performing the check when flipping the least significant bit</span></span><br><span class="line"><span class="comment">       is advantageous, compared to doing it at the time of more disruptive</span></span><br><span class="line"><span class="comment">       changes, where the program flow may be affected in more violent ways.</span></span><br><span class="line"><span class="comment">       The caveat is that we won't generate dictionaries in the -d mode or -S</span></span><br><span class="line"><span class="comment">       mode - but that's probably a fair trade-off.</span></span><br><span class="line"><span class="comment">       This won't work particularly well with paths that exhibit variable</span></span><br><span class="line"><span class="comment">       behavior, but fails gracefully, so we'll carry out the checks anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在进行bitflip 1/1变异时，对于每个字节的最低有效位（least significant bit）的翻转还进</span></span><br><span class="line"><span class="comment">       行了额外的处理：</span></span><br><span class="line"><span class="comment">       1.假设有一个字符串"xxxxxxxxIHDRxxxxxxxx"</span></span><br><span class="line"><span class="comment">       2.更改前导字节和尾随字节会导致程序流发生变化或没有变化，但是触摸“IHDR”字符串中的任何字符总</span></span><br><span class="line"><span class="comment">         是会产生相同的（即程序的执行路径相同），并且独特（与原始执行路径不同）的路径，那么就把这一</span></span><br><span class="line"><span class="comment">         段连续的bytes判断是一个token</span></span><br><span class="line"><span class="comment">       3.sakura师傅举了另一个例子："对于SQL的SELECT *，如果SELECT被破坏，则肯定和正确的路径不</span></span><br><span class="line"><span class="comment">         一致，而被破坏之后的路径却肯定是一样的，比如AELECT和SBLECT，显然都是无意义的，而只有不</span></span><br><span class="line"><span class="comment">         破坏token，才有可能出现和原始执行路径一样的结果，所以AFL在这里就是在猜解关键字token"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode && (stage_cur & <span class="number">7</span>) == <span class="number">7</span>) {</span><br><span class="line"></span><br><span class="line">      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> && cksum == prev_cksum) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">           final character and force output. */</span></span><br><span class="line">        <span class="comment">/* 1.如果路径没变，当前token数量小于32(MAX_AUTO_EXTRA默认为32)，则尝试收集字符串，将</span></span><br><span class="line"><span class="comment">             当前字符作为token拼接到a_collect[]数组中</span></span><br><span class="line"><span class="comment">           2.如果已经达到文件末尾，但仍在收集字符串，则获取最后一个字符并强制输出</span></span><br><span class="line"><span class="comment">           3.如果当前token数量小于32且大于3（token默认的数量范围），调用maybe_add_auto将累计</span></span><br><span class="line"><span class="comment">             的a_collect[]数组中的内容添加到a_extras[]数组中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (a_len < MAX_AUTO_EXTRA) </span><br><span class="line">            a_collect[a_len] = out_buf[stage_cur >> <span class="number">3</span>];</span><br><span class="line">        a_len++;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">           worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line">        <span class="comment">/* 1.如果路径变了，调用maybe_add_auto判断是否收集这个case到queue中</span></span><br><span class="line"><span class="comment">           2.同时将a_collect中的token添加到a_extras数组中 */</span></span><br><span class="line">        <span class="keyword">if</span> (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)</span><br><span class="line">          maybe_add_auto(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">        a_len = <span class="number">0</span>;</span><br><span class="line">        prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">         any difference - we don't want no-op tokens. */</span></span><br><span class="line">      <span class="comment">/* 1.如果当前路径与原始路径不相同，这说明可能是因为token被破坏导致与原始执行路径不符</span></span><br><span class="line"><span class="comment">         2.所以需要保证位翻转后确实有所作为，才会收集这个字符串token，因为我们不想要无操作的token</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur->exec_cksum) {</span><br><span class="line">        <span class="keyword">if</span> (a_len < MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur >> <span class="number">3</span>];        </span><br><span class="line">        a_len++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.stage_finds[STAGE_FLIP1]统计在这个阶段（这里是bitflip 1/1）新发现的路径和Crash的总和</span></span><br><span class="line"><span class="comment">     2.stage_cycles[STAGE_FLIP1]统计在这个阶段执行target的总次数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP1] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two walking bits. */</span></span><br><span class="line">  <span class="comment">/* 1.bitflip 2/1阶段与bitflip 1/1原理相同，只不过是连续翻转相邻的两位bit</span></span><br><span class="line"><span class="comment">     2.结果分别保存到 stage_finds[STAGE_FLIP2] 和 stage_cycles[STAGE_FLIP2] 中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"bitflip 2/1"</span>;</span><br><span class="line">  stage_short = <span class="string">"flip2"</span>;</span><br><span class="line">  stage_max   = (len << <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur < stage_max; stage_cur++) {</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur >> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP2] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Four walking bits. */</span></span><br><span class="line">  <span class="comment">/* 同理，bitflip 4/1，连续翻转四位并记录 */</span></span><br><span class="line">  stage_name  = <span class="string">"bitflip 4/1"</span>;</span><br><span class="line">  stage_short = <span class="string">"flip4"</span>;</span><br><span class="line">  stage_max   = (len << <span class="number">3</span>) - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur < stage_max; stage_cur++) {</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur >> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP4] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接下来将进入bitflip 8/8这个阶段，在这个阶段就不需要用前面的FLIP_BIT进行翻转了，而是</span></span><br><span class="line"><span class="comment">     直接将0xFF(11111111)与字节进行异或来实现。在这个过程中，还会生成一个非常重要的数组——</span></span><br><span class="line"><span class="comment">     effector map[]，下面对原理进行阐述：（这里引用sakura和hollk的分析结论）</span></span><br><span class="line"><span class="comment">     1.在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector</span></span><br><span class="line"><span class="comment">       map中标记为1，即有效的；否则标记为0，即无效的</span></span><br><span class="line"><span class="comment">     2.这么做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能</span></span><br><span class="line"><span class="comment">       属于"data"，而不是"metadata"（例如size, flag等），对整个fuzzing的意义不大。所以</span></span><br><span class="line"><span class="comment">       ，在随后的一些变异中，会参考effector map[]，通过stage_max--的方式跳过无效的byte，</span></span><br><span class="line"><span class="comment">       从而节省执行资源</span></span><br><span class="line"><span class="comment">     3.但某些情况并不会检测有效字符，例如在dumb_mode模式下或者指定fuzzer的情况下，此时所有</span></span><br><span class="line"><span class="comment">       字符都有可能进行变异</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Effector map setup. These macros calculate:</span></span><br><span class="line"><span class="comment">     EFF_APOS      - position of a particular file offset in the map.</span></span><br><span class="line"><span class="comment">     EFF_ALEN      - length of a map with a particular number of bytes.</span></span><br><span class="line"><span class="comment">     EFF_SPAN_ALEN - map span for a sequence of bytes.</span></span><br><span class="line"><span class="comment">     Effector map 一些用于计算的宏的设置</span></span><br><span class="line"><span class="comment">     EFF_APOS      - 计算特定文件偏移量在map中的位置，EFF_MAP_SCALE2设置为3</span></span><br><span class="line"><span class="comment">     EFF_ALEN      - 具有特定字节数的map的长度</span></span><br><span class="line"><span class="comment">     EFF_SPAN_ALEN - 一个字节序列的map范围</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_APOS(_p)          ((_p) >> EFF_MAP_SCALE2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_REM(_x)           ((_x) & ((1 << EFF_MAP_SCALE2) - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize effector map for the next step (see comments below). Always</span></span><br><span class="line"><span class="comment">     flag first and last byte as doing something. */</span></span><br><span class="line">  <span class="comment">/* 初始化effector map：</span></span><br><span class="line"><span class="comment">     1.初始化大小为case字节长度的空间，赋值给eff_map</span></span><br><span class="line"><span class="comment">     2.将eff_map第一个字节设置为1</span></span><br><span class="line"><span class="comment">     3.如果case的长度大于等于9字节：</span></span><br><span class="line"><span class="comment">        a.将eff_map最后一个字节设置为1</span></span><br><span class="line"><span class="comment">        b.令计数器eff_cnt加1（这是一个在fuzz_one开始处的一个局部变量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  eff_map    = ck_alloc(EFF_ALEN(len));</span><br><span class="line">  eff_map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (EFF_APOS(len - <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">    eff_map[EFF_APOS(len - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    eff_cnt++;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Walking byte. */</span></span><br><span class="line">  <span class="comment">/* 下面正式进入bitflip 8/8阶段，也就是单字节翻转阶段：</span></span><br><span class="line"><span class="comment">     1.设置stage_name为"bitflip 8/8"   </span></span><br><span class="line"><span class="comment">     2.设置stage_max为len，这里没有乘8，因为是对字节进行翻转</span></span><br><span class="line"><span class="comment">     3.out_buf[stage_cur] ^= 0xFF，这里直接对字节进行翻转</span></span><br><span class="line"><span class="comment">     4.调用common_fuzz_stuff对变异后数据进行测试，记录interesting，若返回1则跳转到</span></span><br><span class="line"><span class="comment">       abandon_entry去处理</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"bitflip 8/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"flip8"</span>;</span><br><span class="line">  stage_max   = len;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur < stage_max; stage_cur++) {</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = stage_cur;</span><br><span class="line"></span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) </span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We also use this stage to pull off a simple trick: we identify</span></span><br><span class="line"><span class="comment">       bytes that seem to have no effect on the current execution path</span></span><br><span class="line"><span class="comment">       even when fully flipped - and we skip them during more expensive</span></span><br><span class="line"><span class="comment">       deterministic stages, such as arithmetics or known ints.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">       我们还在这个阶段实现了一个简单的技巧：我们识别即使在完全翻转时似乎对当前执行路径</span></span><br><span class="line"><span class="comment">       没有影响的字节；这样在更昂贵的确定性fuzzing阶段可以跳过它们（例如算数或已知整数）</span></span><br><span class="line"><span class="comment">       1.如果eff_map[某个字节]对应的值为0</span></span><br><span class="line"><span class="comment">       2.如果不是dumb_mode且case的len大于等于128，则计算校验值cksum</span></span><br><span class="line"><span class="comment">       3.如果是dumb_mode，就不计算了，直接对原先的cksum取反</span></span><br><span class="line"><span class="comment">       4.最后判断cksum与原先的cksum是否相同，若不同说明发现了新的路径，则设置eff_map</span></span><br><span class="line"><span class="comment">         这个字节对应的值为1</span></span><br><span class="line"><span class="comment">       5.判断结束后，将先前取反的字节复位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(stage_cur)]) {</span><br><span class="line"></span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">         without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode && len >= EFF_MIN_LEN)</span><br><span class="line">        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cksum = ~queue_cur->exec_cksum;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum != queue_cur->exec_cksum) {</span><br><span class="line">        eff_map[EFF_APOS(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">        eff_cnt++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">      </span><br><span class="line">    out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the effector map is more than EFF_MAX_PERC dense, just flag the</span></span><br><span class="line"><span class="comment">     whole thing as worth fuzzing, since we wouldn't be saving much time</span></span><br><span class="line"><span class="comment">     anyway.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     如果effector map的密度超过EFF_MAX_PERC（设定为90），只需要将整件事标记为值得</span></span><br><span class="line"><span class="comment">     进行模糊测试（即将eff_map所有字节设置为1），因为无论如何我们都不会节省太多时间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (eff_cnt != EFF_ALEN(len) &&</span><br><span class="line">      eff_cnt * <span class="number">100</span> / EFF_ALEN(len) > EFF_MAX_PERC) {</span><br><span class="line">    <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, EFF_ALEN(len));</span><br><span class="line">    blocks_eff_select += EFF_ALEN(len);</span><br><span class="line"></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    blocks_eff_select += eff_cnt;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  blocks_eff_total += EFF_ALEN(len);</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP8] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two walking bytes. */</span></span><br><span class="line">  <span class="comment">/* 接下来进入bitflip 16/8阶段，即双字节翻转阶段，这部分原理与单字节翻转类似，但有以下</span></span><br><span class="line"><span class="comment">     几点不同：</span></span><br><span class="line"><span class="comment">     1.stage_name设置为"bitflip 16/8"</span></span><br><span class="line"><span class="comment">     2.stage_max设置为len - 1，而不是len</span></span><br><span class="line"><span class="comment">     3.以字为单位和0xffff进行异或运算，去翻转相邻的两个字节</span></span><br><span class="line"><span class="comment">     4.翻转之前会先检查eff_map里对应于这两个字节的标志是否为0，如果为0，则这两个字节是无</span></span><br><span class="line"><span class="comment">       效的数据，stage_max--，然后开始变异下一个字</span></span><br><span class="line"><span class="comment">     相同点：</span></span><br><span class="line"><span class="comment">     1.先翻转，再common_fuzz_stuff，最后复位</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (len < <span class="number">2</span>) <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">"bitflip 16/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"flip16"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + <span class="number">1</span>)]) {</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">    *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP16] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len < <span class="number">4</span>) </span><br><span class="line">      <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Four walking bytes. */</span></span><br><span class="line">  <span class="comment">/* 比特翻转的最后一个阶段，bitflip 32/8，即4字节翻转：</span></span><br><span class="line"><span class="comment">     1.stage_name设置为"bitflip 32/8"</span></span><br><span class="line"><span class="comment">     2.stage_max设置为len - 3</span></span><br><span class="line"><span class="comment">     3.以双字（dword）为单位，直接通过和0xffffffff异或运算去翻转相邻四个字节的位，然后</span></span><br><span class="line"><span class="comment">       执行一次，并记录</span></span><br><span class="line"><span class="comment">     4.在每次翻转之前会检查eff_map里对应于这四个字节的标志是否为0，如果是0，则这两个字节</span></span><br><span class="line"><span class="comment">       是无效的数据，stage_max--，然后开始变异下一组双字</span></span><br><span class="line"><span class="comment">     5.复位</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"bitflip 32/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"flip32"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len - <span class="number">3</span>; i++) {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + <span class="number">1</span>)] &&</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] && !eff_map[EFF_APOS(i + <span class="number">3</span>)]) {</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">    *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_FLIP32] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_bitflip:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (no_arith) </span><br><span class="line">      <span class="keyword">goto</span> skip_arith;</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="ARITHMETIC-INC-DEC-阶段"><a href="#ARITHMETIC-INC-DEC-阶段" class="headerlink" title="ARITHMETIC INC/DEC 阶段"></a>ARITHMETIC INC/DEC 阶段</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**********************</span></span><br><span class="line"><span class="comment">   * ARITHMETIC INC/DEC *</span></span><br><span class="line"><span class="comment">   **********************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这个阶段进行加减变异，和Bit_Flip阶段差不多，也是按照bit位数递增变异：</span></span><br><span class="line"><span class="comment">     1.这个阶段的加减变异是存在上限的在config.h中定义了宏ARITH_MAX，默认为35.所以会对</span></span><br><span class="line"><span class="comment">       目标进行+1~+35、-1~-35的运算；由整数存在大端序和小端序两种表现形式，所以这个阶段</span></span><br><span class="line"><span class="comment">       会对这两种情况分别进行变异</span></span><br><span class="line"><span class="comment">     2.本阶段中两种情况会跳过对应的byte的变异：</span></span><br><span class="line"><span class="comment">        a.选中字节对应在effector map中是无效的</span></span><br><span class="line"><span class="comment">        b.之前Bit_Flip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同</span></span><br><span class="line"><span class="comment">          ，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 8-bit arithmetics. */</span></span><br><span class="line">  <span class="comment">/* 重点来看来看arith 8/8阶段，后面的可以类比理解：</span></span><br><span class="line"><span class="comment">     1.由于arith 8/8阶段是单字节的，所以不需要考虑大小端，但单字和双字则需要考虑</span></span><br><span class="line"><span class="comment">     2.先遍历case中的每个字节，用orig暂存当前字节</span></span><br><span class="line"><span class="comment">     3.判断这个字节在eff_map中是否有效，若无效，stage减去2倍的ARITH_MAX，进入下一轮</span></span><br><span class="line"><span class="comment">     4.否则进入内层循环</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"arith 8/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"arith8"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">2</span> * len * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line"></span><br><span class="line">    u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) {</span><br><span class="line">      stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1.依次扫描orig~orig+j*（1 <= j <= 35）</span></span><br><span class="line"><span class="comment">       2.然后orig与orig+j进行异或翻转，结果赋值给r</span></span><br><span class="line"><span class="comment">       3.判断这个r是否可以通过上一阶段的Bit_Filp得到（防止相同的冗余变异，以节省时间）</span></span><br><span class="line"><span class="comment">         这里去看一下could_be_bitflip()函数的实现就明白了，如果r的值为0xffffffff</span></span><br><span class="line"><span class="comment">         或者0xffff或者0xff中的一个，那么就和前面的Bit_Flip撞了，因此会返回1，属于</span></span><br><span class="line"><span class="comment">         冗余变异</span></span><br><span class="line"><span class="comment">          a.若可以得到，则stage_max--</span></span><br><span class="line"><span class="comment">          b.否则，将out_buf[i]+j，然后调用common_fuzz_stuff</span></span><br><span class="line"><span class="comment">       4.将orig与orig-j进行异或翻转，结果赋值给r</span></span><br><span class="line"><span class="comment">       5.再判断一次r是否可以通过上一阶段的Bit_Flip得到，后面同上</span></span><br><span class="line"><span class="comment">       6.最后用orig恢复out_buf[i]的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j <= ARITH_MAX; j++) {</span><br><span class="line"></span><br><span class="line">      u8 r = orig ^ (orig + j);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Do arithmetic operations only if the result couldn't be a product</span></span><br><span class="line"><span class="comment">         of a bitflip. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(r)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        out_buf[i] = orig + j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) </span><br><span class="line">            <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> </span><br><span class="line">          stage_max--;</span><br><span class="line"></span><br><span class="line">      r =  orig ^ (orig - j);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(r)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        out_buf[i] = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) </span><br><span class="line">            <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      out_buf[i] = orig;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH8] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 16-bit arithmetics, both endians. */</span></span><br><span class="line">  <span class="comment">/* arith 16/8阶段每次对2字节进行加减变异，原理与arith 8/8相同，但是会考虑大小端 */</span></span><br><span class="line">  <span class="keyword">if</span> (len < <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">goto</span> skip_arith;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">"arith 16/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"arith16"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">4</span> * (len - <span class="number">1</span>) * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line"></span><br><span class="line">    u16 orig = *(u16*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + <span class="number">1</span>)]) {</span><br><span class="line">      stage_max -= <span class="number">4</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j <= ARITH_MAX; j++) {</span><br><span class="line"></span><br><span class="line">      u16 r1 = orig ^ (orig + j),</span><br><span class="line">          r2 = orig ^ (orig - j),</span><br><span class="line">          r3 = orig ^ SWAP16(SWAP16(orig) + j),</span><br><span class="line">          r4 = orig ^ SWAP16(SWAP16(orig) - j);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try little endian addition and subtraction first. Do it only</span></span><br><span class="line"><span class="comment">         if the operation would affect more than one byte (hence the </span></span><br><span class="line"><span class="comment">         & 0xff overflow checks) and if it couldn't be a product of</span></span><br><span class="line"><span class="comment">         a bitflip. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_LE; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig & <span class="number">0xff</span>) + j > <span class="number">0xff</span> && !could_be_bitflip(r1)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u16*)(out_buf + i) = orig + j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"> </span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig & <span class="number">0xff</span>) < j && !could_be_bitflip(r2)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u16*)(out_buf + i) = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Big endian comes next. Same deal. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig >> <span class="number">8</span>) + j > <span class="number">0xff</span> && !could_be_bitflip(r3)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig >> <span class="number">8</span>) < j && !could_be_bitflip(r4)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) - j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      *(u16*)(out_buf + i) = orig;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_ARITH16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH16] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 32-bit arithmetics, both endians. */</span></span><br><span class="line">  <span class="comment">/* arith 32/8阶段每次对4字节进行加减变异，同样会考虑大小端 */</span></span><br><span class="line">  <span class="keyword">if</span> (len < <span class="number">4</span>) <span class="keyword">goto</span> skip_arith;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">"arith 32/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"arith32"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">4</span> * (len - <span class="number">3</span>) * ARITH_MAX;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len - <span class="number">3</span>; i++) {</span><br><span class="line"></span><br><span class="line">    u32 orig = *(u32*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + <span class="number">1</span>)] &&</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] && !eff_map[EFF_APOS(i + <span class="number">3</span>)]) {</span><br><span class="line">      stage_max -= <span class="number">4</span> * ARITH_MAX;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j <= ARITH_MAX; j++) {</span><br><span class="line"></span><br><span class="line">      u32 r1 = orig ^ (orig + j),</span><br><span class="line">          r2 = orig ^ (orig - j),</span><br><span class="line">          r3 = orig ^ SWAP32(SWAP32(orig) + j),</span><br><span class="line">          r4 = orig ^ SWAP32(SWAP32(orig) - j);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Little endian first. Same deal as with 16-bit: we only want to</span></span><br><span class="line"><span class="comment">         try if the operation would have effect on more than two bytes. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig & <span class="number">0xffff</span>) + j > <span class="number">0xffff</span> && !could_be_bitflip(r1)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u32*)(out_buf + i) = orig + j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((orig & <span class="number">0xffff</span>) < j && !could_be_bitflip(r2)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u32*)(out_buf + i) = orig - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Big endian next. */</span></span><br><span class="line"></span><br><span class="line">      stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((SWAP32(orig) & <span class="number">0xffff</span>) + j > <span class="number">0xffff</span> && !could_be_bitflip(r3)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = j;</span><br><span class="line">        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((SWAP32(orig) & <span class="number">0xffff</span>) < j && !could_be_bitflip(r4)) {</span><br><span class="line"></span><br><span class="line">        stage_cur_val = -j;</span><br><span class="line">        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) - j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> </span><br><span class="line">          stage_max--;</span><br><span class="line"></span><br><span class="line">      *(u32*)(out_buf + i) = orig;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_ARITH32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_ARITH32] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_arith:</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="INTERESTING-VALUES阶段"><a href="#INTERESTING-VALUES阶段" class="headerlink" title="INTERESTING VALUES阶段"></a>INTERESTING VALUES阶段</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**********************</span></span><br><span class="line"><span class="comment">   * INTERESTING VALUES *</span></span><br><span class="line"><span class="comment">   **********************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进入INTERESTING VALUES阶段：</span></span><br><span class="line"><span class="comment">     1.这个阶段主要将out_buf中的字节替换成AFL预设的一些"interesting values"，这些数定义</span></span><br><span class="line"><span class="comment">       在config.h文件中</span></span><br><span class="line"><span class="comment">     2.hollk师傅认为这里主要是替换成一些可能导致整数溢出的数据，进行fuzz</span></span><br><span class="line"><span class="comment">     3.每次变异前，会调用could_be_bitflip和could_be_arith，判断是否在前两个阶段已经达到</span></span><br><span class="line"><span class="comment">       同样的变异，如果已经产生则跳过</span></span><br><span class="line"><span class="comment">     4.effector map仍然会用于判断目标字节的项是否有效，如果无效也会跳过</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.interest 8/8阶段：</span></span><br><span class="line"><span class="comment">        a.阶段以一个字节为单位进行替换变异</span></span><br><span class="line"><span class="comment">        b.核心操作为"out_buf[i] = interesting_8[j]"，完成字节的替换操作</span></span><br><span class="line"><span class="comment">        c.然后依旧是进行common_fuzz_stuff+字节复位的操作</span></span><br><span class="line"><span class="comment">     2.interest 16/8阶段：</span></span><br><span class="line"><span class="comment">        a.以两个字节为单位进行替换变异</span></span><br><span class="line"><span class="comment">        b.需要去除异或、加减、单字节替换变异阶段的冗余</span></span><br><span class="line"><span class="comment">        c.考虑大小端序</span></span><br><span class="line"><span class="comment">     3.interest 32/8阶段：</span></span><br><span class="line"><span class="comment">        a.以四字节为单位进行替换变异，其余手法同interest 16/8</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"interest 8/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"int8"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = len * <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setting 8-bit integers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line"></span><br><span class="line">    u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) {</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < <span class="keyword">sizeof</span>(interesting_8); j++) {</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">          could_be_arith(orig, (u8)interesting_8[j], <span class="number">1</span>)) {</span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_8[j];</span><br><span class="line">      out_buf[i] = interesting_8[j];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      out_buf[i] = orig;</span><br><span class="line">      stage_cur++;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST8] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setting 16-bit integers, both endians. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (no_arith || len < <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">goto</span> skip_interest;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">"interest 16/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"int16"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">2</span> * (len - <span class="number">1</span>) * (<span class="keyword">sizeof</span>(interesting_16) >> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line"></span><br><span class="line">    u16 orig = *(u16*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + <span class="number">1</span>)]) {</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_16);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < <span class="keyword">sizeof</span>(interesting_16) / <span class="number">2</span>; j++) {</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_16[j];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip if this could be a product of a bitflip, arithmetics,</span></span><br><span class="line"><span class="comment">         or single-byte interesting value insertion. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &&</span><br><span class="line">          !could_be_arith(orig, (u16)interesting_16[j], <span class="number">2</span>) &&</span><br><span class="line">          !could_be_interest(orig, (u16)interesting_16[j], <span class="number">2</span>, <span class="number">0</span>)) {</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">        *(u16*)(out_buf + i) = interesting_16[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &&</span><br><span class="line">          !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &&</span><br><span class="line">          !could_be_arith(orig, SWAP16(interesting_16[j]), <span class="number">2</span>) &&</span><br><span class="line">          !could_be_interest(orig, SWAP16(interesting_16[j]), <span class="number">2</span>, <span class="number">1</span>)) {</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">        *(u16*)(out_buf + i) = SWAP16(interesting_16[j]);</span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(u16*)(out_buf + i) = orig;</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_INTEREST16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST16] += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len < <span class="number">4</span>) <span class="keyword">goto</span> skip_interest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setting 32-bit integers, both endians. */</span></span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">"interest 32/8"</span>;</span><br><span class="line">  stage_short = <span class="string">"int32"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = <span class="number">2</span> * (len - <span class="number">3</span>) * (<span class="keyword">sizeof</span>(interesting_32) >> <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len - <span class="number">3</span>; i++) {</span><br><span class="line"></span><br><span class="line">    u32 orig = *(u32*)(out_buf + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + <span class="number">1</span>)] &&</span><br><span class="line">        !eff_map[EFF_APOS(i + <span class="number">2</span>)] && !eff_map[EFF_APOS(i + <span class="number">3</span>)]) {</span><br><span class="line">      stage_max -= <span class="keyword">sizeof</span>(interesting_32) >> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < <span class="keyword">sizeof</span>(interesting_32) / <span class="number">4</span>; j++) {</span><br><span class="line"></span><br><span class="line">      stage_cur_val = interesting_32[j];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip if this could be a product of a bitflip, arithmetics,</span></span><br><span class="line"><span class="comment">         or word interesting value insertion. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &&</span><br><span class="line">          !could_be_arith(orig, interesting_32[j], <span class="number">4</span>) &&</span><br><span class="line">          !could_be_interest(orig, interesting_32[j], <span class="number">4</span>, <span class="number">0</span>)) {</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">        *(u32*)(out_buf + i) = interesting_32[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &&</span><br><span class="line">          !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &&</span><br><span class="line">          !could_be_arith(orig, SWAP32(interesting_32[j]), <span class="number">4</span>) &&</span><br><span class="line">          !could_be_interest(orig, SWAP32(interesting_32[j]), <span class="number">4</span>, <span class="number">1</span>)) {</span><br><span class="line"></span><br><span class="line">        stage_val_type = STAGE_VAL_BE;</span><br><span class="line"></span><br><span class="line">        *(u32*)(out_buf + i) = SWAP32(interesting_32[j]);</span><br><span class="line">        <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        stage_cur++;</span><br><span class="line"></span><br><span class="line">      } <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(u32*)(out_buf + i) = orig;</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_INTEREST32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_INTEREST32] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_interest:</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="DICTIONARY-STUFF阶段"><a href="#DICTIONARY-STUFF阶段" class="headerlink" title="DICTIONARY STUFF阶段"></a>DICTIONARY STUFF阶段</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/********************</span></span><br><span class="line"><span class="comment">   * DICTIONARY STUFF *</span></span><br><span class="line"><span class="comment">   ********************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从这个阶段开始，就接近deterministic fuzzing的尾声了，本阶段主要基于用户提供的</span></span><br><span class="line"><span class="comment">     extras token来进行一定的变异，变异规则为替换或者插入。这些extras token的生成</span></span><br><span class="line"><span class="comment">     及加载过程参考初始化部分的maybe_add_auto、load_extras、save_auto这三个函数</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     用户提供的tokens，是在词典文件中设置并通过-x选项指定的，如果没有则跳过相应的子阶</span></span><br><span class="line"><span class="comment">     段；阶段开始会判断extras_cnt的值，如果为0，说明用户没有提供extra token，则直</span></span><br><span class="line"><span class="comment">     接跳过这个阶段的变异</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!extras_cnt) </span><br><span class="line">      <span class="keyword">goto</span> skip_user_extras;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Overwrite with user-supplied extras. */</span></span><br><span class="line">  <span class="comment">/* DICTIONARY STUFF有3个阶段，第一个是user extras (over)，这部分主要是将用户</span></span><br><span class="line"><span class="comment">     提供的tokens依次与out_buf进行替换：</span></span><br><span class="line"><span class="comment">     1.stage_max设置为extras_cnt * len</span></span><br><span class="line"><span class="comment">     2.外层循环out_buf每个字节，内层循环token，并依次在当前字节开始处进行替换。然后</span></span><br><span class="line"><span class="comment">       调用common_fuzz_stuff</span></span><br><span class="line"><span class="comment">     3.以下几种情况会跳过extras替换</span></span><br><span class="line"><span class="comment">        a.extras_cnt > MAX_DET_EXTRAS（设定为200）</span></span><br><span class="line"><span class="comment">        b.没有空间插入有效载荷，即[out_but[i], len] < len(token)</span></span><br><span class="line"><span class="comment">        c.eff_map在整个token替换的跨度区域没有设置有效字节</span></span><br><span class="line"><span class="comment">     4.由于extras token是按照从小到大的顺序排好序的，所以这里采用了在外部循环确定的</span></span><br><span class="line"><span class="comment">       特定偏移量处恢复写入之间的缓冲区</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"user extras (over)"</span>;</span><br><span class="line">  stage_short = <span class="string">"ext_UO"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = extras_cnt * len;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line"></span><br><span class="line">    u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extras are sorted by size, from smallest to largest. This means</span></span><br><span class="line"><span class="comment">       that we don't have to worry about restoring the buffer in</span></span><br><span class="line"><span class="comment">       between writes at a particular offset determined by the outer</span></span><br><span class="line"><span class="comment">       loop. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < extras_cnt; j++) {</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip extras probabilistically if extras_cnt > MAX_DET_EXTRAS. Also</span></span><br><span class="line"><span class="comment">         skip them if there's no room to insert the payload, if the token</span></span><br><span class="line"><span class="comment">         is redundant, or if its entire span has no bytes set in the effector</span></span><br><span class="line"><span class="comment">         map. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((extras_cnt > MAX_DET_EXTRAS && UR(extras_cnt) >= MAX_DET_EXTRAS) ||</span><br><span class="line">          extras[j].len > len - i ||</span><br><span class="line">          !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, extras[j].len))) {</span><br><span class="line"></span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      last_len = extras[j].len;</span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) </span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Insertion of user-supplied extras. */</span></span><br><span class="line">  <span class="comment">/* user extras (insert)阶段主要是将用户提供的token插入到out_buf中的策略：</span></span><br><span class="line"><span class="comment">     1.这个阶段没有过滤掉eff_map字节无效等情况，也就是说不会跳过token插入的阶段</span></span><br><span class="line"><span class="comment">     2.这里初始化了一块缓冲区ex_tmp，而不是直接对out_buf进行，所以只有Insert token和</span></span><br><span class="line"><span class="comment">       copy tail的过程，没有restore的过程</span></span><br><span class="line"><span class="comment">     3.copy tail之后，进行common_fuzz_stuff     </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"user extras (insert)"</span>;</span><br><span class="line">  stage_short = <span class="string">"ext_UI"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = extras_cnt * (len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  ex_tmp = ck_alloc(len + MAX_DICT_FILE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i <= len; i++) {</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < extras_cnt; j++) {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (len + extras[j].len > MAX_FILE) {</span><br><span class="line">        stage_max--; </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Insert token */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Copy tail */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) {</span><br><span class="line">        ck_free(ex_tmp);</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy head */</span></span><br><span class="line">    ex_tmp[i] = out_buf[i];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ck_free(ex_tmp);</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_UI] += stage_max;</span><br><span class="line"></span><br><span class="line">skip_user_extras:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!a_extras_cnt)</span><br><span class="line">      <span class="keyword">goto</span> skip_extras;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后是auto extras (over)阶段，该阶段和 user extras (over)类似，只不过是将</span></span><br><span class="line"><span class="comment">     extras[] 换成了 a_extras[]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  stage_name  = <span class="string">"auto extras (over)"</span>;</span><br><span class="line">  stage_short = <span class="string">"ext_AO"</span>;</span><br><span class="line">  stage_cur   = <span class="number">0</span>;</span><br><span class="line">  stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;</span><br><span class="line"></span><br><span class="line">  stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line"></span><br><span class="line">    u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) {</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* See the comment in the earlier code; extras are sorted by size. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (a_extras[j].len > len - i ||</span><br><span class="line">          !<span class="built_in">memcmp</span>(a_extras[j].data, out_buf + i, a_extras[j].len) ||</span><br><span class="line">          !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, a_extras[j].len))) {</span><br><span class="line"></span><br><span class="line">        stage_max--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      last_len = a_extras[j].len;</span><br><span class="line">      <span class="built_in">memcpy</span>(out_buf + i, a_extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) </span><br><span class="line">          <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">      stage_cur++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">  stage_cycles[STAGE_EXTRAS_AO] += stage_max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">skip_extras:</span><br><span class="line">  <span class="comment">/* If we made this to here without jumping to havoc_stage or abandon_entry,</span></span><br><span class="line"><span class="comment">     we're properly done with deterministic steps and can mark it as such</span></span><br><span class="line"><span class="comment">     in the .state/ directory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果在没有跳转到havoc_stage或者abandon_entry的情况下会来到这里，说明我们已经正确地完</span></span><br><span class="line"><span class="comment">     成了确定性fuzz步骤（deterministic steps），为此我们可以标记出来（例如在.state/目录中）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!queue_cur->passed_det) </span><br><span class="line">      mark_as_det_done(queue_cur);</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="RANDOM-HAVOC（随机毁灭）阶段"><a href="#RANDOM-HAVOC（随机毁灭）阶段" class="headerlink" title="RANDOM HAVOC（随机毁灭）阶段"></a>RANDOM HAVOC（随机毁灭）阶段</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/****************</span></span><br><span class="line"><span class="comment">   * RANDOM HAVOC *</span></span><br><span class="line"><span class="comment">   ****************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 对于非dumb_mode的主fuzzer来说，完成了上述deterministic fuzzing后，便会进入此阶段；</span></span><br><span class="line"><span class="comment">     对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</span></span><br><span class="line"><span class="comment">     RANDOM HAVOC（随机毁灭），这个阶段充满了随机性，它包含了多轮变异，每一轮都应用多种方式</span></span><br><span class="line"><span class="comment">     进行组合</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"></span><br><span class="line">havoc_stage:</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The havoc stage mutation code is also invoked when splicing files; if the</span></span><br><span class="line"><span class="comment">     splice_cycle variable is set, generate different descriptions and such. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.判断是否设置了splice_cycle</span></span><br><span class="line"><span class="comment">        a.若设置了，标记此阶段为"havoc"</span></span><br><span class="line"><span class="comment">        b.若没设置，标记此阶段为"splice"</span></span><br><span class="line"><span class="comment">     2.设置stage_max的值（HAVOC_MIN设定为16）</span></span><br><span class="line"><span class="comment">     3.设置orig_hit_cnt、havoc_queued的值（这2个均为fuzz_one的局部变量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!splice_cycle) {</span><br><span class="line"></span><br><span class="line">    stage_name  = <span class="string">"havoc"</span>;</span><br><span class="line">    stage_short = <span class="string">"havoc"</span>;</span><br><span class="line">    stage_max   = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *</span><br><span class="line">                  perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line">      </span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> u8 tmp[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    perf_score = orig_perf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">"splice %u"</span>, splice_cycle);</span><br><span class="line">    stage_name  = tmp;</span><br><span class="line">    stage_short = <span class="string">"splice"</span>;</span><br><span class="line">    stage_max   = SPLICE_HAVOC * perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stage_max < HAVOC_MIN) </span><br><span class="line">      stage_max = HAVOC_MIN;</span><br><span class="line"></span><br><span class="line">  temp_len = len;</span><br><span class="line"></span><br><span class="line">  orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line">  havoc_queued = queued_paths;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We essentially just do several thousand runs (depending on perf_score)</span></span><br><span class="line"><span class="comment">     where we take the input file and make random stacked tweaks. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.外层循环stage_max轮stage（最小为16）</span></span><br><span class="line"><span class="comment">     2.内层循环use_stacking轮，即一次stage中变化的次数（这是个随机的值，范围在2~14之间）</span></span><br><span class="line"><span class="comment">     3.进入switch语句，分支条件根据extras的数量随机生成一个数（范围在0~16或0~14之间，其中case15和case16</span></span><br><span class="line"><span class="comment">       只有存在extras时才有可能触发）：</span></span><br><span class="line"><span class="comment">        case0: </span></span><br><span class="line"><span class="comment">        case1:  随机选中interesting_8[]中的某个byte随机替换out_buf中的某个byte</span></span><br><span class="line"><span class="comment">        case2:  随机选中interesting_16[]中的某个word随机替换out_buf中的某个word（大小端序随机选择）</span></span><br><span class="line"><span class="comment">        case3:  随机选中interesting_32[]中的某个dword随机替换out_buf中的某个dword（大小端序随机选择）</span></span><br><span class="line"><span class="comment">        case4:  随机选中out_buf中的某个byte，减去一个随机的值（范围1~35）</span></span><br><span class="line"><span class="comment">        case5:  随机选中out_buf中的某个byte，加上一个随机的值（范围1~35）</span></span><br><span class="line"><span class="comment">        case6:  随机选中out_buf中的某个word，减去一个随机的值（大小端随机选择）</span></span><br><span class="line"><span class="comment">        case7:  随机选中out_buf中的某个word，加上一个随机的值（大小端随机选择）</span></span><br><span class="line"><span class="comment">        case8:  随机选中out_buf中的某个dword，减去一个随机的值（大小端随机选择）</span></span><br><span class="line"><span class="comment">        case9:  随机选中out_buf中的某个dword，加上一个随机的值（大小端随机选择）</span></span><br><span class="line"><span class="comment">        case10: 随机选中out_buf中的某个byte与范围在1~255中的一个随机值进行异或</span></span><br><span class="line"><span class="comment">        case11: 随机选中out_buf中的某个byte进行删除</span></span><br><span class="line"><span class="comment">        case12: 同case11，稍微增加一丢丢删除byte的概率，从而使得case更加精炼</span></span><br><span class="line"><span class="comment">        case13: 随机选中out_buf中的某个位置，插入随机长度的内容：</span></span><br><span class="line"><span class="comment">                a.75%的概率，插入一段out_buf中随机选择的一段内容</span></span><br><span class="line"><span class="comment">                b.25%的概率，插入一段相同的随机数字（50%概率是随机生成的，50%概率是从out_buf中随机选取的一个byte）</span></span><br><span class="line"><span class="comment">        case14: 随机选中out_buf中的某个位置，覆盖随机长度的内容：</span></span><br><span class="line"><span class="comment">                a.75%的概率，覆盖一段out_buf中随机选择的一段内容</span></span><br><span class="line"><span class="comment">                b.25%的概率，覆盖一段相同的随机数字（50%概率是随机生成的，50%概率是从out_buf中随机选取的一个byte）</span></span><br><span class="line"><span class="comment">        case15: 随机选中out_buf中的某个位置，覆盖成extra token（token来自用户提供的extras和自动生成的a_extras）</span></span><br><span class="line"><span class="comment">        case16: 随机选中out_buf中的某个位置，插入extra token（token来自用户提供的extras和自动生成的a_extras）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur < stage_max; stage_cur++) {</span><br><span class="line"></span><br><span class="line">    u32 use_stacking = <span class="number">1</span> << (<span class="number">1</span> + UR(HAVOC_STACK_POW2));</span><br><span class="line"></span><br><span class="line">    stage_cur_val = use_stacking;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < use_stacking; i++) {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (UR(<span class="number">15</span> + ((extras_cnt + a_extras_cnt) ? <span class="number">2</span> : <span class="number">0</span>))) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Flip a single bit somewhere. Spooky! */</span></span><br><span class="line"></span><br><span class="line">          FLIP_BIT(out_buf, UR(temp_len << <span class="number">3</span>));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Set byte to interesting value. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] = interesting_8[UR(<span class="keyword">sizeof</span>(interesting_8))];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Set word to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len < <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) {</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) =</span><br><span class="line">              interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) >> <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) = SWAP16(</span><br><span class="line">              interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) >> <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Set dword to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len < <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) {</span><br><span class="line">  </span><br><span class="line">            *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) =</span><br><span class="line">              interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) >> <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) = SWAP32(</span><br><span class="line">              interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) >> <span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly subtract from byte. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly add to byte. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly subtract from word, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len < <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">            u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) =</span><br><span class="line">              SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly add to word, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len < <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">            u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u16*)(out_buf + pos) =</span><br><span class="line">              SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly subtract from dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len < <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">            u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) =</span><br><span class="line">              SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Randomly add to dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len < <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">2</span>)) {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">            u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">            *(u32*)(out_buf + pos) =</span><br><span class="line">              SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Just set a random byte to a random value. Because,</span></span><br><span class="line"><span class="comment">             why not. We use XOR with 1-255 to eliminate the</span></span><br><span class="line"><span class="comment">             possibility of a no-op. */</span></span><br><span class="line"></span><br><span class="line">          out_buf[UR(temp_len)] ^= <span class="number">1</span> + UR(<span class="number">255</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span> ... <span class="number">12</span>: {</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Delete bytes. We're making this a bit more likely</span></span><br><span class="line"><span class="comment">               than insertion (the next option) in hopes of keeping</span></span><br><span class="line"><span class="comment">               files reasonably small. */</span></span><br><span class="line"></span><br><span class="line">            u32 del_from, del_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len < <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Don't delete too much. */</span></span><br><span class="line"></span><br><span class="line">            del_len = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            del_from = UR(temp_len - del_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            memmove(out_buf + del_from, out_buf + del_from + del_len,</span><br><span class="line">                    temp_len - del_from - del_len);</span><br><span class="line"></span><br><span class="line">            temp_len -= del_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len + HAVOC_BLK_XL < MAX_FILE) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Clone bytes (75%) or insert a block of constant bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">            u8  actually_clone = UR(<span class="number">4</span>);</span><br><span class="line">            u32 clone_from, clone_to, clone_len;</span><br><span class="line">            u8* new_buf;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actually_clone) {</span><br><span class="line"></span><br><span class="line">              clone_len  = choose_block_len(temp_len);</span><br><span class="line">              clone_from = UR(temp_len - clone_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">              clone_len = choose_block_len(HAVOC_BLK_XL);</span><br><span class="line">              clone_from = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            clone_to   = UR(temp_len);</span><br><span class="line"></span><br><span class="line">            new_buf = ck_alloc_nozero(temp_len + clone_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Head */</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf, out_buf, clone_to);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Inserted part */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actually_clone)</span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf + clone_to, out_buf + clone_from, clone_len);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="built_in">memset</span>(new_buf + clone_to,</span><br><span class="line">                     UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], clone_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Tail */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + clone_to + clone_len, out_buf + clone_to,</span><br><span class="line">                   temp_len - clone_to);</span><br><span class="line"></span><br><span class="line">            ck_free(out_buf);</span><br><span class="line">            out_buf = new_buf;</span><br><span class="line">            temp_len += clone_len;</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>: {</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Overwrite bytes with a randomly selected chunk (75%) or fixed</span></span><br><span class="line"><span class="comment">               bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">            u32 copy_from, copy_to, copy_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len < <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            copy_len  = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            copy_from = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line">            copy_to   = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (UR(<span class="number">4</span>)) {</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (copy_from != copy_to)</span><br><span class="line">                memmove(out_buf + copy_to, out_buf + copy_from, copy_len);</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> <span class="built_in">memset</span>(out_buf + copy_to,</span><br><span class="line">                          UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], copy_len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Values 15 and 16 can be selected only if there are any extras</span></span><br><span class="line"><span class="comment">           present in the dictionaries. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>: {</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Overwrite bytes with an extra. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt && UR(<span class="number">2</span>))) {</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* No user-specified extras or odds in our favor. Let's use an</span></span><br><span class="line"><span class="comment">                 auto-detected one. */</span></span><br><span class="line"></span><br><span class="line">              u32 use_extra = UR(a_extras_cnt);</span><br><span class="line">              u32 extra_len = a_extras[use_extra].len;</span><br><span class="line">              u32 insert_at;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (extra_len > temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">              <span class="built_in">memcpy</span>(out_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* No auto extras or odds in our favor. Use the dictionary. */</span></span><br><span class="line"></span><br><span class="line">              u32 use_extra = UR(extras_cnt);</span><br><span class="line">              u32 extra_len = extras[use_extra].len;</span><br><span class="line">              u32 insert_at;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (extra_len > temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">              <span class="built_in">memcpy</span>(out_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>: {</span><br><span class="line"></span><br><span class="line">            u32 use_extra, extra_len, insert_at = UR(temp_len + <span class="number">1</span>);</span><br><span class="line">            u8* new_buf;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Insert an extra. Do the same dice-rolling stuff as for the</span></span><br><span class="line"><span class="comment">               previous case. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt && UR(<span class="number">2</span>))) {</span><br><span class="line"></span><br><span class="line">              use_extra = UR(a_extras_cnt);</span><br><span class="line">              extra_len = a_extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (temp_len + extra_len >= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Head */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Inserted part */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">              use_extra = UR(extras_cnt);</span><br><span class="line">              extra_len = extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (temp_len + extra_len >= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Head */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Inserted part */</span></span><br><span class="line">              <span class="built_in">memcpy</span>(new_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Tail */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + insert_at + extra_len, out_buf + insert_at,</span><br><span class="line">                   temp_len - insert_at);</span><br><span class="line"></span><br><span class="line">            ck_free(out_buf);</span><br><span class="line">            out_buf   = new_buf;</span><br><span class="line">            temp_len += extra_len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 1.在进行完循环叠加变换后，调用common_fuzz_stuff对变换后的结果进行fuzz</span></span><br><span class="line"><span class="comment">       2.恢复out_buf的内容</span></span><br><span class="line"><span class="comment">       3.如果fuzz后，queued_paths和havoc_queued不一样了，说明发现了新路径；在范围允许</span></span><br><span class="line"><span class="comment">         的情况下，更新stage_max、perf_score以及havoc_queued（注意这个是局部变量）</span></span><br><span class="line"><span class="comment">       4.在经历了如此多的deterministic变异和随机变异后，原本的case或许早已面目全非，在这</span></span><br><span class="line"><span class="comment">         个过程中充满了大量的随机性，这也是fuzzing过程中的不可控因素，也因此，建议在fuzz</span></span><br><span class="line"><span class="comment">         的时候开多个fuzzer同时进行，因为fuzz的结果往往并不相同。也因此，在服务器上跑fuzz</span></span><br><span class="line"><span class="comment">         往往需要的是更多的核心数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, temp_len))</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp_len < len) </span><br><span class="line">        out_buf = ck_realloc(out_buf, len);</span><br><span class="line">    temp_len = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queued_paths != havoc_queued) {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (perf_score <= HAVOC_MAX_MULT * <span class="number">100</span>) {</span><br><span class="line">        stage_max  *= <span class="number">2</span>;</span><br><span class="line">        perf_score *= <span class="number">2</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      havoc_queued = queued_paths;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!splice_cycle) {</span><br><span class="line">    stage_finds[STAGE_HAVOC]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">    stage_cycles[STAGE_HAVOC] += stage_max;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    stage_finds[STAGE_SPLICE]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">    stage_cycles[STAGE_SPLICE] += stage_max;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div>



<h3 id="SPLICING阶段"><a href="#SPLICING阶段" class="headerlink" title="SPLICING阶段"></a>SPLICING阶段</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IGNORE_FINDS</span></span><br><span class="line">   <span class="comment">/************</span></span><br><span class="line"><span class="comment">   * SPLICING *</span></span><br><span class="line"><span class="comment">   ************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is a last-resort strategy triggered by a full round with no findings.</span></span><br><span class="line"><span class="comment">     It takes the current input file, randomly selects another input, and</span></span><br><span class="line"><span class="comment">     splices them together at some offset, then relies on the havoc</span></span><br><span class="line"><span class="comment">     code to mutate that blob. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果在经历过RANDOM HAVOC阶段后没有什么效果，那么就会进入到SPLICING阶段，这个阶段会尝试</span></span><br><span class="line"><span class="comment">     将当前的case与一个随机选中的case以某个偏移量拼接在一起，然后再次进入RANDOM HAVOC阶段 */</span></span><br><span class="line"></span><br><span class="line">retry_splicing:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_splicing && splice_cycle++ < SPLICE_CYCLES &&</span><br><span class="line">      queued_paths > <span class="number">1</span> && queue_cur->len > <span class="number">1</span>) {</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">target</span>;</span></span><br><span class="line">    u32 tid, split_at;</span><br><span class="line">    u8* new_buf;</span><br><span class="line">    s32 f_diff, l_diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First of all, if we've modified in_buf for havoc, let's clean that</span></span><br><span class="line"><span class="comment">       up... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_buf != orig_in) {</span><br><span class="line">      ck_free(in_buf);</span><br><span class="line">      in_buf = orig_in;</span><br><span class="line">      len = queue_cur->len;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pick a random queue entry and seek to it. Don't splice with yourself. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> { </span><br><span class="line">        tid = UR(queued_paths); </span><br><span class="line">    } <span class="keyword">while</span> (tid == current_entry);</span><br><span class="line"></span><br><span class="line">    splicing_with = tid;</span><br><span class="line">    target = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tid >= <span class="number">100</span>) { </span><br><span class="line">        target = target->next_100; tid -= <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (tid--) </span><br><span class="line">        target = target->next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that the target has a reasonable length. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (target && (target->len < <span class="number">2</span> || target == queue_cur)) {</span><br><span class="line">      target = target->next;</span><br><span class="line">      splicing_with++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!target) </span><br><span class="line">        <span class="keyword">goto</span> retry_splicing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the testcase into a new buffer. */</span></span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(target->fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd < <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">"Unable to open '%s'"</span>, target->fname);</span><br><span class="line"></span><br><span class="line">    new_buf = ck_alloc_nozero(target->len);</span><br><span class="line"></span><br><span class="line">    ck_read(fd, new_buf, target->len, target->fname);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find a suitable splicing location, somewhere between the first and</span></span><br><span class="line"><span class="comment">       the last differing byte. Bail out if the difference is just a single</span></span><br><span class="line"><span class="comment">       byte or so. */</span></span><br><span class="line"></span><br><span class="line">    locate_diffs(in_buf, new_buf, MIN(len, target->len), &f_diff, &l_diff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f_diff < <span class="number">0</span> || l_diff < <span class="number">2</span> || f_diff == l_diff) {</span><br><span class="line">      ck_free(new_buf);</span><br><span class="line">      <span class="keyword">goto</span> retry_splicing;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split somewhere between the first and last differing byte. */</span></span><br><span class="line"></span><br><span class="line">    split_at = f_diff + UR(l_diff - f_diff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the thing. */</span></span><br><span class="line"></span><br><span class="line">    len = target->len;</span><br><span class="line">    <span class="built_in">memcpy</span>(new_buf, in_buf, split_at);</span><br><span class="line">    in_buf = new_buf;</span><br><span class="line"></span><br><span class="line">    ck_free(out_buf);</span><br><span class="line">    out_buf = ck_alloc_nozero(len);</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !IGNORE_FINDS */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果有所发现，那么就会来到此处：</span></span><br><span class="line"><span class="comment">     1.设置ret_val为0</span></span><br><span class="line"><span class="comment">     2.设置splicing_with为-1，即不与其它case进行拼接</span></span><br><span class="line"><span class="comment">     3.对于当前项case信息进行更新：</span></span><br><span class="line"><span class="comment">        a.如果queue_cur通过了评估，且queue_cur->was_fuzzed值为0，则将该值置1，然后</span></span><br><span class="line"><span class="comment">          令计数器pending_not_fuzzed减1</span></span><br><span class="line"><span class="comment">        b.如果queue_cur还是favored的，那么pending_favored计数器减1</span></span><br><span class="line"><span class="comment">     4.最后做一些清理回收的操作，然后返回ret_val</span></span><br><span class="line"><span class="comment">     5.至此，fuzz_one结束</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ret_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">abandon_entry:</span><br><span class="line"></span><br><span class="line">  splicing_with = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Update pending_not_fuzzed count if we made it through the calibration</span></span><br><span class="line"><span class="comment">     cycle and have not seen this entry before. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!stop_soon && !queue_cur->cal_failed && !queue_cur->was_fuzzed) {</span><br><span class="line">    queue_cur->was_fuzzed = <span class="number">1</span>;</span><br><span class="line">    pending_not_fuzzed--;</span><br><span class="line">    <span class="keyword">if</span> (queue_cur->favored) </span><br><span class="line">        pending_favored--;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  munmap(orig_in, queue_cur->len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_buf != orig_in) </span><br><span class="line">      ck_free(in_buf);</span><br><span class="line">  ck_free(out_buf);</span><br><span class="line">  ck_free(eff_map);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret_val;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> FLIP_BIT</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<h2 id="交互运作"><a href="#交互运作" class="headerlink" title="交互运作"></a>交互运作</h2><p>文章的最后，附上一张AFL执行时的交互工作图：</p>
<a href="/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/interworking_1.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="lazyload" data-src="/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/interworking_1.png"></a>





<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://eternalsakura13.com/2020/08/23/afl/" target="_blank" rel="noopener"><strong>skr：sakuraのAFL源码全注释</strong></a></li>
<li><a href="https://hollk.blog.csdn.net/article/details/121771166?spm=1001.2014.3001.5502" target="_blank" rel="noopener"><strong>hollk：AFL源码分析之afl-fuzz.c详细注释（二）：FUZZ执行流程</strong></a></li>
<li><a href="https://bbs.pediy.com/thread-265936.htm" target="_blank" rel="noopener"><strong>ScUpax0s：AFL源码阅读笔记之gcc与fuzz部分</strong></a></li>
<li><strong><a href="https://github.com/google/AFL/blob/master/afl-fuzz.c" target="_blank" rel="noopener">AFL：afl-fuzz.c</a></strong></li>
<li><a href="https://paper.seebug.org/1732/" target="_blank" rel="noopener">Seebug：AFL 二三事——源码分析</a></li>
<li><a href="https://hicookie.me/2019/09/18/AFL-Learning/" target="_blank" rel="noopener">HICOOKIE：AFL-Learning</a></li>
<li><a href="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/" target="_blank" rel="noopener">Jussi Judin：afl-fuzz on different file systems</a></li>
</ol>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">cataLoc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://cata1oc.github.io/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/">http://cata1oc.github.io/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全    </a><a class="post-meta__tags" href="/tags/Fuzzing/">Fuzzing    </a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/03/12/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9005/cover0x54.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/05/13/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98/"><img class="prev_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/05/13/KCTF2022%E6%98%A5%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98/0x5B.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>KCTF2022春季赛第二题</span></div></a></div><div class="next-post pull_right"><a href="/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/cover0x53.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>AFL源码分析04：afl-fuzz.c</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/01/02/AFL源码分析01/" title="AFL源码分析01：afl-gcc.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/02/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001/cover0x50.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-02</div><div class="relatedPosts_title">AFL源码分析01：afl-gcc.c</div></div></a></div><div class="relatedPosts_item"><a href="/2021/12/22/AFL环境搭建/" title="AFL环境搭建"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/12/22/AFL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/cover0x4F.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-12-22</div><div class="relatedPosts_title">AFL环境搭建</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/05/AFL源码分析02/" title="AFL源码分析02：afl-as.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/05/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002/cover0x51.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-05</div><div class="relatedPosts_title">AFL源码分析02：afl-as.c</div></div></a></div><div class="relatedPosts_item"><a href="/2022/01/07/AFL源码分析03/" title="AFL源码分析03：afl-as.h"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/01/07/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003/cover0x52.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-01-07</div><div class="relatedPosts_title">AFL源码分析03：afl-as.h</div></div></a></div><div class="relatedPosts_item"><a href="/2022/02/06/AFL源码分析04/" title="AFL源码分析04：afl-fuzz.c"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2022/02/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9004/cover0x53.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-02-06</div><div class="relatedPosts_title">AFL源码分析04：afl-fuzz.c</div></div></a></div><div class="relatedPosts_item"><a href="/2021/10/31/初探GOT与PLT/" title="初探GOT与PLT"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/cata1oc/cata1oc.github.io/master/2021/10/31/%E5%88%9D%E6%8E%A2GOT%E4%B8%8EPLT/cover0x4C.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-31</div><div class="relatedPosts_title">初探GOT与PLT</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By cataLoc</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>