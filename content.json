{"meta":{"title":"cataLoc's Blog","subtitle":"","description":"","author":"cataLoc","url":"http://yoursite.com","root":"/blog/"},"pages":[{"title":"link","date":"2020-03-07T03:28:51.000Z","updated":"2020-03-07T03:28:52.000Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-07T03:27:53.000Z","updated":"2020-03-07T03:27:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"movies","date":"2020-03-07T03:28:28.000Z","updated":"2020-03-07T03:28:30.000Z","comments":true,"path":"movies/index.html","permalink":"http://yoursite.com/movies/index.html","excerpt":"","text":""},{"title":"messageboard","date":"2020-03-07T03:28:09.000Z","updated":"2020-03-07T03:28:12.000Z","comments":true,"path":"messageboard/index.html","permalink":"http://yoursite.com/messageboard/index.html","excerpt":"","text":""},{"title":"music","date":"2020-03-07T03:28:22.000Z","updated":"2020-03-07T03:28:24.000Z","comments":true,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-03-07T03:28:40.000Z","updated":"2020-03-07T03:28:42.000Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-07T03:27:42.000Z","updated":"2020-03-07T03:27:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2-9-9-12分页","slug":"2-9-9-12分页","date":"2020-03-22T06:53:29.000Z","updated":"2020-03-22T13:09:33.549Z","comments":true,"path":"2020/03/22/2-9-9-12分页/","link":"","permalink":"http://yoursite.com/2020/03/22/2-9-9-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"在前面的文章中主要介绍了10-10-12分页方式，在这种分页方式下，物理地址最多可达4GB。随着硬件发展，4GB的物理地址范围已经无法满足要求，于是Intel设计了一种新的分页方式：2-9-9-12分页（又称PAE）分页。下面就来了解一下这种分页方式是如何运作的吧。 PAE分页为什么是2-9-9-12PAE（Physical Address Extension，物理地址扩展）页，一定会涉及到2个结构，就是PDE和PTE。以PTE来说，它可以直接定位到某个物理页上的物理地址，在10-10-12分页下，由于PTE的大小是4字节(32位)，因此PTE能够寻址的范围仅有4GB。设想，若PTE有33位，那便可以寻址8GB；34位就能寻址16GB……以此类推。Intel考虑到对齐的因素，就干脆直接让PTE的长度达到64位了。这样一个PTE的大小就8字节，又因为一个PTT表的大小是4KB(4096字节)，因此原本一个PTT表里能装下1024个4字节的PTE，现在只能装下512个8字节的PTE了。2的9次方等于512，所以PTI的值为9。 同理，PDI的值也为9，这样2-9-9-12中还剩下最前面的2位。 PDPTEPDPTE（Paga-Directory-Point-Table Entry）页目录指针表项，顾名思义，这是一个指向PDT表（在10-10-12分页下，Cr3指向PDT表的首地址）的元素，且位于PDPT表（PAE分页下Cr3指向PDPT表首地址）中。由于仅剩2位，所以PDPTE只有4个，同样PDPTE每项占8个字节，来看下这个结构。 Avail：下标9~11，共3位，这是留给操作系统使用的位，CPU本身并不使用 Base Address：下标12~35，寻址时，低12位补0，共36位（达到36位，与PTE保持一致，寻址空间达到64GB），即PDT基址 至于PCD和PWT，留到控制寄存器和TLB部分详解。 PDEPAE分页下，PDE扩展到了64位，其余属性变化不大。 PS = 1：大页，下标35-21是大页的物理地址，低21位填0，大页的大小为2MB（10-10-12的大页为4MB），按照2MB对齐。 PS = 0：下标35~12是页表（PTT）基址，低12位补0，共36位。 Avail：同PDPTE PTE与PDE一样，PAE分页下的PTE，也是扩展到了64位，其余变化不大 PTE中下标35-12是物理页基址，共24位（10-10-12分页下是下标31~12，共20位），低12位补0。 物理页基址+12位的页内偏移指向具体数据。 在了解这些结构后，来看一下PAE分页的大致模型 XD位在Intel新系列的CPU中，在下标63的地方多了一个属性位XD位（AMD中称为NX，即No Execetion） 我们知道段的属性有可读、可写和可执行，但是页的属性只有可读、可写。 当ret执行返回语句时，如果堆栈里的数据指向一个提前准备好的数据（把数据当作代码来执行，漏洞很多都是依赖这点，比如SQL注入），这个位的作用就是在硬件上实现一种保护，防止数据可执行的情况发生。 查找物理页PAE分页下查找对应的物理页和10-10-12差不多，拆分线性地址后，再根据PDPI、PDI、PTI偏移去找，由于每项均是8字节，所以在Windbg中使用dq指令进行查看。来看下面这个例子： 变量a的线性地址为：0x12ff7c。按照2-9-9-12进行拆分后得到0-0-12f-f7c。接着通过Cr3一步步查找，具体如下： 变量a的存的值为0x123，通过拆分线性地址，成功在找到变量a对应的物理地址。 0地址挂物理页在学习10-10-12分页时，通过0地址挂物理页的实验，加深对物理页的理解，这里我们通过这个实验进一步熟悉PAE分页。 先运行程序，发现访问违例，运行失败 查看0地址对应的物理页，发现物理页是空的。 然后查看局部变量a对应的物理页，并将a对应的物理页挂到0的位置（注意，挂物理页时，用两次!ed指令而不是!eq指令） 接着运行程序发现可以正确的打印出0地址上的内容 PAE分页下PDT/PTT的基址新增加的结构，PDPTE，并没有R/W位，US位等属性，真正决定物理页属性的还是PDE和PTE。相比10-10-12分页可以通过PDT/PTT基址修改物理页属性，在PAE分页下同样可以做到，这部分我们来研究下PAE分页下PDT和PTT的基址。 逆向分析MmIsAddressValid在前一篇文章中我们分析了10-10-12分页下的MmIsAddressValid函数，它在找到PDE/PTE后会判断下标为0(P位)和下标为7(PDE对应PS位，PTE对应PAT位)的位置的值，进行一些处理工作。而这个函数找到PDE/PTE的过程就使用了PDT/PTT的基址。这次通过分析PAE分页下的MmIsAddressValid函数，来找到PAE分页下PDT/PTT基址。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"逆向分析MmIsAddressValid(10-10-12)","slug":"逆向分析MmIsAddressValid","date":"2020-03-21T03:07:40.000Z","updated":"2020-03-21T08:36:14.300Z","comments":true,"path":"2020/03/21/逆向分析MmIsAddressValid/","link":"","permalink":"http://yoursite.com/2020/03/21/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid/","excerpt":"","text":"在对页表基址，页目录表基址熟练掌握后，今天来看逆向分析一个函数：MmIsAddressValid。这是一个系统函数，可以在ntoskrnl.exe的导出函数中找到它，也可以在Windbg中输入指令 Code1kd> u MmIsAddressValid 查看。 为什么要分析这个函数呢？因为即使是系统函数，也是无法直接使用物理页的，想要去访问PDE和PTE也就一定要通过基址来访问，而今天要分析的MmIsAddressValid函数，就利用了这么一个原理，相比前一篇的基址小实验，这里对于线性地址拆分的过程更为巧妙，让我们一起来看看吧！ 获取PDE属性 首先观察函数主体部分，发现代码并不长，但是有很多跳转，具体跳转内容就不作分析了，主要是分析函数主体： Code1234567891011121314804e4661 8bff mov edi,edi //hotpatch804e4663 55 push ebp804e4664 8bec mov ebp,esp804e4666 8b4d08 mov ecx,dword ptr [ebp+8] //取第一个参数（线性地址）804e4669 8bc1 mov eax,ecx //赋值到中间变量，方便运算804e466b c1e814 shr eax,14h //逻辑右移20位804e466e bafc0f0000 mov edx,0FFCh 804e4673 23c2 and eax,edx //和操作数进行与运算，同时清空最后2位；相当于做了一个乘4的运算，既左移2位804e4675 2d0000d03f sub eax,3FD00000h //进行减法运算，相当于eax+0xC0300000804e467a 8b00 mov eax,dword ptr [eax] //取PDE的值804e467c a801 test al,1 //判断PDE属性P位是否为1804e467e 0f84d2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e4684 84c0 test al,al //判断下标为7的位(PS位)值是否为1804e4686 7824 js nt!MmIsAddressValid+0x53 (804e46ac) 巧妙的与运算： 首先将线性地址逻辑右移20位，此时还余下12位 将这12位和操作数0xFFC做一个与运算，0xFFC换算成2进制就是1111 1111 1100。因此做完与运算后，刚刚经过第一步操作还剩下12位的数的低2位，置0了。熟悉移位运算的朋友们知道，这个12位的数，相当于1个10位的数逻辑左移2位得到，换句话说就是将这个10位的数乘4。而这个10位，就是PDI，因此这步操作完了以后，相当于我们获得了PDI*4的值。 接下来，与0x3FD00000做减法运算，作用相当于加上0xC0300000，两种方法的结果是一样的。因此，我们得到了0xC0300000 + PDI*4的值，而这个值，恰恰就是我们要找的PDE，接着只需要取出里面的值，就可以获取PDE的属性了 后续跳转再获取PDE的属性后，会遇到两个跳转，简单的概括下： 首先会判断PDE下标为0的位置的值，也就是P位，当P位为0时，说明物理页无效，会跳转到一个相应的处理函数，这里就不再跟进分析 若物理页P位为1，就会来到第二个跳转，这里test al, al指令会修改标志寄存器，当al的最高位，也就是下标为7的位置值为1时，会被认为是负数，此时会修改EFLAG寄存器的SF位。这时，在第二个跳转的位置，js判断的就是SF的值是否为1，若为1，也就是al下标为7的位置值为1，这是对应的PDE属性PS位，说明这是一个4MB的大页，进而会跳转执行相应的处理函数。 获取PTE属性Code123456789101112804e4688 c1e90a shr ecx,0Ah //逻辑右移10位804e468b 81e1fcff3f00 and ecx,3FFFFCh //和操作数进行与运算，同时清空最后2位，相当于PDI左移12位+PTI左移2位804e4691 81e900000040 sub ecx,40000000h //进行减法运算，相当于eax+0xC0000000804e4697 8bc1 mov eax,ecx804e4699 8b08 mov ecx,dword ptr [eax] //获取PTE属性804e469b f6c101 test cl,1 //判断P位的值是否为0804e469e 0f84b2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e46a4 84c9 test cl,cl //判断PAT是值是否为1804e46a6 0f88b6de0300 js nt!MmIsAddressValid+0x3f (80522562)804e46ac b001 mov al,1804e46ae 5d pop ebp804e46af c20400 ret 4 巧妙的与运算Code1and ecx, 3FFFFCh 假设线性地址右移10位后的值为 0000 0000 00aa aaaa aaaa bbbb bbbb bbxx（a, b的值为0或者1，这里只是为了区分PDI和PTI） 然后我们来拆分0x3FFFFC的值：0000 0000 0011 1111 1111 1111 1111 1100 将两者进行与运算后得到结果为 0000 0000 00aa aaaa aaaa bbbb bbbb bb00 我们知道，aa aaaa aaaa应为PDI，而bb bbbb bbbb应为PTI，因此可以把得到的结果看作是这样的一个运算：$$aa aaaa aaaa","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://yoursite.com/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"基址小实验","slug":"基址小实验","date":"2020-03-20T15:14:53.000Z","updated":"2020-03-20T16:16:41.088Z","comments":true,"path":"2020/03/20/基址小实验/","link":"","permalink":"http://yoursite.com/2020/03/20/%E5%9F%BA%E5%9D%80%E5%B0%8F%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"在学习完页目录表基址，页表基址后，我们知道通过C0300000和C0000000这两个地址，可以访问相应的PDE和PTE，今天就来实践一下。 之前在介绍PDE/PTE属性R/W位时有过一个实验，是对位于常量区的内容进行修改，当时通过Windbg修改了所在PDE/PTE的R/W位。这次实验，我们利用页目录表/页表基址来进行修改。 测试原始代码 首先测试原始代码，发现直接修改常量区的字符串，是会失败的 提权进入0环提权这里还是会用到Windbg，根据调用函数的地址，填入段选择子，并通过调用门进行提权（就当复习调用门知识了） 修改R/W位提权进入0环后（为啥要提权呢？因为C0300000/C0000000都属于高2G的线性地址，3环没法直接访问），就到了我们最关键的步骤了，修改R/W位。 c123456temp = *(int*)0xC0300004;temp = temp|0x2;*(int*)0xC0300004 = temp;temp = *(int*)0xC000108C;temp = temp|0x2;*(int*)0xC000108C = temp; 在这之前声明了一个中间变量temp（int类型）。 具体步骤： 打印出字符串所在常量区的地址0x423fb0，进行拆分：10-10-12 -> 0x1-0x23-0xfb0 PDI = 0x1，带入公式：PDE = C0300000 + 0x1 x 4 PTI = 0x23，带入公式：PTE = C0000000 + 0x1 x 1000 + 0x23 x 4 分别取PDE和PTE处的值，并和0x2进行或运算（将R/W位置1） 这样就完成了对R/W位的修改，在接下来再次对常量区的值进行修改操作时，便可以成功。 完整代码c123456789101112131415161718192021222324252627282930313233343536373839#include \"stdafx.h\"int temp;__declspec(naked) void ModifyRW() { __asm { pushad pushfd } temp = *(int*)0xC0300004; temp = temp|0x2; *(int*)0xC0300004 = temp; temp = *(int*)0xC000108C; temp = temp|0x2; *(int*)0xC000108C = temp; __asm { popfd popad retf }}int main(int argc, char* argv[]){ char* str = \"hello\"; char buffer[6] = {0, 0, 0, 0, 0x4B, 0}; printf(\"addr: %x, str: %s\", str, str); getchar(); _asm { call fword ptr buffer } *str = 'a'; printf(\"str: %s\", str); getchar(); return 0;}","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"页目录表、页表基址","slug":"页目录表、页表基址","date":"2020-03-20T07:11:51.000Z","updated":"2020-03-20T14:22:35.004Z","comments":true,"path":"2020/03/20/页目录表、页表基址/","link":"","permalink":"http://yoursite.com/2020/03/20/%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E3%80%81%E9%A1%B5%E8%A1%A8%E5%9F%BA%E5%9D%80/","excerpt":"","text":"考虑这样一个问题，我们现在可以通过在Windbg里找到线性地址所在的物理页，通过修改物理页的属性，就可以实现一些原本受限的功能。例如将常量区对应的物理页R/W属性修改为1，便可以修改位于常量区的元素。 但是，以上操作都是基于Windbg在双击调试的环境中实现的，那么一旦脱离了调试器，该如何通过代码来实现对物理页属性的修改呢？这就需要借助于页目录表基址和页表基址了。 页目录表基址结论：C0300000就是页目录表基址，接下来我们来验证这个结论。 C0300000拆分C0300000： 1100 0000 0011 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 11 0000 0000 300 12 0000 0000 0000 0 Cr3这里以记事本(notepad.exe)为例，来验证一下，C0300000就是页目录表基址，首先查看记事本对应的Cr3指向的物理地址。 我们知道，Cr3指向的是PDT的首地址，这里可以看到4个PDE有值。 查看C0300000物理页接下来的步骤就是比较熟悉的，根据拆分后的线性地址，寻找物理页的过程了。但是这一次，要慢点看。 这一步很容易理解，Cr3.base + 300*4，通过Cr3和线性地址的前10位，我们找到了PDE的值：7ea49063 什么？又重复了一遍？实际上不是，由于PDE的值为7ea49063，后12位是属性位，因此，7ea49000是我们要找的PTT的首地址，然后通过PTT.base + 300*4，就得到了PTE的值：7ea49063。 有了PTE的值，加上最后12位的偏移（此处为0），就可以找到物理页。 得到结果后，是不是很惊讶？C0300000这个线性地址对应的物理页上的物理地址，竟然和Cr3指向的物理地址完全一样！也就是说，以后不需要Cr3，只需在当前程序内，通过C0300000这个线性地址就可以得到当前程序PDT的首地址了 如何利用是啊，C0300000这个地址有啥用呢？当然有用，而且非常有用。回到文章开头的问题，我们该如何在不使用Windbg的情况下，修改物理页的属性呢？ 我们知道，想要修改物理页的属性，需要先修改物理页对应的PDE和PTE，那要如何找到PDE和PTE呢，由于在编写代码时，用到的都是线性地址，而C0300000这个线性地址刚好就可以找到PDT的首地址，这样我们拆分想要修改的物理页属性的线性地址，将前10位加上C0300000即可找到对应的PDE。 既然PDE找到了，那不就有了PTT的首地址，这样PTE不也就可以找到了吗？并不是这样，尽管找到了PDE，但是由于PDE里面存着的是物理地址，如果直接访问PDE里面存的那个地址，在代码中会转变为一个线性地址，因此并不能通过PDE获取PTT的首地址，也就不能获取到PTE了，想要找到PTE，还得需要用到另外一个基地址，就是页表基址。 页表基址还是直接上结论，页表基址：C0000000 接下来我们来验证。 C0000000拆分C0000000： 1100 0000 0000 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 00 0000 0000 0 12 0000 0000 0000 0 Cr3这里还是以记事本(notepad.exe)为例： 我们查看Cr3指向的物理地址，当前共有4个PDE的有值的，而PDE的值，就是PTT的首地址，以第一个PDE（36c24067）为例，其中PTT的首地址为36c24000。 查看C0000000物理页步骤和之前一样，就直接看结果好了。 发现，C0000000这个线性地址所对应的物理页，刚好是36c24000，也就是第一个PDE对应的PTT的首地址。由此可以进一步推断，C0001000则是第二个PDE对应的PTT的首地址，以此类推。 再看10-10-12分页现在再来看10-10-12分页时，看法就会有所不一样了。 实际上页表（PTT）被映射到了从0xC0000000到0xC03FFFFF的4M地址空间 在这1024个表中有一张特殊的表：页目录表（PDT） 页目录表（PDT）被映射到了0xC030000开始处的4KB大小的地址空间 总结有了0xC0300000和0xC0000000能做什么？掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。 公式总结： 什么是PDI和PTI？ 将32位线性地址拆分位10(PDI)-10(PTI)-12 访问页目录表(PDT)的公式：0xC0300000 + PDI x 4 访问页表(PTT)的公式：0xC0000000 + PDI x 1000 + PTI x 4（不用*号因为会被转义） 其它关于页的细节 高2G有一些大页，即4MB页 两个进程低2G几乎不同，高2G几乎相同 一个进程低2G的内存空间，前64K与后64K是没有使用的（线性地址0 - 00010000 与 7FFF0000 - 7FFFFFFFF） 谁填充了这些表呢进程本身可以通过0xC0300000和0xC0000000访问修改任意物理页，那么是谁为我们填充0xC0300000和0xC0000000的PDE与PTE呢？ 进程的创建过程：当创建B进程时，先在A进程中将B进程所有信息全部构建好，然后切换Cr3即可。也就是说，最开始的这张表是由A进程填充的。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"PDE_PTE属性（部分）","slug":"PDE-PTE属性","date":"2020-03-19T12:37:33.000Z","updated":"2020-03-19T15:51:12.795Z","comments":true,"path":"2020/03/19/PDE-PTE属性/","link":"","permalink":"http://yoursite.com/2020/03/19/PDE-PTE%E5%B1%9E%E6%80%A7/","excerpt":"","text":"上一篇文章中了解了PDE和PTE，这一篇就来了解一下PDE和PTE的属性。 物理页的属性 一上来看这张图，肯定是一脸懵逼的。先从行开始看，第一行是关于CR3寄存器的，这部分留到控制寄存器的章节再分析。接下来三行是不同类型PDE的，最后两行是PTE的。其中PDE和PTE有很多属性是重合的。而物理页的属性，就是有PDE和PTE共同决定的。计算方法是将相同属性位的值进行与运算。 物理页的属性 = PDE属性 & PTE属性 P位 首先来看P（Present）位：存在位。PDE与PTE的P位均位1时，物理页有效；其余情况，物理页不存在。这也解释了为什么PDE的第三行和PTE的第二行可以直接忽略。 在上一篇文章中，有一个关于0地址赋值的实验。0地址之所以不能赋值是因为它的PTE的P位为0，在我们修改了PTE的P位，并给它挂上一个物理页后，0地址遍可以赋值了。 R/W位 R/W = 0 只读 R/W = 1 可读可写 R/W很好理解，控制写的权限呗，这个位有何用呢？来看一个小实验。 c123456789101112131415#include \"stdafx.h\"int main(int argc, char* argv[]){ char* str = \"hello\"; printf(\"%x\", str); getchar(); *str = 'a'; printf(\"%s\", str); getchar(); return 0;} 来看这个代码，很明显，执行会是失败的，因为用char*定义的字符串，是会存储在常量区，而不是堆栈中了，又因为常量区的值是不允许修改的，因此 c1*str = 'a'; 这条语句会执行失败并报错。 那为什么常量区的内容就不可修改呢？其实，说白了，就是常量区挂着的物理页的R/W属性为0，因此只能读，不可写，既然知道了原因，我们只要修改了常量区所在物理页的属性，将R/W位置1即可。 通过printf语句先打印出所在常量区的线性地址，接着拆分跟进PDE和PTE中（具体步骤省略） 可以发现，PTE的R/W位值为0，因此将其修改为1写入，随后运行程序发现，可以成功修改字符串首地址出的字符！ P/S位 P/S（PageSize）位，只对PDE有意义，位于PDE的第7位。 PS = 1 PDE直接指向物理页，无PTE，低22位为页内偏移。线性地址只能拆成两段（10-22）：页的大小为2的22次方，也就是4MB，俗称“大页”，大页比较少，一般出现在高2G中 PS = 0 就是我们比较熟悉的10-10-12分页，页的大小为4KB U/S位 U/S（User/System）位，位于PDE/PTE的第2位。 U/S = 0：特权用户 U/S = 1：普通用户 三环程序是不能读写高2G内存的，原因在于高2G内存对应的物理页U/S位被置0了，也就是说只有特权用户才能读写高2G的内存。所以，当普通用户想要读取高2G内存时，就可以把U/S置1，这样就可以访问高2G内存了。 当然，理论如此，不过除了U/S位外，影响高2G内存读写的还有PCD位和PWT位，这部分内容也要到控制寄存器部分才能讲，所以第二种3环程序读写高2G实验（第一种是通过门提权），就要放到后面实现了，这里只要先记住，U/S位是影响访问读写权限的。 与R/W的区别这里需要注意一下U/S位与R/W位的区别，U/S位的读写控制是根据用户的级别，而R/W位的控制是直接控制读写，不管你是不是特权用户。 A位 A（Accessed）位于PDE/PTE的第5位：表示该物理页是否被访问（读或者写）过，访问过置1，即使只访问一个字节也会导致PDE，PTE置1。 D位 D（Dirty），脏位，是否被写过。0表示没有被写过，1表示被写过 总结以上是关于PDE/PTE部分属性的含义，还有一部分位没有涉及到，例如G位，PWT位，PCD位，这些需要讲到控制寄存器和TLB相关概念时再细讲。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"10-10-12分页","slug":"10-10-12分页","date":"2020-03-18T12:55:20.000Z","updated":"2020-03-19T13:43:58.205Z","comments":true,"path":"2020/03/18/10-10-12分页/","link":"","permalink":"http://yoursite.com/2020/03/18/10-10-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"保护模式下内存管理方式分为两种，段与页。前面的篇章中，简要介绍了段的知识，今天就来和大家聊聊页的知识，页是保护模式中更为重要的一环，随着系统进入32-Bit，段的作用明显降低了，取而代之的则是在段的基础上，更为细分的页。 段与页 这是Intel白皮书中介绍关于段与页的概要图，经过段的学习，可以很容易的理解左半部分，这是一个根据所提供的有效地址（图中Offset）以及段寄存器中确定的基址，锁定线性地址空间中的某个线性地址（图中Lin.Addr.）的过程。而右半部分，则是利用了页的功能，通过拆分线性地址，一步步转化成了物理地址。 上述提到了3个概念，有效地址，线性地址以及物理地址，文字叙述会让人混淆，我们来看一条语句： Code1mov dword ptr ds:[0x12345678], 0x123 其中，0x12345678是有效地址 ds.Base + 0x12345678是线性地址 这都非常好理解，那什么是物理地址呢？考虑这样一个问题，掌握3环知识的小伙伴们知道每个进程都有4GB的内存空间，这时如果有一个进程A，给会进行一个操作，给ds.Base + 0x12345678赋值0x123，还有一个进程B，同样会给ds.Base + 0x12345678赋值0x123，那么ds.Base + 0x12345678处的位置到底是哪个值呢？还是两者都不是呢？这就涉及到了物理地址的概念。 PDT与PTT每个进程都有一个CR3的值，这很突兀，CR3是什么？实际之前在TSS切换时也用到了，具体等到了控制寄存器那会详细分析。简单来说，CR3被用来切换和定位当前正在使用的页表，它是一个32位的寄存器，其中高20位指向一个物理页（Windows系统上，一个页的大小是4KB，也就是4096个字节），如下图所示： 这图该怎么看呢？首先CR3会指向一个物理页，这个物理页又叫做页目录表（PDT），页目录表每个元素叫做页目录表项（PDE），页目录表项，每个4字节，所以一共有1024个页目录表项，CR3就好比一本书，PDT就是这本书的目录，PDE就是章节，这是一本有1024个章节的书（哇塞，真厚啊U•ェ•*U），这样就好理解多了。这是第一级。 页目录表项又指向一个第二级的表，叫做页表（PTT），页表的大小也是4KB，页表中的每个元素叫做页表项（PTE）。页表项可以理解为书中章节的每个小节，就好比第一章里面有1024个小节，这个小节就是PTE，这1024个小节加起来，构成一个小节表，就是PTT。 第二级介绍完了，第三级也就好理解了，既然书中每个章节的每个小节理解了，接下来就是页码了，每个小节都会对应书中的某个页码。而这个页码，就是相当于的物理页了。这样就可以理解这张图了，就是一部部找到物理页。 10-10-12分页Windows采用三种分页方式，在32位系统上主要有10-10-12分页和2-9-9-12分页这两种方式，在64位系统上增加了9-9-9-9-12这种分页方式，后面的文章会依次介绍32位下的两种分页方式。首先从10-10-12开始。 首先修改C盘的boot.ini文件，将noexecute改成execute，重启虚拟机，即可使用10-10-12分页方式 10-10-12分页是如何工作的呢？来看一个简单的程序： c123456789#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); return 0;} 这个程序很简单，给a赋值0x123，并查看a的地址 而这个地址0x12ff7c，实际上就是前文提到的线性地址，接下来我们将这个32位的地址按照10-10-12的方式进行拆分： 1.将0x12ff7c拆分成二进制：0000 0000 0001 0010 1111 1111 0111 1100 2.将这32位二进制数，按照10-10-12的方式组合： 每部分位数 二进制 十六进制 10 0000 0000 00 0 10 01 0010 1111 12f 12 1111 0111 1100 f7c 3.根据Cr3找到页目录表（PDT）中的页目录表项（PDE）： 首先在Windbg中执行!process 0 0指令，找到当前程序的Cr3，Cr3的值指向的就是页目录表的首地址。由于第一部分值为0，所以要查找的PDE，需要用Cr3+0*4(乘4是因为每个PDE大小是4字节)，这里注意一下，由于查找的是物理地址，所以使用的是!dd指令。 4.根据PDE找到页表（PTT）中的页表项（PTE）： 上一步已经找到了PDE，PDE的值指向的是某个PTT的首地址，方法和上一步一样，用PDE中的值+12f(拆分完的第二部分)x4，就可以得到PTE，这里要注意一点，将PDE中的值代入时，后12位置0，由于后12位为属性位，在查找的过程中不起作用 5.根据PTE确定物理地址： 确定PTE后，就剩最后一步了。由于一个物理页的大小本身就是4KB，也就是2的12次方，所以当确定了前20位后也就确定了物理页，因此我们要找的内容就在219da000这个物理页上的某个物理地址。这个物理页的范围是219da000~219dafff。现在可以理解，PTE指向的是一个物理页的首地址，根据最后12位的来确定，我们要寻找的值在物理页上的偏移，也就真正的找到了这个物理地址。 根据实验截图，发现我们一开始存在变量a里面的0x123，真正存的地方在0x219daf7c这个物理地址的位置，这就是通过线性地址一步步的找过来的，这些工作都是CPU做的，比如当我们读取a这个地址上的值是，CPU会通过分页机制读取该物理地址的值，然后再显示出来。 有趣的实验读错值了？有了10-10-12分页的知识，来做一个有趣的小实验 c1234567891011#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); printf(\"%x\", *(&a)); getchar(); return 0;} 这个代码非常简单，一般人认为，会先输出a的地址，然后再输出0x123。但有了物理页的知识，我们就可以做一些手脚了。 很奇怪吧？为什么输出不是0x123，而却输出0x456呢？原因就在于，我们偷偷修改了变量的物理地址上的值，将原本的0x123改成了0x456，因此，CPU再次去物理页读取时，值已经发生了变化，读到了修改后的值。 0地址也能存值？c1234567891011121314#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 1; printf(\"%x\", &a); getchar(); *(int*)0 = 0x123; printf(\"address0: %x\", *(int*)0); getchar(); return 0;} 这是个显而易见运行会失败的程序，为什么？因为你给0地址赋值了，有点C/C++开发经验的人都知道，0地址是不能存值的，为什么？因为运行不过去啊！这不扯淡嘛！你看我就运行过去了！ 这又是为什么呢？其实0地址不能存值的原因是，没有给它挂物理页，既然没有物理页，那CPU按照分页去查的时候，就查不到了；那么只要给他挂个物理页，就可以给这个线性地址存值了，具体操作如下。 总结 一张页表能包含的物理页：1024*KB = 4MB 10-10-12分页共有1024张页表：1024*4MB = 4GB 前20位的值如果相同，那么一定在同一个物理页 一个PTE最多可以指向一个物理页；PTE可以没有物理页；多个PTE可以指向同一个物理页 参考资料：《Intel白皮书第三卷第四章》 参考教程：https://www.bilibili.com/video/av68700135?p=24","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务门","slug":"任务门","date":"2020-03-17T01:10:51.000Z","updated":"2020-03-17T03:46:00.956Z","comments":true,"path":"2020/03/17/任务门/","link":"","permalink":"http://yoursite.com/2020/03/17/%E4%BB%BB%E5%8A%A1%E9%97%A8/","excerpt":"","text":"为何使用任务门之前任务段中提到，进行任何切换时可以还可以使用任务门。那么既然存在TSS段描述符了，为何还需要任务门呢？ 简要概括，任务门有如下优势： 任务门可以放在GDT表中，也可以放在IDT表中，还能放在当前线程的LDT表中，而TSS段描述符只能在GDT表中 任务门可以让低权限的线程进行任何切换，任务门的结构中也有DPL属性，当通过任务门去访问TSS描述符时，一旦通过任务门，TSS段描述符就不再进行检查了，即使你是个CPL=3的程序，而TSS段描述符的DPL=0，只要任务门DPL=3，就可以通过任务门完成任务切换，稍后会做这个实验。 由于任务门可以位于IDT表中，所以当遇到中断或者异常时，可以切换到独立的任务去处理异常 下面为不同表中，任务门进行任务切换的过程： 任务门描述符 任务门描述符的结构非常简单，真正用到的只有24位，属性位里：DPL一般设置为3，方便应用程序访问，Type则是固定的0101，TSS段选择子，顾名思义，就是一个段选择子，指向位于GDT表中TSS段描述符的位置。其余位均为保留位，置0即可。 任务门实现任务切换这一步十分简单，仅仅比使用TSS多了一个步骤而已，这里也不细讲了，直接上步骤。 首先，编译源文件，下断点，确定TSS的地址，根据地址构造TSS段描述符： 第二步，根据GDT表中构造好的TSS段描述符位置，在IDT表中构造任务门： 第三步，在Windbg中使用!process 0 0指令确定CR3的值，并填入自己的TSS中： 执行程序，获取到自己构造的TSS表数据，任务切换成功： 总结任务门总体还是比较简单，由于是通过int 0x20中断进入，因此iretd作为中断返回出来，比起JMP FAR还需要手动修改EFLAGS的NT位和previous task link容易的多。比较遗憾的是，这一部分的小作业，通过任务门进1环，还是失败了。这里稍微说一下我的思路，由于是进入1环（虽然windows没用1环），但我们让他进入1环，就替换1环的寄存器，ESP1和SS1，当然SS1和CS都需要设置CPL值为1，但是原本0环这两个段寄存器控制的都是DPL=0的段，因此我们需要构造一个1环的段描述符，我实验的时候构造了一个1环的非一致代码段描述符和一个1环的数据段描述符，让任务切换后的CS，SS载入段描述符信息用。同时还需要把TSS段描述符的DPL设置为1，其余值保持不变。可惜，几次都死掉了，实验没能成功，群内也没人这个进入1环的实验，以后有人讨论的话会考虑再试试。 任务段任务门这里有些遗憾吧，的确有点复杂，没理解透彻，感觉任务段那讲的也不是很清晰，希望以后我还能看得懂吧，接下来进入页的内容了，保护模式的关键来了，得掌握好。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务段","slug":"任务段","date":"2020-03-16T12:41:30.000Z","updated":"2020-03-16T17:07:35.399Z","comments":true,"path":"2020/03/16/任务段/","link":"","permalink":"http://yoursite.com/2020/03/16/%E4%BB%BB%E5%8A%A1%E6%AE%B5/","excerpt":"","text":"要点回顾在调用门、中断门与陷阱门中，一旦发生权限切换，那么就必有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。这时问题来了，我们知道EIP和CS的值都可以通过门描述符获得，那么ESP和SS是哪来的？这就是引出了今天的内容：TSS（Task-state segment），任务状态段。 TSS设计初衷想要学习一类知识，首先要了解它被设计出来的目的，这样就能找到方向，更好的了解它。CPU在运行时会频繁的切换任务，每次切换任务时，还没执行完的任务怎么办？总不能下次重新执行吧，于是需要保存上一个任务的上下文环境，于是，TSS诞生了，TSS是一块大小为104(0x68)个字节的内存，没错，TSS不是什么寄存器，就是一段内存，或者说是一个段，这段内存可以保存32-Bit下所有通用寄存器以及段寄存器的值，这样CPU就可以切换到新任务时，仍然保留上一个任务的环境，方便新任务执行完后，能够完好的回到先前的任务继续执行。 注意，TSS是一个段，有段就有段寄存器和段描述符哟！比如我们熟悉的CS，CS就是段寄存器，它描述的是代码段，同时，它会通过段选择子从GDT表的代码段描述符中载入段的相关信息，通常情况下，代码段的范围是0~FFFFFFFF（大小是4GB）；这样一对比，就可以理解了，TSS也是如此，因为TSS也是一个段（大小是104字节），所以应该存在一个描述TSS的段寄存器从一个段描述符里加载TSS相关信息。这就是今天会依次介绍的TR寄存器和TSS段描述符。 这里补充一点知识，尽管Intel设计TSS的初衷的为了方便任务切换（CPU层面叫做任务切换，操作系统层面叫做线程切换），但是Windows认为这个TSS设计的不好，因此并没有采用这个结构进行线程切换，并且Linux也没有采用TSS进行线程切换，这俩操作系统用的都是堆栈进行线程切换的。那么Windows用到了这个结构没有，当然是用到了，但仅仅用到了ESP0和SS0这两个值。 TSS结构先来看看TSS的结构 大部分都应该比较熟悉，这里介绍几个较为陌生的字段： Previous Task Link：这里保存的是上一个TSS的段选择子，比如任务发生了切换，新任务执行完后，如何才能找到先前未能执行完的任务呢？就得依靠这个值了（前面不是说了Windows不用TSS进行线程切换嘛，是呀，但是这里讲解的这个字段的作用，设计初衷就是为了任务切换） ESP0/SS0：当发生提权时，0环的ESP和SS的值就是从这里取的 CR3：有人会问，我哪知道取哪个TSS的ESP0和SS0呢？就是这个值的作用了，这个值帮我们确定当前位于哪个线程，之后在页的篇章中会学到CR3的相关内容。 LDT：这个值通常都是0，Windows没有用到LDT表，因为LDT表只对当前的线程有用 I/O Map：这个位置涉及到硬件IO了，值一般是固定的 TSS段描述符 TSS段描述符只能存在GDT表中，不能存到LDT或者IDT中，所以它的结构和之前介绍的段描述符是类似的，区别在于个别位的不同 G位：在代码段/数据段描述符中，这个位置通常位1，因为这两个段的范围通常是4GB，而TSS的大小是104字节，单位是字节，因此这个值为0 Type域：这个值为1011或1001，其中B位是Busy位，置1时说明该TSS是否被载入或者嵌套，载入说明CPU正在执行该任务；嵌套则表明该任务处理了一半，切换到了另一个任务中去，但该任务并未执行完。 Base/Limit：Base确定TSS段的起始位置，Limit确定TSS段的大小，Base~Base+Limit就是TSS段的范围。 TR寄存器在一开始的探究段寄存器的文章中提过，CPU共有8个段寄存器，TR就是其中之一。先前提到过，TR寄存器的工作原理和其它段寄存器一样，通过段选择子加载GDT表的TSS段描述符中的信息，方便CPU找到TSS的位置，具体工作原理如下： 这里介绍两个操作TR段寄存器的指令LTR和STR： LTR：这是一个特权指令，只有0环的程序才能调用；作用是将段选择子写入TR寄存器 STR：STR不是特权指令，这个指令3环程序也可以调用，所用是读取TR寄存器的值 需要注意的一点，修改TR寄存器的值，只是会载入新的TSS段描述符信息，并不会对修改前的TSS段造成影响。 实现任务切换虽然说了Windows并没有将TSS用来进行线程切换，但是我们仍然可以手动实现任务的切换。 直接修改TR寄存器是不能做到任务切换的，但是可以通过JMP FAR或者CALL FAR来加载TSS段描述符来实现。下面分别使用两种方法来实现（两种实现方法细节有很多差别） 一般情况下，任务切换发生在下列四种情况之一： 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表中的TSS段描述符 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表或者当前LDT表中的任务门描述符 一个中断或者异常触发了在IDT表中的任务门描述符 当前任务执行IRET指令，且EFLAGS寄存器的NT位为1时 CALL FAR实现本次CALL FAR实现采用第一种任务切换的情况。 设计一个TSS，存储任务切换时必要的信息，其中包括ESP0，SS0，CR3，EIP，ESP，段寄存器，位图控制。 ESP0：也就是任务切换后的堆栈，可以自己创一个空数组，然后写入数组的首地址，就可以作为堆栈使用。 段寄存器及SS0：这些值，在0环通常都一样，可以进入Windbg参考其它TSS的值，这里使用的是SS/SS0 = 0x10，ES/DS = 0x23，CS = 0x8，FS = 0x30，GS = 0x0 EIP：这就是要跳转后执行的地方，可以写一个裸函数来验证是否切换成功，直接取裸函数地址即可，我这里的值为0x401020（每个人机器可能不一样） CR3：这个值，需要在执行前，中断到Windbg寄存器中，通过!process 0 0指令获取。 位图控制：这是一个默认值为0x20AC0000 构造完的TSS如下： c12345678910111213141516171819202122232425262728DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; 然后我们需要根据这个TSS的地址，来构造我们的TSS段描述符 地址为0x12fd70 因此TSS段描述符为：0000e912`fd700068，e->DPL=3：是为了3环的程序可以访问这个段描述符，0x68就是104字节，9说明未被载入。然后让我们填入段描述符 接着运行程序，需要采集Cr3的值，先中断到Windbg，再通过!process 0 0指令获取，取最后的一个值 在程序中填入cr3的值后回车，发现可以成功取到任务切换后ESP，CS，SS，并且均为我们设定的值，实验成功。 完整代码如下： c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include \"stdafx.h\"#include int saveEax, newESP;short newCS, newSS;__declspec(naked) void Get_Value() { __asm { mov saveEax, eax mov newESP, esp mov ax, cs mov newCS, ax mov ax, ss mov newSS, ax mov eax, saveEax iret }}int main(int argc, char* argv[]){ char stack[100] = {0}; char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; int Cr3 = 0; printf(\"Input: \"); scanf(\"%x\", &Cr3); getchar(); DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; _asm { call fword ptr buffer } printf(\"ESP: %x, cs: %x, ss: %x\", newESP, newCS, newSS); getchar(); return 0;} 以上是通过Call Far实现的任务切换。还有另一种方法，是通过JMP FAR来实现，而且JMP FAR实现会更加困难一些。这里简要概括一下，当使用CALL FAR时，CPU会自动帮你用当前任务的段选择子填写你TSS的Previous Task Link字段，同时给你的Eflags的NT位置1，这个NT位有什么用呢，就是关系到iret这个指令的意义，当Elfags的NT为1时，iret表示根据Previous Task Link的值，从当前任务返回到前一个任务中去，当NT为0时，这是一个中断返回指令。而当你使用JMP FAR实现时，你需要手动给Pervious Task Link字段赋上前一个任务的段选择子，此外你需要手动给Eflags的NT位置1，当然这可以通过 Code12345pushfdmov eax, [esp]or eax, 0x4000mov [esp], eaxpopfd 来实现，此外，还需要确保前一个TSS段的段描述符Busy位的值为1，这样才能确保该任务处在嵌入的状态。 总结这是开博客以来，最艰难的一篇了，看视频楞是没看明白，然后又去翻Intel白皮书，看明白了然后开始代码实现，CALL FAR的任务切换实现的还算顺利，但是JMP FAR的问题就比较大了，一下午都没整出来，蛋疼啊~ 不想再弄了，看了群友的代码，感觉自己好像也没写错，就是一直死。明天打算整一整任务门吧，完了就到页的知识了，那边掌握的还算不错，可以轻松一阵子了，坚持呀！ 参考资料：《Intel白皮书卷3-第七章》","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"陷阱门","slug":"陷阱门","date":"2020-03-15T08:31:07.000Z","updated":"2020-03-15T10:56:29.726Z","comments":true,"path":"2020/03/15/陷阱门/","link":"","permalink":"http://yoursite.com/2020/03/15/%E9%99%B7%E9%98%B1%E9%97%A8/","excerpt":"","text":"这一篇来说陷阱门，陷阱门这东西，就没什么好讲的，应该Windows几乎没怎么用，陷阱门也是位于IDT表里的，列出前48个描述符，就没有陷阱门。。。 陷阱门描述符 看图，陷阱门描述符，和中断门描述符，就1个位不一样，中断门的Type域是1110，陷阱门是1111 代码实现代码实现也和中断门的完全一样，搬过来就行了。 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 与中断门的差别那可能有人要问了，既然陷阱门和中断门完全一样，有什么存在的意义。那还是有一点不同的，来看两次执行的结果： 同样的代码，执行结果不同，可以发现，陷阱门和中断门的区别在于，中断门执行后EFLAG寄存器的值发生了改变，而陷阱门不会改变EFLAG，这就是陷阱门和中断门的差别。 EFLAG寄存器结构 根据EFLAG寄存器的结构可以得知，中断门执行后，将IF位置0了，但陷阱门不会，这就是中断门和陷阱门的唯一区别。 那么这个IF位有什么用呢？为什么陷阱门要将IF位置0呢？ 稍查资料，可以了解到IF标志是用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。IF标志对不可屏蔽中断没有影响。 这里举个简单的例子说明下什么是可屏蔽中断，什么是不可屏蔽中断。打开任务管理器，可以看到有很多进程正在运行，这时候，你想把电脑锁屏，于是按下Win+L，这个时候键盘会向CPU发送一个可屏蔽中断，告诉CPU，用户按下了Win+L键，需要执行锁屏功能，如果此时EFLAG的IF位为1，这是CPU会短暂放下手上的任务，先去处理你的锁屏任务，处理完后，你的电脑锁屏了，CPU会继续运行刚刚处理的进程；如果此时ELFAG的IF位为0，那么CPU就和没听到一样，继续做它自己的事。如果遇到意外状况，电脑的电源线拔了下来，断电了，这时电源会向CPU发送一个不可屏蔽中断，这个中断不受IF位影响，CPU一定会去处理。这时有人会问了，断电后CPU还怎么工作？其实在主板上，是有电容的，可以在断电后让CPU再去做一些清理工作，这就是不可屏蔽中断。 总结中断门和陷阱门的唯一区别：中断门执行时，将IF位清零，但陷阱门不会。 参考教程：https://www.bilibili.com/video/av68700135?p=20","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"中断门","slug":"中断门","date":"2020-03-15T06:26:54.000Z","updated":"2020-03-15T08:13:54.134Z","comments":true,"path":"2020/03/15/中断门/","link":"","permalink":"http://yoursite.com/2020/03/15/%E4%B8%AD%E6%96%AD%E9%97%A8/","excerpt":"","text":"上一篇提到过，Windows是不使用调用门的，所以在GDT表里没有找到调用门，那么Windows如何实现代码跨段，提权等行为呢？这里用的较多的是中断门，接下来就来介绍一下中断门。 IDT表与GDT的区别首先要提到IDT表（中断描述符表），在上一篇提到的调用门的门描述符，都在GDT表里，而中断门的门描述符在另一张叫做IDT的表里面。同GDT一样，IDT也是由一系列描述符组成的，每个描述符占８个字节。但需要注意的是，IDT表中的第一个元素不是NULL。 在Windbg中查看IDT表的基址和长度： IDT的构成IDT表可以包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 中断门执行流程有了IDT表的概念后，咱们就可以开始讲讲中断门的执行流程，实际上和调用门差别不是很大，可以类比的来看： 执行调用门的指令：CALL CS:EIP，其中CS是段选择子，包含了查找GDT表的是一个索引. 执行中断门的指令：INT N，其中N是IDT表的一个索引 执行流程就只有这个差别，当CPU通过N这个索引在IDT表中找到了中断门描述符后，执行的步骤就和调用门的步骤完全一样了，可以参考调用们的执行流程。这里要注意一点，当找到中断门描述符后，还是会通过描述符里的段选择子，去GDT表中找需要跳转的代码段。所以说中断门的执行会查找两张表，先查找IDT表，再查找GDT表。 中断门描述符简要说完了IDT表（实际上和GDT表没啥差别）来看看中断门描述符的结构： 粗略一看，和调用门描述符没差呀。这不就是无参调用门描述符换了个Type域嘛。没错，的确是这样（这里解释下D位，可以理解为段描述符的DB位，置0时为16位中断门，置1时为32位中断门）。当你发现这点时，说明调用门的结构你理解清楚了。因此结构不再赘述，可以参考调用门 中断返回与调用门使用长返回RETF不同，中断门使用中断返回指令：IRET/IRETD INT N指令： 在没有权限切换时，会向堆栈压入3个值，分别是CS，EFLAG，返回地址 在有权限切换时，会向堆栈压入5个值，分别是SS，ESP，EFLAG，CS，返回地址 这也是与调用门不同的地方，中断门会多压入一个值。于是有小盆友就要问啦，“死肥宅哥哥，为什么中断门会多压入一个参数呢？” 这还不明显吗，你想想人家调用门为什么要压入值进入堆栈啊？肯定是这些值会改变啊，所以要用堆栈保存一下，等长返回的时候，再还原状态；中断门多压入了一个EFLAG说明通过中断门跨段时，EFLAG的值会变啊！ 所以，在中断门中，不能通过RETF返回，而应通过IRET/IRETD返回，其实只要改改堆栈，就可以通过RETF返回中断门，IRETD返回调用门。 代码实现中断门比较简单，这里演示一个实现的范例 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 根据GetValue函数的地址构造中断门描述符，然后填入中断门里即可 执行结果如下： 然后我们用int 3中断到Windbg里验证一下 验证成功。 总结通过调用门与中断门的对比，来总结一下中断门： 调用门通过CALL FAR指令执行，但中断门通过INT指令 调用门查询GDT表，中断门查询IDT表（后续也会再查询GDT表） CALL CS:EIP中的CS是段选择子，由3部分组成，而INT N指令中的N只是索引，中断门不检查RPL，只检查CPL 调用门可以有参数，但中断门没有参数 参考教程：https://www.bilibili.com/video/av68700135?p=19","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"调用门","slug":"调用门","date":"2020-03-14T06:34:21.000Z","updated":"2020-03-15T08:09:52.571Z","comments":true,"path":"2020/03/14/调用门/","link":"","permalink":"http://yoursite.com/2020/03/14/%E8%B0%83%E7%94%A8%E9%97%A8/","excerpt":"","text":"前一篇中提到CALL FAR指令最终跳转的地址是调用门里，今天就要分析一下调用门。首先从调用门的执行流程开始 调用门执行流程指令格式：CALL CS:EIP(EIP是废弃的) 执行步骤： 根据CS的值查GDT表，找到对应的段描述符，这个描述符是一个调用门。 在调用门描述符中存储另一个代码段的选择子 选择子指向的段的Base+调用门里的Offset，就是真正要执行的地址 光看描述，的确很难懂，结合调用门描述符来分析，会好理解很多 调用门描述符 高4字节8~15位：这是和普通段描述符完全一样的8位，其中第12位是判断该描述符是系统段还是数据段或代码段的位置，调用门描述符是系统段，所以此处值一定是0。接下来的Type域，这个根据段描述符那章中也能找到，32位的调用门描述符，Type域为1100，这也是确定的。 高4字节的高16位+低4字节的低16位：这两块区域加起来刚好是32位，构成一个Offset，也就是调用门执行流程第三步里Base加上的Offset，那么Base哪里拿呢？ 低4字节的高16位：这16位是一个段选择子，有段选择子，就可以拆分，于是RPL，TI，Index都能解析出来，这时候就可以根据Index去GDT表里找到段描述符，而这个段，就是调用门跳转的段，因此要用这个段的Base+Offset便可获得真正要执行的地址。 高4字节的低5位(第5~7位均为0)：这5位的作用是描述调用门传进去的参数，调用门是可以传参的，而参数的个数，决定了这个位置的值 下面，通过代码来验证调用门的执行流程。 无参调用门调用门分为无参和有参（示例默认都提权）两种情况，这里先用无参调用门进行实验： 构造调用门因为Windows是不使用调用门的，所以需要自己构造一个调用门：0040EC00 00081010 为什么要这样构造呢？先看最熟悉的那8位，EC = 11101100，P=1，S=1，调用门=1100，DPL为啥选取3呢。首先，调用门的提权在于通过调用门后，新的段选择子会修改CS达到CPL的提权，但是访问调用门描述符还是需要保证CPL=DPL，因此，DPL需要设置为3。由于无参调用门，也就没参数，因此参数位为0，EC00也就解释清了。 接下来看0008，这个也很好理解，段选择子嘛，拆分一下，RPL=0，Index=1，我们去Windbg里看一下就好了 这下就清晰了，指向00cf9b00 0000ffff这个段描述符，拆分一下，Limit=FFFFFFFF，G=1，Base=00000000，是个非一致代码段。看来想要跳转成功，也得是0环的代码段才行。 由于Base为0，那么跳转到的地方就是0+401010，那这个401010是哪来的呢？这得看代码才能说清。 代码实现c12345678910111213141516171819202122232425262728293031323334353637383940#include \"stdafx.h\"int saveEax = 0;short oldCS = 0;short newCS = 0;short oldSS = 0;short newSS = 0;int oldESP = 0;int newESP = 0;__declspec(naked) void GetValue() { __asm { mov saveEax, eax lea eax, [esp] //new esp mov newESP, eax mov eax, [esp+8] //old esp mov oldESP, eax mov eax, [esp+4] //old cs mov oldCS, ax mov ax, cs mov newCS, ax mov eax, [esp+0xc] //old ss mov oldSS, ax mov ax, ss mov newSS, ax mov eax, saveEax retf }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { call fword ptr [buffer] } printf(\"%x, %x, %x, %x, %x, %x\", oldCS, newCS, oldSS, newSS, oldESP, newESP); getchar(); return 0;} 来看一下代码，从main函数开始看起，我们自己构造一个CS:EIP（EIP已废弃）的6字节char型数组，然后在汇编中执行CALL FAR调用我们构造的CS:EIP，接着打印部分内容。 可以看出执行调用门的语句嵌入了汇编里，根据上方在构造调用门时的分析可以得出，最终调用门跳转的地址会是401010，那么这个401010是怎么来的呢？其实就是GetValue函数的地址，我们知道通过调用门后会跳转到一个地址，但是如何才能检测成功跳转并提权呢？就得有一个函数来收集这些信息并将其打印出来，也就有了GetValue函数（GetValue地址通过VC下断点查看，然后写入构造的调用门描述符中）GetValue要声明成裸函数，这样堆栈只需自己平衡，可以避免元素访问的位置过远。 根据前一篇文章的内容，如果跨段并提权，堆栈内部大致情况如下 因此，这里采用通过全局变量，来依次读取堆栈不同位置的值，并打印查看结果。 由结果看，ESP，CS，SS均发生了切换，且CPL变为0，ESP的值也变为了一个高2G的数 为了验证结果的正确性，我们可以通过中断再看一下0环的堆栈结构，将裸函数中的汇编代码清除，只留下int 3和长返回语句如下： Code1234_asm { int 3 retf} 然后重新执行，会中断到Windbg（为什么会从虚拟机中断到Windbg，这个到后面中断部分会详细讲解）查看栈顶部分内存 注意：这里的栈顶esp的值和刚刚不一样是因为程序重新执行了，进入0环时，ESP和SS是TSS给的，而TSS内的值是当前线程给的，因为代码修改了，所以重新执行程序时，线程不一样了，所以0环的堆栈也就不一样了。但是3环的数据是没有变的（理论上也是会变的，这里没变是因为编译器的优化），对比刚刚手动读取的结果来看，3环的ESP，CS，SS完全一致，说明刚刚调用门的实验成功提权进入0环。 有参调用门无参说完了，接下来是有参调用门，有参调用们和无参的区别在于仅仅是参数位的值会有所变动，栈里多了push进去的参数，其余和无参基本上相同。 构造调用门 这里构造的调用门描述符是：0040EC03 00081020，（地址变成了401020，是因为我重启了下虚拟机所以GetValue函数地址变了，并不影响），需要注意的是参数位设置成了3，因为这次计划传入3个参数进去。 代码实现由于Push了参数进去，所以不确定参数在0环堆栈中位于什么位置，于是先用int 3的方法，在Windbg中查看一下堆栈的情况 图中可以发现，在压入参数的调用门进入0环后，参数位于3环ESP和3环CS中间的位置，堆栈表示大致如下： 这样，就可以来编写代码了，总体和无参的差距不大。 c1234567891011121314151617181920212223242526272829303132#include \"stdafx.h\"int saveEax = 0;int para1, para2, para3;__declspec(naked) void GetValue() { __asm { mov saveEax, eax mov eax, [esp+8] mov para3, eax mov eax, [esp+0xc] mov para2, eax mov eax, [esp+0x10] mov para1, eax mov eax, saveEax retf 0xc }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { push 1 push 2 push 3 call fword ptr [buffer] } printf(\"%x, %x, %x\", para1, para2, para3); getchar(); return 0;} 需要注意一点，这里由于push了3个参数，所以长返回的时候要用RETF 0xc来平衡堆栈，否则直接中断到Windbg，要是不处理的话就蓝屏了。 代码执行效果如下，成功在0环堆栈取到了push进入的参数。 总结 当通过门，权限不变时，只会PUSH两个值：CS和返回地址，新的CS的值由调用门决定 当通过门，权限改变的时候，会PUSH四个值：SS，ESP，CS，返回地址，新的CS由调用门决定，新的SS和ESP由TSS提供 通过门调用时，要执行哪行代码由调用门决定，但使用RETF返回时，由堆栈中压入的值决定，也就是说，进门时，只能按指定路线走，出门时，可以翻墙（只要改变堆栈里面的值就可以想去哪去哪） 可不可以再建个门出去呢？也就是用Call，当然可以。 参考教程：https://www.bilibili.com/video/av68700135?p=17","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"长调用与短调用","slug":"长调用与短调用","date":"2020-03-14T01:29:45.000Z","updated":"2020-03-14T06:15:50.000Z","comments":true,"path":"2020/03/14/长调用与短调用/","link":"","permalink":"http://yoursite.com/2020/03/14/%E9%95%BF%E8%B0%83%E7%94%A8%E4%B8%8E%E7%9F%AD%E8%B0%83%E7%94%A8/","excerpt":"","text":"在上一篇章中提过，实现跨段的跳转，可以使用JMP FAR指令，但是想要实现跨段的调用，就需要学习一个新的指令CALL FAR；CALL FAR指令要更为复杂一些，原因是JMP指令是不影响堆栈的，而CALL指令会影响堆栈。 短调用首先来回顾下短调用，短调用其实就是普通的CALL调用，是相对于CALL FAR而言，所以叫做短调用。短调用会影响EIP寄存器和ESP寄存器，因此在返回时需要额外去平衡一下堆栈；短调用属于三环知识，这里不再赘述，具体的调用和返回时的堆栈变化如下图所示： 长调用（跨段不提权）长调用分为提权和不提权两种，这里先讲不提权的情况。 这图看不明白没关系，一个个分析。首先，EIP为什么是废弃的？因为，这个长调用指令，压根不会跳转到你给的EIP的位置，而是会跳转到调用门里提供的地址。那什么是调用门呢?下一篇会具体提到， 这里简单概括调用门就是一种位于GDT表里特殊的描述符。 回到长调用这里，当CALL执行后，与一般的调用指令不同，长调用使得堆栈提升了8个字节，除了返回地址外，还压入了调用者的CS，以便在调用返回至原来程序时，CS也能得到恢复。其中返回地址依然是位于[esp]处，调用者的CS位于[esp+4]处。 长调用返回也与普通调用不同，普通调用使用ret指令即可返回到原来程序的位置，而长调用返回时需要使用长返回指令RETF，长返回指令除了会将返回地址送入EIP寄存器，还会将CS恢复至执行前的状态，同时平衡堆栈。 长调用（跨段并提权）不提权的长调用还稍微好理解一点，提权的长调用，就稍微有些复杂了，由于发生了提权，CS的CPL发生了改变，根据Intel的规定，CS和SS的CPL一定要保持一致，所以此时SS的值也会发生改变，除此之外，因为发生了提权，堆栈从3环的堆栈变为了0环的堆栈，因此ESP也会发生改变。所以提权的长调用会4个寄存器的值发生改变，分别是EIP，CS，ESP，SS，来看一下执行前后的变化 提权后，分别将返回地址，调用者CS，ESP，SS压入了0环的堆栈中，这样在返回3环时，可以确保这些寄存器恢复到原本的状态。 同样，提权后返回用的也是RETF，长返回指令，分别将返回地址，调用者的CS，ESP，SS压入相应的寄存器中，大致如下： 总结长调用相较长跳转更为复杂，这篇只是做个简单的介绍，在后面的篇章中，将通过分析调用门的实现过程来详细讲解长调用，这里对本篇提到的几个特点做些总结。 跨段调用时，一旦有权限切换，就会切换堆栈 CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样 JMP FAR只能跳转到同级非一致代码段或者共享段，但CALL FAR可以通过调用门提权，提升CPL的权限 参考课程 : https://www.bilibili.com/video/av68700135?p=16","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"代码跨段跳转（不提权）","slug":"代码跨段跳转","date":"2020-03-13T02:24:36.000Z","updated":"2020-03-13T15:47:09.308Z","comments":true,"path":"2020/03/13/代码跨段跳转/","link":"","permalink":"http://yoursite.com/2020/03/13/%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5%E8%B7%B3%E8%BD%AC/","excerpt":"","text":"之前的篇章中提到过，除了CS段寄存器外，均可使用MOV或LES,LSS,LDS,LFS,LGS指令进行修改；为什么CS不可以直接被修改呢？ CS是代码段的段寄存器，CS的改变意味着EIP的改变，所以无法使用上述指令进行修改 代码跳转指令代码的跳转指令分为2种，一种是同时修改CS和EIP的指令，另一种，只修改EIP指令，具体如下： 同时修改CS和EIP：JMP FAR/ CALL FAR / RETF / INT / IRETD 只修改EIP：JMP / CALL / JCC / RET 本篇用到的是JMP FAR指令。 JMP FAR指令：和普通的JMP指令不同，JMP FAR实际是在JMP指令后写上6个字节，例如 JMP 0x4B: 0x00401456的形式。 其中0x4B是段选择子，0x00401456是跳转地址。 若能成功执行，0x4B会写入CS中，0x00401456会写入EIP中，代码发生跳转。 代码跳转流程JMP 0x20:0x004183D7 CPU如何执行这行代码? 段选择子拆分0x20 对应二进制 0x0000 0000 0010 0000 RPL：00 TI：0 Index：4 查表得到段描述符 TI = 0 所以查GDT表 根据Index = 4 找到对应的段描述符 四种情况可以跳转：代码段、调用门、TSS任务段、任务门（其中调用门，TSS任务段以及任务门，都属于系统段） 之前段描述符的篇章提到过，可以根据段描述符的属性判断属于哪个段，通过看属性的那16位：由于代码段和数据段的S位值为1，所以一般第12-15位为字节9/F，而代码段的Type域的第1位为1，所以代码段的Type域一定大于等于8。因而判断代码段描述符的第8-15位通常在98-9F或者F8-FF这个范围内。 权限检查权限检查分为非一致代码段和一致代码段两种情况，下面我们分别来看 非一致代码段非一致代码段，要求：CPL == DPL 并且 RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（下）","slug":"一次简单的Hook-下","date":"2020-03-12T07:38:30.000Z","updated":"2020-03-12T15:23:43.627Z","comments":true,"path":"2020/03/12/一次简单的Hook-下/","link":"","permalink":"http://yoursite.com/2020/03/12/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8B/","excerpt":"","text":"前一篇已经完成了对GetMsgAbstract函数的分析，发现，当执行到GetMsgAbstactByElement这一步时，已经可以根据寄存器用来传递的参数获取聊天内容，这篇来根据分析的内容编写用来Hook的dll。 Inline Hook这里先对Inline Hook做个简要概述，它是一种通过修改指令的方法，转移程序的执行流程，在程序执行某函数前或者某函数后，先执行你定义的Hook函数，拿到需要的参数信息，再根据需要对参数信息进行加工，从而完成Hook。常见的手法如下： Code11. jmp xxxxxxxx (5字节) Code12. push xxxxxxxx/retn (6字节) Code13. mov eax, xxxxxxxx/jmp eax (7字节) Code14. call Hook 根据需求不同，替换掉原本的指令长度不同，从而选择的手段也不同；本篇中采用6字节的方式 构建DLL一般构建一个dll要分别去编写头文件，C/C++源文件以及入口点函数。首先我们先从头文件开始。 头文件 打开Visual Studio，新建一个动态链接库(DLL)项目，VS会自动帮忙生成头文件和源文件，点击头文件stdafx.h开始编写 其实VS已经帮忙生成好了大部分，只需要定义自己需要实现的函数和方便自己使用的宏即可 这里为什么不写成下面这种形式呢？ c1__declspec(dllexport) BOOL WINAPI Msg_Hook(); 因为这个dll的主要作用是hook，并不需要有导出函数，即使有了被我们hook的程序也不会主动去调用（因为它的代码里面根本没有调用我的dll的代码），所以干脆就不写了，没什么影响。 入口点函数VS帮我们生成好的入口点函数如下： 在这里其实只需要把刚刚定义的函数，写在DLL_PROCESS_ATTACH的地方即可，因为在dll加载到进程时，会先调用入口点函数，传入的参数则是DLL_PROCESS_ATTACH，这样就可以调用我们的Hook函数了。 源文件源文件的编写是比较关键的一步，主要功能的实现都在这里。首先，我们需要实现Hook用的函数。 Hook函数 首先编写一个大致的框架，来分析一下都做了些什么，还缺一些什么。 Inline Hook的核心在于修改指令，从而实现程序流程的转移。具体的流程就是，找到需要修改的位置，修改当前位置的指令。 修改指令的大小这里采用的是push xxxxxxxx/retn的手法，所以需要创建一个6个字节的char型数组。 修改的位置修改的位置如何确定？之前在OD分析反汇编程序时，确定在调用GetMsgAbstractByElement之前就可获取到消息内容，发现，调用这个函数的call语句加上之前的push eax，刚好6个字节，这就是Hook点了 这个位置位于KernelUtil.dll中，所以我们可以补充第三条语句改成如下： Code1DWORD modify_addr = (PROC)GetModuleHandle(\"KernelUtil.dll\") + EntryOFFSET; 同时也可以根据基址确定EntryOFFSET并写在开头。 如何修改？这里采用Windows提供的ReadProcessMemory和WriteProcessMemory这两个函数，参数非常好理解，当前进程，需要修改的地址位置，修改的字节，修改字节的长度以及一个可以忽略的参数。在读的时候，指定位置的指定大小的字节会被保存进定义的char型数组里，写的时候就是把修改后的字节写回原来的地址。那我们要如何确定该写什么呢？ 根据push xxxxxxxx/retn指令，可以确定第一个字节和最后一个字节分别为0x68和0xC3。中间的4个字节填什么？就是执行我们做手脚的函数地址了。Hook函数的作用就是转移程序执行的流程，将程序转移到我们自己定义的函数，我们自己的函数就可以对当前的程序做些手脚，比如读取函数接收的参数，并将其传递出来。 目前为止，经过分析，可以进一步完善源程序。 接下来，就来编写自己的函数，将消息内容传递出来。 功能函数功能函数其实就是用汇编写一个裸函数，为啥要用裸函数？这样的话，编译器就不会自动帮我们生成如下这三行指令： Code123push ebpmov ebp, espsub esp, 0x20 而是我们自己平衡堆栈，所以就可以避免很多额外的偏移造成的麻烦，经过上一篇的分析已知，当函数到达GetMsgAbstractByElement的位置处时，可以通过[[ebx+0x28]]+0x18获取消息内容。那就可以采用一下方式： Code123456pushadpushfdmov eax, [ebx+0x28]mov eax, [eax]mov eax, [eax+0x18]mov Msg, eax 这样只要在外部定义一个变量Msg，即可将消息取到，然后可以利用OutputDebugString将消息内容输出到DbgView里观察。 但这还没有结束，因为之前覆盖掉了GetMsgAbstractByElement，所以这次需要重新再调用一遍。所以我们需要获取GetMsgAbstractByElement的地址，先通过当前地址和基址相减算出偏移0xBE0B0，然后通过KernelUtil.base+Offset确定函数的地址。这时只需要在平衡堆栈后的地方，补上之前替换掉的6个字节即可。 最终功能函数实现如下： 实验结果我们使用OD，将编写的dll注入进去 注入后此处代码发生了变化 观察DbgView，发现成功拿到消息内容","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://yoursite.com/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"第一周","slug":"第一周","date":"2020-03-11T12:40:24.000Z","updated":"2020-03-11T12:49:59.321Z","comments":true,"path":"2020/03/11/第一周/","link":"","permalink":"http://yoursite.com/2020/03/11/%E7%AC%AC%E4%B8%80%E5%91%A8/","excerpt":"","text":"今天是开博客的第七天，说满意其实也不是很满意，进度还是很慢的，当然计划也是长远的。一个是希望能坚持下来，也很久没坚持做一件事了；另一个是希望能够在4个月左右的时间，将所涉及的三个领域的基础知识，真正的掌握了，希望自己能真正尽力。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"段权限检查（数据段）","slug":"段权限检查","date":"2020-03-11T01:55:19.000Z","updated":"2020-03-11T07:54:44.536Z","comments":true,"path":"2020/03/11/段权限检查/","link":"","permalink":"http://yoursite.com/2020/03/11/%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5/","excerpt":"","text":"访问违例问题在介绍内容前，先看两个程序 两个程序的差异仅仅在于段选择子的不同，结果则是一个访问成功另一个访问违例了。分别对两个段选择子进行拆分： Code10023 = 0000 0000 00100 0 11 RPL：3 Index : 4 Code1002B = 0000 0000 00101 0 11 RPL：3 Index : 5 可以看出，两个段选择子的差别仅在Index的不同，也就是指向的段描述符不同，再来看看两个段选择子对应的段描述符 注意：由于Index是从0开始算的（和数组一样），所以对应的实际上是表中第五个和第六个段描述符。 根据之前段描述符属性的内容，来查看属性位，分别为： Code1Attr: CFF3 DPL:3 Code1Attr: 008B DPL:0 可以发现，两个段描述符的DPL不同，之前在段选择子的篇章中提到过，在将段选择子指向的段描述符加载到段寄存器时，一定要保证数值上（RPLDPL。那为什么RPL>DPL就会出错呢？下面来逐步解析。 CPU分级先来了解一下CPU分级 CPU共划分了4个等级，Ring0~Ring3，其中Ring3级别最低，Ring0级别最高。这个分级是CPU划分的，并不是操作系统所划分的，操作系统只是使用了这个分级，其中Windows系统只用了Ring3和Ring0两个等级，分别表示应用级和系统级。应用级的程序往往不能访问系统级，所以保护模式不仅仅是防止段的胡乱访问，还保证了程序在相应的级别稳定的运行。 CPLCurrent Privilege Level，当前特权级，之前段选择子篇章中讲过，段选择子的后2位的值为RPL，而CPL指的CS或SS中的段选择子的后2位（CS/SS的后两位一定是相同的，所以无论用哪个作为CPL都一样），也就是说CS或SS的RPL就是当前程序的CPL。 下面来查看两个CPL： 随便拖一个程序进入OD，根据CS/SS可以算出当前程序的CPL为3。因为这些程序都是Ring3的程序。 按Ctrl+Break在Windbg中断下，查看寄存器，可以发现当前CPL为0。因为Windbg在调试系统时执行的都是内核函数，所以处在Ring0。 DPL Descriptor Privilege Level：描述符特权级别。在段描述符属性那一篇中解析DPL时提到过，在段描述符高4字节的第13~14位就是DPL，那么DPL到底有什么用呢？和CPL有什么关系呢？ DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么。 通俗的理解：如果你想访问我，那么你应该具备什么特权。例如： Code1mov ds, ax 如果ax指向的段DPL = 0 但当前程序的CPL = 3 这行指令是不会成功的，因为CPL = 3是应用层，权限较低，是不能访问DPL = 0的系统层的；这也是为什么之前的例子中会出现访问违例。 RPLRequest Privilege Level：请求特权级别 有小盆友可能会问了，既然已经有CPL和DPL，那只要CPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（上）","slug":"一次简单的Hook-上","date":"2020-03-10T01:36:42.000Z","updated":"2020-03-10T09:48:23.338Z","comments":true,"path":"2020/03/10/一次简单的Hook-上/","link":"","permalink":"http://yoursite.com/2020/03/10/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8A/","excerpt":"","text":"这一次hook小实验的目标是hook出某社交软件中的实时聊天内容，主要目的是了解hook的原理以及在hook之前对程序的分析流程及其他准备工作，从而对于hook有个完整的认识。 准备工具 OllyDbg调试器：用于单步跟踪，动态调试等。 IDA pro调试器：用于静态分析函数代码结构等。 Mircosoft Visual Studio 201*(版本随意)：用于dll代码编写 DbgView：捕获并查看程序中由OutputDebugString输出的信息。 Hook的分类Hook无非只有两种类型，一种是通过修改数据（通常是引用的函数地址）进行的Hook，这如何理解，简单而言，很多大型程序，都需要通过调用各式各样的函数库来实现一些功能，而这种Hook就是通过修改程序调用的函数地址，改成自己写的函数，从而额外实现一些功能，实现对程序的Hook，例如IAT Hook；另一种是直接修改函数内的指令进行Hook，通过控制函数内的跳转，在函数执行时，实现一些自己的功能，然后再返回到函数使之正常运行，例如Inline Hook。这次Hook实验，采用的就是Inline Hook的手法实现。 基址与偏移在逆向分析中，通过基址和偏移定位一个函数，会非常方便，同时可以对IDA的代码进行基址重定位，从而达到和OD的同步分析。 如何确定基址呢，一个程序需要调用一个外部的库函数，或者加载dll来实现某些功能，当dll被加载进程序时，会根据默认基址0x10000000进行载入dll，但是一个程序往往会加载多个dll，此时dll会根据重定位表来对dll进行重定位，基址也会有所变化。由于dll中的导出函数，距离基址的偏移是固定的，所以只要确定需求函数与dll基址的偏移，就可以轻松定位到这个函数。如图，将程序被OD附加时，通过点击上方的E按钮，进入模块列表，左边第一栏的Base就是dll的基址，例如IM.dll在此次加载时的基址为0x62840000。 右键View name查看IM.dll的导出函数，可以发现此次加载时PostTask_Session这个函数的地址为0x628E6EF9，相减可得偏移为0xA6EF9，以后每次只需确定IM.dll的基址，就可以通过偏移直接确定PostTask_Session的地址，这在hook代码中很有用。 程序分析流程查找需要被Hook函数根据我们需要Hook的功能来看，要截取实时聊天的数据，需要对接收聊天内容的函数做手脚，猜想这个函数的函数名一定与Message有关，例如GetMessage，RecvMessage等。将程序附加进OD，点击E查看Tim加载的主要模块(dll)，找到一个KernelUtil.dll，为啥找这个dll呢？根据之前逆向，发现很多功能都是由这个dll实现的，从dll名也可以看出这是一个实现功能的dll。右键View name，查看dll的导出函数。 查看和Message有关的函数，最终会发现一个名为GetMsgAbstract的导出函数 为什么选这个函数呢？因为看名字猜测这是一个获取消息摘要的函数，也许和收发消息有一定的关联，因此可以拿出来进行试一试。 在函数的开头，下一个断点，然后在Tim内任何发送一条消息。发现程序断了下来，说明这个函数的确和消息有关。 寻找聊天内容尽管确定了，这个函数和聊天消息有关，但是只有真正找到了消息内容，这个函数才能够被利用，否则还得换另一个函数分析。首先按照F8单步执行(不步入函数，为了节省时间并快速定位)，每当一个函数(call语句)执行完后，都要观察堆栈和寄存器的变化，看看是否有重要内容。继续单步，直到发现一个函数GetMsgAbstractByElement，这个函数执行完后，会在堆栈[ebp-8]的位置出现刚刚发送的消息。 这时，我们可以进一步GetMsgAbstractByElement，来寻找发送的消息是如何出现的。 函数入口 右图开始分析，在调用GetMsgAbstactByElement之前，共push了5个参数进去，其中第一个push进去的参数0x548FA04，此时所指向的堆栈中的值为0，第三个push进去的0x548FA01，所指位置，截断了堆栈中部分数据，也无意义。第四个push进去的参数，值为0，同样也用不到。第五个push进去的参数，首先将[ebp-8]处的地址加载到eax，然后再push进去，根据前一次的步入，已知函数执行后，[ebp-8]的位置即是发送的消息，但该参数用于存放取完后的消息，并不是消息的源头。这样就只剩下第二个参数，右键ebx，Follow in dump，进入数据窗口，并没有发现消息内容的存在，因此可以猜测，这是一个包含了消息的结构体，至于如何结构结构体获取消息，还得步入GetMsgAbstactByElement函数作进一步分析。 GetMsgAbstactByElement函数按F7步入函数 可以发现，栈顶足足降低了0x70字节，所以push进来的参数暂时只能靠[ebp+偏移]来访问，关注点仍然放在第二个参数的值上，目前除了ebx仍然为此值，push进入堆栈，目前位于[ebp+0x14]的位置，值也相同，由于[ebp+0x14]是作为参数push进来的，所以ebx的值多半用不到了，接下来只需关注[ebp+0x14]的值。 同一张图，距离函数开始不远，就有一条赋值语句将[ebp+0x14]的值赋给edi，这时edi的值也会成为第二个参数的值，同样需要关注。接着继续单步分析。 单步执行到这里时发现，在一次函数调用前，将edi作为参数push了，此外又将[ebp-0x20]处的位置清零，需要留意关注，然后单步步过该函数观察变化。 该函数执行后发现，[ebp-0x20]处的位置多了个数，右键-Follow in dump，进入数据窗口发现，在0x18偏移的位置，正好是发送的消息。这下就可以确定，是此处的call dword ptr ds:[eax + 0x48]这条语句，将传入的参数结构体进行解构，找到了消息。 解构参数结构体的函数接下来重新运行程序，再发送一条新的消息并断下。单步到call dword ptr ds:[eax + 0x48]处，按F7单步进入该函数。 这个函数并不长，但是实现了很关键的功能 Code1mov ebx,dword ptr ss:[ebp+0x8] 这一步，将[ebp+8]的值给到ebx，而这个值恰好就是外部传进来的需要解构的结构体，接下来需要关注涉及到ebx的指令。 其中接下来一条，将[ebx+0x38]的地址赋给eax，但是eax接下来就被重新赋值了，所以只需向下关注，其中这里方框框住的两行，实际上做了个减法运算，之后eax的值再一次被重置。接下来的一步，ecx也被清零了。 Code1mov eax,dword ptr ds:[ebx+0x28] 这是非常关键的一步，为什么说它关键呢，因为这时候已经脱离了ebx，说明ebx已经将结构体内部的信息传递给了eax上了，接着继续看eax，同时跟进[ebx+0x28]数据窗口查看。 Code1mov eax,dword ptr ds:[eax+ecx*4] => mov eax,dword ptr ds:[eax] 由于ecx的值为0，便可做一个优化。此时再去跟进[eax]数据窗口查看。 发现，刚好有一条发送出去但是还未接收到的消息。至此大功告成，已经确定GetMsgAbstractElement函数的解构过程： 首先将外部传入的第二个参数，赋值给edi寄存器暂存 接着将edi寄存器内的值作为参数，传入到一个解析结构体的函数内 进入函数，先将原先edi寄存器保存的参数，赋值给ebx寄存器 然后将ebx+0x28所在地址的值赋值给eax寄存器 最后eax寄存器将保存的值作为地址，进入后发现，在0x18处偏移，刚好就是保存的消息。 结论验证通过上述分析可以发现，在执行GetMsgAbstractElement，就可以通过其第二个push进去的参数，获取到消息内容了。这时，我们再次运行重新，发送消息，并重新断下。通过之前推论得出的偏移来计算： Code1[[ebx+0x28]]+18 该命令可以达到一个地址，而这个地址就应该存着消息。 验证成功。尽管我们是从GetMsgAbstract进来开始分析的，但是在分析的过程中发现GetMsgAbstractElement在执行前，就可以拿到消息内容，而GetMsgAbstract，执行的过程中总会执行GetMsgAbstractElement，因此可以在GetMsgAbstractElement函数执行前做手脚，注入我们的代码实现对消息内容的Hook。至于Hook代码的编写，限于篇幅，将在下一个部分呈现","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://yoursite.com/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"段描述符属性","slug":"段描述符属性","date":"2020-03-09T09:19:09.000Z","updated":"2020-03-13T13:22:38.361Z","comments":true,"path":"2020/03/09/段描述符属性/","link":"","permalink":"http://yoursite.com/2020/03/09/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%9E%E6%80%A7/","excerpt":"","text":"之前介绍了，段描述符是用来填充段寄存器余下位置的，然而段寄存器余下位置有80位，而段描述符仅有64位，那到底是如何填充的呢？这篇就从这个问题开始，逐步探究段描述符的属性。首先，回顾一下段描述符的结构： P位P位，位于段描述符高4字节的第15位，是判断描述符是否有效的位置。 P = 1: 该描述符有效 P = 0：该描述符无效 G位在解析G位前，先来回顾下之前的问题，64位的段描述符到底是如何分配给段寄存器余下80位的。 首先回顾一下段寄存器的结构： c123456struct SegMent { WORD selector; WORD attribute; DWORD base; DWORD limit;} 段选择子： 由mov/les/lds/lss/lfs/lgs指令直接写入16位。 属性：段描述符中高4字节的第8-23位，刚好16位，作为属性写入段寄存器。 基址：将段描述符高4字节中第24-31位，与第0-7位拼接成作为高16位，低四字节的第16-31位作为低16位，拼接成32位，作为Base，写入到段寄存器里。 (这里没用~号是因为会转义成删除线) 限长：这里就要用到G位了。首先观察段描述符结构，可以发现，在高4字节的第16-19位，与低4字节的第0-15位，都是段限长，将他们拼接起来，也就是20位，那这20位是如何扩展成32位呢？这里就要用到这部分的关键G位了，当G的值为0时，表示以字节为单位，这时，假设Limit的值加起来为FFFFF(20位)，则取0x000FFFFF作为Limit写入段寄存器；当G的值为1时，表示以4KB为单位，这样去理解，如果一个段的大小为1KB，也就是1024B或0x400B，这时，实际上能取的范围是0-1023或0-0x3FF，所以此时的Limit应该为3FF。这样当以单位为4KB来计算一个段的Limit时，若Limit的值为1，说明可以取0和1两个值，也真正的大小实际上是2，所以用2*4KB=8192B=0x2000B，但是真是可以取到的值为0-1FFF，所以此时写入段寄存器Limit的值为1FFF。同理，若段描述符Limit的值为FFFFF，真正写入段寄存器的值为FFFFFFFF(32位)。 具体的公式如下： Code12345G = 0: = LimitG = 1: (Limit + 1)*4KB - 1 = Limit*4KB + 4KB - 1 = (Limit","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"段描述符与段选择子","slug":"段描述符与段选择子","date":"2020-03-08T11:31:33.000Z","updated":"2020-03-13T13:22:59.224Z","comments":true,"path":"2020/03/08/段描述符与段选择子/","link":"","permalink":"http://yoursite.com/2020/03/08/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90/","excerpt":"","text":"在探究段寄存器属性时，注意到，段寄存器在读的时候，只读了16位，但是写的时候会写入96位。那么，段寄存器是如何做到写入96位的呢？今天就要研究两个新的概念：段描述符与段选择子 基础知识Windbg指令Windbg是在调试Windows系统内核时常用的一个调试器，之后也会多次用到；通过Windbg可以实现主机对虚拟机上的Windows系统进行双击调试。搭建双击调试环境可以参考此贴：https://blog.csdn.net/q1007729991/article/details/52710390 这里，简单介绍一下，在研究段描述符和段选择子所需用到的几个Windbg指令： 命令 含义 r 查看和修改寄存器 dd 以4字节分隔，显示指定内存区域的数据内容 dq 以8字节分隔，显示指定内存区域的数据内容 第二个d和q分别是dword和qword的意思，第一个d是一个查看内存的指令，以后会详细说明。 汇编基础这里补充一点汇编基础，如何在确保，给一个拥有6个元素的char型数组赋值时，确保元素所在高位或者低位呢？ 通过观察反汇编可以看出，0x78处在 [ebp-8]的位置上，距离ebp相对较远；0x12处在[ebp-5]的位置上，距离ebp相对较近，两者差了4个字节，我们可以假象在地址空间中的位置如下表： 地址 值 0x12ff40(随便取个值) 0x78 0x12ff41 0x56 0x12ff42 0x34 0x12ff43 0x12 0x12ff44 0x23 0x12ff45 0x00 而Windows操作系统是小端模式，也就是高字节保存在高地址中；例如0x12在0x12345678这个数里属于高字节，0x12所在的地址位0x12ff43相当于0x78位于高地址，所以在赋值时，需要把0x12放到高地址中，根据小端模式在内存中的排列可知，若想确定一个实际值为0x12345678的数，在内存的排列大概是”78563412“这种形势，因此在赋值时按照如下方式： 这里还有一个坑是，赋值时不要加’ ‘，因为一个字节的数不止一个字符，不能放到单引号里。 GDT，LDTGDT和LDT分别指全局描述符表和局部描述符表。由于Windows系统没有使用LDT表，所以可以忽略这个表。而GDT表，表里存储的就是段描述符。 了解GDT表，需要先知道这个表有多大，存在哪里。这时需要借助一个寄存器gdtr，这是个48位的寄存器，其中32位存的是GDT表的位置，16位存的是GDT表的大小；可以通过以下指令进行查询。 由图可知，当前虚拟机中的操作系统，gdt表位于0x8003f000的位置，大小是0x03ff，也就是说从0x8003f000~0x8003f3ff这段内存中，存放着gdt表。 段描述符当执行以下语句时： Code1mov ds, ax CPU会去查表，根据ax的值决定查看GDT表还是LDT表，以及查找表的什么位置，查出哪些数据 首先查看一下GDT表，由于段描述符大小是8字节/64位，所以采用dq指令进行查看。 这里查看了GDT表0x80个字节大小的内存，一个段描述符的大小是8字节，所以显示了16个段描述符。 接下来看一下段描述符表的结构 可以发现，在段描述符中，有着Base，Limit，还有各种Attribute，这些就是从段描述符中查找的数据，并写入段寄存器剩下的80位里。那么有了GDT表和段描述符，那么究竟该选择哪一个段描述符的数据写入段寄存器呢？这就涉及到另一个结构：段选择子 段选择子“段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符”。 这句话怎么理解，怎么又是16位的段描述符，又是GDT表的段描述符？首先，段的Base，Limit以及Attribute都是由GDT表的段描述符来决定的，那么到底是由哪个段描述符来决定的？为了确定这个段描述符，引入了段选择子这个结构，段选择子，指向了GDT表中某一个段描述符，这样就可以把该段描述符的数据写入到段寄存器内了。所以说，段选择子，是一个段描述符的描述符。下面是段选择子的结构。 由图，结构非常简单，各个位的含义也比较好理解。这里有个小g巧，段选择子一共16位，由于Windows没有使用LDT表，所以TI位永远是0。请求特权级别一般也只有0和3，所以段选择子最后4位的值只有4种组合：0000, 0011, 1000, 1011 加载段描述符至段寄存器除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器。 CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，以后的文章会说到。 Code1les ecx,fword ptr ds:[buffer] //取buffer高2个字节给es，低4个字节给ecx 这里的buffer是一个地址，存了6个字节的数，例如定义buffer为一个6个元素的char型数组。这里的fword指的是三字，也就是6个字节 注意：在数值上需要要求RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"浅谈对称加密传输","slug":"浅谈对称加密传输","date":"2020-03-07T09:19:26.000Z","updated":"2020-03-09T13:59:14.424Z","comments":true,"path":"2020/03/07/浅谈对称加密传输/","link":"","permalink":"http://yoursite.com/2020/03/07/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/","excerpt":"","text":"看到crownless一篇关于Tor原理解析的文章，涉及到了加密传输的部分，以前没仔细理解，现在用通俗的语言记录下来。 基础概要对称加密所谓对称加密，就是通信双方，在发送和接收数据时，使用同一个密钥key对数据进行加密与解密。发送方和接收方必须在数据传送前商定好秘钥。 优点：加密速度快、效率高。 缺点：一旦密钥泄露，加密信息不再安全 25519曲线Curve25519椭圆曲线，是基于蒙哥马利曲线的密钥协商算法，具体如下 蒙哥马利曲线算法，可以做到”Time-constant”，也就是说不论他们进行运算的数值是多少，他们所花的时间是相同的，可以规避“ 时间旁路 ”攻击。（crownless文中有提到这是一种很神奇的可以在不安全的信道上建立共享的对称密钥的方法） 传输过程密钥获取Bob为了访问Alice，先访问Tor的目录服务器，获取一部分Tor节点的IP地址，并从中随机选择三个节点的IP地址A、B、C。然后，Bob会先和A节点通过Curve25519椭圆曲线算法以及协商所需的参数，协商一个对称密钥keyA；这时A节点会将Bob协商密钥所需参数发送给Bob。Bob通过算法计算出对称密钥keyA。之后，Bob和节点A之间就会用这把对称密钥keyA进行加密通信。 然后，Bob把B的IP地址和与B协商密钥所需的参数用对称密钥keyA加密后发送给A。A用keyA解密后，将Bob与B协商密钥所需的参数发送到B的IP地址。B收到参数后产生了对称密钥keyB，并将与Bob协商密钥所需的参数发还给A。A将参数通过keyA加密后发还给Bob。Bob用keyA解密后通过算法计算出对称密钥keyB。Bob通过相同的方法和C协商出keyC。至此，Bob有了三把钥匙keyA、keyB、keyC。 需要注意的是，当把协商密钥所需的参数，发给相应的节点时，若一方还没收到协商的参数并生成密钥，另一方就不会对协商参数进行加密。在B收到参数生成密钥keyB后，将与Bob协商密钥所需的参数发还给A，此时不会对协商参数用keyB进行加密，以保证另一方可以拿到参数生成密钥。但已经进行加密通信的双方，则会使用密钥加密通信数据。 加密传输Bob往Alice发送数据包时，先将数据Data用keyC加密，再用keyB加密，再用keyA加密，就好像层层包裹一样，然后发往节点A。节点A解开一层加密，发往节点B。节点B解开一层加密，发往节点C。节点C解开一层加密，得到Bob发往Alice的明文，发送给Alice。 参考文章： https://bbs.pediy.com/thread-248850.htm https://www.jianshu.com/p/5dba044f67b1","categories":[],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"http://yoursite.com/tags/NetWork/"}]},{"title":"探究段寄存器","slug":"探究段寄存器","date":"2020-03-06T15:00:07.000Z","updated":"2020-03-08T10:35:10.662Z","comments":true,"path":"2020/03/06/探究段寄存器/","link":"","permalink":"http://yoursite.com/2020/03/06/%E6%8E%A2%E7%A9%B6%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"被忽视的ds1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域","text":"被忽视的dsCode1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域 这些是OllyDbg调试器显示出当前程序运行时段寄存器的各部分属性的值。接下来分析这些值的来源和含义。 段寄存器的读写在后面的部分会经常用到段寄存器的读写，这里先说明一下： 读： Code1mov ax, fs 写： Code1mov ds, ax 段寄存器在读的时候，只读了16位，但是写的时候会写入96位。 注意：ldtr和tr段寄存器不能用mov指令进行读写 段寄存器结构Code123456struct SegmentReg { WORD selector; WORD attribute; DWORD base; DWORD limit;} 由段寄存器的结构可知，段寄存器共96位，由16位的段选择子，16位的段属性，32位的base和32位的limit组成。 打印ds寄存器的值，发现只能显示0x0023，也就是段选择子那16位。不是说好的共96位吗？实际上，剩下来80位是不可见的部分，只不过OD也展示出来了，接下来证明每个属性的存在。 段基址Code1mov eax, dword ptr ds:[0] 理论上，上面这条语句是无法执行成功的，因为零地址是不允许访问的（因为没有给零地址挂物理页） 但是上述程序可以成功执行（这里不使用ds，原因是vc6作者对ds做过优化，写成ds将编译不过去），说明了这里访问的不是零地址，而是其它地址，也就是说，段寄存器修改了写入数据的地址，证明了段基址的存在。 这里真正的将数据写入eax的地址是： Code1gs.base + 0x0 以下是常见段的基址 段寄存器 Base ES 0 CS 0 SS 0 DS 0 FS 0x7FFDE000 GS - 由于将fs段的值赋给了gs段，因此写入eax寄存器的是0x7FFDE000地址上的值。 段属性 上面两段程序的差别仅仅在于插入的汇编的第一条指令，mov ax, cs 和 mov ax, ss。造成结果不同的原因是，ss段寄存器是可读、可写的，而cs段寄存器是可读、可执行，但是不可写；因此在试图向cs段寄存器所指向的基址+偏移（既[ ]内的值）是会发生访问违例的，这也说明了，不同的段寄存器，属性是不同的，证明了段属性的存在。 段限长 又出现了访问违例的情况，此处var的值为0x1000，超过了fs段寄存器的Limit：0xFFF，所以此时已经不能通过fs段来访问fs.base+0x1000这个地址了，这说明段寄存器也有一定的管辖范围，超出这个范围，就没有权限访问了 总结这次的笔记主要探究了段寄存器的属性和结构，大致整理如下 段寄存器 段选择子 属性 基址 限长 ES 0x0023 RW 0 0xFFFFFFFF CS 0x001B RX 0 0xFFFFFFFF SS 0x0023 RW 0 0xFFFFFFFF DS 0x0023 RW 0 0xFFFFFFFF FS 0x003B RW 0x7FFDE000 0xFFF GS - - - - 参考文章：https://blog.csdn.net/q1007729991/article/details/52537943 参考教程：https://www.bilibili.com/video/av68700135?p=7","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"初见保护模式","slug":"初见保护模式","date":"2020-03-05T09:19:09.000Z","updated":"2020-03-09T13:58:29.632Z","comments":true,"path":"2020/03/05/初见保护模式/","link":"","permalink":"http://yoursite.com/2020/03/05/%E5%88%9D%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","excerpt":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。","text":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。 保护模式的引入提供了段间的保护机制，防止程序间胡乱访问地址带来的问题，同时也扩大了访问的内存空间（没整明白8086实模式的寻址方式，看结果，保护模式的确扩大了寻址空间）。 段、页机制段，页机制均是CPU所提供的，操作系统利用CPU提供的段，页机制，实现对虚拟地址空间的管理，使得操作系统在保护模式上有序，”安全”的工作。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]}]}