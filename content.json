{"meta":{"title":"cataLoc's Blog","subtitle":"","description":"","author":"cataLoc","url":"http://cataloc.gitee.io/blog","root":"/blog/"},"pages":[{"title":"link","date":"2020-03-07T03:28:51.000Z","updated":"2020-03-07T03:28:52.000Z","comments":true,"path":"link/index.html","permalink":"http://cataloc.gitee.io/blog/link/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-07T03:27:53.000Z","updated":"2020-03-07T03:27:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://cataloc.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"movies","date":"2020-03-07T03:28:28.000Z","updated":"2020-03-07T03:28:30.000Z","comments":true,"path":"movies/index.html","permalink":"http://cataloc.gitee.io/blog/movies/index.html","excerpt":"","text":""},{"title":"messageboard","date":"2020-03-07T03:28:09.000Z","updated":"2020-03-07T03:28:12.000Z","comments":true,"path":"messageboard/index.html","permalink":"http://cataloc.gitee.io/blog/messageboard/index.html","excerpt":"","text":""},{"title":"music","date":"2020-03-07T03:28:22.000Z","updated":"2020-03-07T03:28:24.000Z","comments":true,"path":"music/index.html","permalink":"http://cataloc.gitee.io/blog/music/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-03-07T03:28:40.000Z","updated":"2020-03-07T03:28:42.000Z","comments":true,"path":"photos/index.html","permalink":"http://cataloc.gitee.io/blog/photos/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-07T03:27:42.000Z","updated":"2020-03-07T03:27:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://cataloc.gitee.io/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-28T06:28:51.287Z","updated":"2020-03-28T06:28:51.287Z","comments":true,"path":"link/link.json","permalink":"http://cataloc.gitee.io/blog/link/link.json","excerpt":"","text":"{\"class\":{\"class_name\":\"友情链接\",\"link_list\":{\"1\":{\"name\":\"Joney\",\"link\":\"https://www.cnblogs.com/joneyyana/p/\",\"avatar\":\"xxxx\",\"descr\":\"xxxx\"}}}}"}],"posts":[{"title":"Android程序分析入门（准备工作）","slug":"Android程序分析入门-上","date":"2020-05-03T11:00:11.000Z","updated":"2020-05-03T11:56:13.997Z","comments":true,"path":"2020/05/03/Android程序分析入门-上/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/05/03/Android%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8-%E4%B8%8A/","excerpt":"","text":"前言停更了一周，其实前些天倒是也学了点，但是五一假期太诱人了，都想把事情放在假期来做，然而前两天基本上就睡过去了，所以拖到了今天。Android这部分，2月份疫情期间学了不少，不过之后开始更新Windows内核的内容了，也就没续上，之前又做了一遍实验，发现很多坑都没有再踩。所以这篇可能会漏掉部分我以前遇到的坑。 之前有计划在3月下旬就开始更新Android，后来发现，由于先前日更的缘故，周末其实也是比较赶进度的，所以拖了很久，现在不日更了，Windows内核的基础部分，也就差个多核同步以及APC了，所以就可以偶尔穿插的更新些Android相关的了，把这部分的内容再巩固下。（题外话，瀚哥真是个狠人，感觉他醒着的时间都在学习新的内容，认识这个世界，太佩服了） 回到本篇的内容，我计划是在博客里演示一遍虫神书上的第一个逆向实验，但是需要一些准备工作，比如CrackMe程序代码的编写，部分Android逆向用到的工具下载及配置等等，所以这篇叫做准备工作，具体程序逆向分析，会在下一篇进行。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://cataloc.gitee.io/blog/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"全局句柄表","slug":"全局句柄表","date":"2020-04-26T13:18:15.000Z","updated":"2020-04-26T16:29:34.021Z","comments":true,"path":"2020/04/26/全局句柄表/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/26/%E5%85%A8%E5%B1%80%E5%8F%A5%E6%9F%84%E8%A1%A8/","excerpt":"","text":"基本概念 进程的句柄表是私有的，每个进程都有一个自己的句柄表 系统拥有一个全局的句柄表，通过全局变量PspCidTable获取到全局句柄表的地址 每个进程和线程都有一个唯一的编号：PID和CID，这两个值就是该内核对象在全局句柄表中的索引 与局部句柄表的差异 全局句柄表的句柄直接指向内核对象；局部句柄表的句柄指向_OBJECT_HEADER，所以在运算时还需加上0x18字节 全局句柄表只有进程和线程这俩内核对象的句柄；局部句柄表包含了当前进程所有打开的内核对象，不限于进程和线程，还有互斥体等。 全局句柄表结构全局句柄表的结构取决于TableCode的低2位的值： 取0x00时：最多可以存储512个句柄（4KB/8Byte = 512） 取0x01时：第一级可以存1024个地址，第二级用来存句柄。最多可存1024x512个句柄 取0x10时：第一级可以存1024个地址，每个第二级的表也存1024个地址，第三级表存句柄。最多可存1024x1024x512个句柄 具体如下图所示： 查找全局句柄表常规方式下面按照步骤，通过Windbg实现查找全局句柄表中的进程句柄 在虚拟机中打开计算器，并在任务管理器中确定进程PID的值 根据全局变量PspCidTable，定位_HANDLE_TABLE结构体 根据_HANDLE_TABLE中的TableCode字段，以及PID的值（用于索引），来确定句柄的位置。注意事项如下： 1）观察TableCode后2位的值，判断是否需要跨表 2）3环PID是四字节的值，但是句柄在内核是8字节，因此寻址时需要PID/4*8 根据句柄的低四字节，找到对应的内核对象。注意事项如下： 1）全局句柄表的句柄是直接指向内核对象结构体的，所以不需要加0x18字节 2）根据低四字节查找时，需清空后3bit属性位再进行运算 代码查找思路由于PspCidTable无法直接引用，在代码实现的过程中，需要一些其它技巧 1）特征搜索 PsLookupProcessThreadByCid()PsLookupProcessByProcessId()PsLookupThreadByThreadId() 这三个函数都会根据PID或者CID去查找全局句柄表。在这个过程中，就会用到PspCidTable，这样我们可以通过Hook这三个函数，就可以借用PspCidTable这个值，找到全局句柄表了。由于这三个函数都是未导出的，所以需要通过特征搜索先进行定位，特征搜索可以参考之前的文章 2）KPCR KPCR有一个成员，KdVersionBlock。这个成员非常奇妙，在他指向地址（+0x80）位置处有一个地址，这个地址指向的就是PspCidTable。具体如下图所示： 因此我们可以在驱动中采用如下手法。获取到PspCidTable Code1234567PULONG PspCidTable_asm { mov eax, fs:[0x34] mov eax, [eax + 0x80] mov eax, [eax] mov PspCidTable, eax} 当然，这个KdVersionBlock指向的地址还能找到一些其它的值： +0x10：KernelBase +0x18/+0x70：PsLoadedModuleList +0x78：PsActiveProcessHead +0x88：ExpSystemResourcesList 遍历全局句柄表有了获取PspCidTable的方法后，我们就可以试着遍历一下全局句柄表，例如打印每个进程的进程名。 代码实现c123456789101112131415161718192021222324252627282930313233343536373839#include \"ntifs.h\"VOID Driver_Unload(PDRIVER_OBJECT pDriver);VOID TraverseProcess();NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegistryPath) { TraverseProcess(); pDriver->DriverUnload = Driver_Unload; return STATUS_SUCCESS;}VOID TraverseProcess() { PULONG PspCidTable, TableCode; PUCHAR pEPROCESS; _asm { mov eax, fs:[0x34] mov eax, [eax + 0x80] mov eax, [eax] mov PspCidTable, eax mov eax, [eax] mov TableCode, eax } DbgPrint(\"%x, %x\\n\", PspCidTable, TableCode); for (int i = 0; i < 500; i++) { TableCode = TableCode + 2; // DbgPrint(\"Index: %d, TableCode: %x \\n\",i, *TableCode); if (*TableCode != 0) { pEPROCESS = (PUCHAR)((*TableCode) & 0xfffffff8); DbgPrint(\"%s\\n\", (PULONG)(pEPROCESS + 0x174)); } }}VOID Driver_Unload(PDRIVER_OBJECT pDriver) { DbgPrint(\"Unload Success!\\n\");} 实验效果由于代码比较草率，并没有过滤掉线程结构体，所以会有较多的乱码，但仍然可以打印出所有的进程 参考资料参考书籍：《Windows内核原理与实现》——潘爱民 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?t=143&p=68 参考文章： https://blog.csdn.net/weixin_42052102/article/details/83479303 https://blog.csdn.net/qq_41988448/article/details/104945311 https://www.cnblogs.com/joneyyana/p/12595525.html 参考笔记：张嘉杰，时间刺客.","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"句柄表","slug":"句柄表","date":"2020-04-23T12:44:09.000Z","updated":"2020-04-26T03:28:14.169Z","comments":true,"path":"2020/04/23/句柄表/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/23/%E5%8F%A5%E6%9F%84%E8%A1%A8/","excerpt":"","text":"句柄今天来介绍一个熟悉的概念，句柄。早在Win32编程时，海哥曾提到，我们不必去理解句柄是什么，只要记住它是一个4字节的DWORD数即可。但是到了内核层面，就有必要深入了解一下这个概念了。 一直以来，我们接触到的句柄主要分为两种： 1）窗口句柄c1HWND hwnd = FindWindow(NULL,\"计算器\"); 例如上面这个代码，就是从桌面获取到一个已经打开了的窗口的句柄，这个句柄相当于这个窗口的编号，通过这个编号，便可以快速访问到这个窗口。 2）内核句柄c1HANDLE g_hMutex = CreateMutex(NULL,FALSE, \"XYZ\"); 窗口句柄是作用于窗口对象的，内核句柄则是对应了一个内核对象，这也是通常而言我们所说的句柄。正如上面例子所示，当一个进程创建或者打开一个内核对象时，将获得一个句柄（相当于内核对象的一个编号），通过这个句柄可以访问内核对象（例如进程，线程，互斥体等）。 为什么要有句柄前面提到过，句柄相当于内核对象的编号，3环的程序可以根据这个编号，来使用这个内核对象。这样就避免了3环程序直接访问到内核对象；由于内核对象位于0环，如果3环的程序可以直接访问内核对象，一旦访问到无效的内核地址，就会导致蓝屏 句柄表在认识了句柄之后，来了解一下句柄表。前面提到了，当一个进程创建或者打开一个内核对象时，将获得一个句柄；那么当这个进程，打开或创建多个内核对象时，就会获得多个句柄，这些句柄，就会存到一个叫做句柄表的结构里。先来看看句柄表这个结构在哪。 句柄表的位置 在_EPROCESS结构体+0xC4偏移处，有一个字段ObjectTable，其指向了一个HANDLE_TABLE的结构体，这就是句柄表结构体。 各个字段具体含义如下： c1234567891011121314+0x000 TableCode :ULONG_PTR //指向句柄表的存储结构+0x004 QuotaProcess : _EPROCESS//句柄表记录的内存资源记录在此进程中+0x008 UniqueProcessId : Void//创建进程的ID，用于回调函数+0x00c HandleTableLock : [4] _EX_PUSH_LOCK//句柄表锁 (仅在句柄表拓展时使用)+0x01c HandleTableList : _LIST_ENTRY //所有句柄表形成一个链表,链表头为全局变量HandleTableListHand+0x024 HandleContentionEvent : _EX_PUSH_LOCK//若在访问句柄表时发生竞争,则在此推锁上等待+0x028 DebugInfo : //调试信息，当调试句柄时才有意义+0x02c ExtraInfoPages : //审计信息所占用的页面数量+0x030 FirstFree : //空闲链表表头的句柄索引+0x034 LastFree : //最近被释放的句柄索引，用于FIFO类型空闲链表+0x038 NextHandleNeedingPool : //下一次句柄表拓展的起始句柄索引+0x03c HandleCount : //正在使用的句柄表项的数量+0x040 Flags : //标志域+0x040 StrictFIFO : //是否使用FIFO风格的重用，既先释放先重用 本篇主要关注TableCode这个字段，其余字段在用到时会再作分析。TableCode它指向了一个表，这个表存储了当前进程所打开的所有句柄。下面来看一个例子： 在虚拟机中，先打开应用程序计算器，然后运行如下代码： c1234567891011121314151617181920#include \"stdafx.h\"#include \"Windows.h\"int main(int argc, char* argv[]){ DWORD pid; HANDLE hProcess; HWND hwnd = FindWindow(NULL,\"计算器\"); GetWindowThreadProcessId(hwnd, &pid); for (int i = 0; i < 10; i++) { hProcess = OpenProcess(PROCESS_ALL_ACCESS,TRUE, pid); printf(\"句柄：%x\\n\", hProcess); } getchar(); return 0;} 在这个代码中，我们会在程序中重复10次打开计算器 根据打印的结果来看，可以发现，尽管是打开的是同一个进程，但是每次打开时的句柄都不一样。下面我们来根据句柄表的位置来查找一下这些句柄： 首先，在Windbg中，根据进程结构体地址，确定句柄表结构体所在位置 然后，在句柄表结构体中，找到存储句柄表的存储结构所在地址 最后，根据句柄表存储结构的地址，找到当前进程所打开的别的进程的句柄 这里有一点需要说明一下，在应用层，句柄是一个四字节的数，但是在内核存储时，句柄表的每个成员是8字节，因此在查询的时候，3环得到句柄的值需要先除以4再乘8，才能在句柄表中找到对应的句柄（3环句柄相当于是一个查询的编号）。现在我们知道如何通过进程的句柄表找到其打开进程的句柄。现在我们来看看0环中这个句柄的结构。 句柄的结构先来看看句柄的结构是如何定义的（取自潘爱民老师的Windows内核原理与实现） c1234567891011121314151617181920212223typedef struct _HANDLE_TABLE_ENTRY{ union { PVOID Object; //指向句柄所代表的对象 (bit31- bit0) ULONG_PTR ObAttributes; //最低3位有特别含义，参见OBJ_HANDLE_ATTRIBUTES宏定义 PHANDLE_TABLE_ENTRY_INFO InfoTable; //各个句柄表页面的第一个句柄表项，使用此成员指向一张表 ULONG_PTR Value; }; union { union { ULONG GrantedAccess; //访问掩码 struct { //当NtGlobalFlag中包含 FLE_KERNEL_STACK_TRACE_DB 标记时使用 USHORT GrantedAccessIndex; USHORT CreatorBackTraceIndex; }; }; LONG NextFreeTableEntry; //空闲时表示下一个句柄表索引 };} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY; 直接看结构定义的话，有太多的联合体，看着比较费劲，下面用一张图来解释一下（图片取自张嘉杰的笔记） 句柄共8字节，64位，主要分为4个部分，接下来按照标记依次介绍： （bit48~bit63）这一块共计两个字节，16位；高位字节是给SetHandleInformation这个函数用的，例如当执行如下语句： c1SetHandleInformation(Handle,HANDLE_FLAG_PROTECT_FROM_CLOSE,HANDLE_FLAG_PROTECT_FROM_CLOSE); 这个位置将会被写入0x02 （bit32~bit47）这一块也是两个字节，16位；这块是访问掩码，是给OpenProcess这个函数用的，即OpenProcess的第一个参数 DWORD dwDesiredAccess的值 （bit0~bit31）这两块共计四个字节，32位，各个位主要含义如下： bit0：OBJ_PROTECT_CLOSE，表示调用者是否允许关闭该句柄；默认值为1 bit1：OBJ_INHERIT，指示该进程创建的子进程是否可以继承该句柄，即是否将该句柄项拷贝到它们的 句柄表中 bit2：OBJ_AUDIT_OBJECT_CLOSE，指示关闭该对象时是否产生一个审计事件；默认值为0 bit3~31：存放该内核对象在内核中的具体地址 内核对象_OBJECT_HEADER通过上文的学习了，我们了解到句柄的低32位可以获取到内核对象的地址。之前的文章学习过，例如进程，线程，互斥体都属于内核对象，并且它们都有各自的结构体，那是不是句柄指向的地址就是这些结构体的地址呢？其实不然，拿进程来举例，内核对象在开头都有一个0x18字节的_OBJECT_HEADER结构，这是内核对象的头部，也就是说从0x18字节开始， 才是进程结构体开始的位置。_OBJECT_HEADER结构如下 这个_Object_Header包含一些对内核对象的描述信息，其中一个字段Type，指明了内核对象的类型，并包含更多的描述信息 进程查找在进程与线程相关篇章中，我们学习了很多种查找进程的方式，现在又多了一种，就是通过句柄表。有了上面的基础后，可以总结出这么一个思路： 已知当前进程EPROCESS -> _HANDLE_TABLE（EPROCESS+0xc4）-> TableCode -> _OBJECT_HEADER（TableCode + 3环句柄/4*8）-> 打开的进程EPROCESS（OBJECT_HEADER+0x18） 下面简要演示一下这个过程： 第一步：获取3环句柄 第二步：EPROCESS -> _HANDLE_TABLE（EPROCESS+0xc4） 第三步： _HANDLE_TABLE（EPROCESS+0xc4）-> TableCode 第四步：TableCode -> _OBJECT_HEADER（TableCode + 3环句柄/48，*这里注意查询时要将后3bit清零**） -> 打开的进程EPROCESS（OBJECT_HEADER+0x18） 关于反调试句柄表和反调试，进程遍历也是息息相关的，进程遍历会在下一篇全局句柄表中再作分析。这里简单介绍反调试。一个进程加载进内存后，可以起一个线程，专门去遍历其他所有进程的句柄表，如果发现，某个进程的句柄表中有自己进程的句柄，说明自己的这个进程可能正在被调试，就算没有在被调试，也至少被打开了，这时就可以强行关闭自己的程序，不被调试，达到反调试的目的。当然反调试有很多种手段，在调试章节会再作分析。 总结 一个进程可以创建、打开很多内核对象，这些内核对象的地址存储在当前进程的句柄表中。我们在应用层得到的句柄值，实际上就是当前进程句柄表的索引。 同一个内核对象可以被不同的进程所引用，但句柄的值可能一样也可能不一样。 通过句柄表可以找到当前进程所打开或创建的其它内核对象。 参考资料参考书籍：《Windows内核原理与实现》——潘爱民 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=67 参考文章： https://blog.csdn.net/weixin_42052102/article/details/83476572 https://blog.csdn.net/qq_41988448/article/details/104945311 https://www.cnblogs.com/joneyyana/p/12595525.html 参考笔记：张嘉杰，时间刺客.","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Inline Hook SSDT","slug":"Inline-Hook-SSDT","date":"2020-04-20T02:21:29.000Z","updated":"2020-04-20T06:57:38.673Z","comments":true,"path":"2020/04/20/Inline-Hook-SSDT/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/20/Inline-Hook-SSDT/","excerpt":"","text":"一个月前，曾更过一篇博客，简要介绍了使用Hook手段实现对某社交软件实时聊天内容的输出打印。那次实中使用的手段就是Inline Hook，在那篇文章中也比较详细的介绍了如何编写Inline Hook的代码。本篇不再赘述Hook具体细节，简要说明原理并演示Hook过程。 Inline Hook原理无论是3环还是0环，Inline Hook的原理是一样的： 通过修改函数中的指令，改变程序执行的流程 跳转到自己定义的代码段中执行 最后再返回到原始函数中 注意：Hook期间修改掉的原始函数中的代码部分要写入到自身程序中，以保证程序能够完整运行。在Hook结束后（获取自身想要的数据或执行部分功能后），再将修改的部分字节写回到原本的地方，完成Unhook，实现无痕Hook。 Inline Hook SSDT思路本篇通过Inline Hook SSDT，实现和SSDT Hook同样的功能（定义SSDT结构、找到SSDT表、修改物理页属性），相同部分将省略，可参考前一篇SSDT Hook中的代码。 选择Hook点SSDT Hook和Inline Hook的最大区别在于，SSDT Hook仅需要修改系统服务表中的地址即可，而Inline Hook需要找到相应的函数，修改函数中的部分指令，让新的指令执行时会跳转到自己的函数。通常情况下，Inline Hook会根据需要修改字节的大小，选择不同的修改指令，主要有以下三种： Code11. jmp xxxxxxxx (5字节) Code12. push xxxxxxxx/retn (6字节) Code13. mov eax, xxxxxxxx/jmp eax (7字节) 本次实验选取的Hook函数仍然是NtOpenProcess 个人习惯使用6字节的指令进行修改，这里选取了距离NtOpenProcess函数起始地址0x14偏移处的6个字节指令，这6个字节刚好对应3行指令。适合作为Hook点。 构造自己的函数与SSDT Hook不同，Inline Hook不需要构造一个类似的MyNtOpenProcess写入到系统服务表中，因为本身执行的就是NtOpenProcess函数，只是执行时会跳转到我们的代码中继续执行，所以我们需要构造一个自己的函数，用于实现部分功能。 通常情况下，自己实现的函数采用裸函数的形式。这样编译器不会自动帮你生成例如： Code12345_asm { push ebp mov ebp, esp sub esp, 0x??} 这样的指令。因为这样会导致堆栈发生变化，获取参数会变得困难。 本次实验实现的功能，同样是打印NtOpenProcess传入进来的参数。那么就有一个新的问题？如何获取参数呢？这里涉及到3环逆向的一些基本知识，这里只做简要分析 观察NtOpenProcess部分反汇编，可以发现，在Hook点之前，并没有参数通过常用的传参寄存器（ebx，eax，ecx）传入参数，后面部分的汇编，已经给eax/ecx赋值了，说明参数不是通过寄存器传参的，所以一定是通过堆栈传参的。这样就很方便了，我们可以通过[ebp+0x8]，[ebp+0xc]，[ebp+0x10]，[ebp+0x14]。获取到NtOpenProcess的参数，用全局变量保存参数，并在自己的函数中打印。代码如下： c123456789101112131415161718192021222324252627282930313233//用于接收参数的全局变量ULONG ProcessHandle;ULONG DesiredAccess;ULONG ObjectAttributes;ULONG ClientId;//定义实现自己功能的函数VOID __declspec(naked) MyOwnNtFunction() { __asm { pushad pushfd mov eax, [ebp + 0x8] mov ProcessHandle, eax mov eax, [ebp + 0xc] mov DesiredAccess, eax mov eax, [ebp + 0x10] mov ObjectAttributes, eax mov eax, [ebp + 0x14] mov ClientId, eax } DbgPrint(\"ProcessHandle: %x, DesiredAccess: %x, ObjectAttributes: %x, ClientId: %x\\n\", ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); __asm { pushfd pushad xor eax, eax lea edi, [ebp - 0x28] stos dword ptr es : [edi] jmp JmpBackAddr }} 最后一段嵌入的汇编有何用呢？也是非常重要的，因为我们修改了原始函数的6个字节，也就是3行指令，为了保证程序正常执行，需要在自己的函数中添加上这3行指令，执行后直接跳转到3行指令之后的位置执行即可保证程序正常执行。 构造修改指令因个人习惯，Inline Hook比较爱使用6字节的方式，主要原因是懒得算Jmp造成的偏移……这部分的手法在Hook聊天内容那篇文章讲过，这里仅作简要说明： 初始化一个6个字节的数组 下标0的位置设置为”\\x68”，即push 0x????????指令对应的硬编码 下标5的位置设置为”\\xc3”，即ret指令对应的硬编码（这里采用\\x，是用来表明这是个16进制数） 下标1~4的位置，设置成自己函数的地址 实现代码如下： c1234//设置修改部分指令Modify_Byte[0] = '\\x68';*(ULONG*)(Modify_Byte + 1) = (ULONG)(MyOwnNtFunction);Modify_Byte[5] = '\\xc3'; Hook与Unhook既然有Hook，也要有Unhook完成卸载。由于Inline Hook原理是修改指令对应的硬编码，因此使用RtlMoveMemory来实现对Hook点部分的代码进行修改，注意不能忘记修改物理页的属性。代码如下： c12345678910111213//Hook函数VOID HookNtOpenProcess() { PageProtectOff(); RtlMoveMemory((PUCHAR)ModifyAddr, Modify_Byte, 6); PageProtectOn();}//Unhook函数VOID UnHookNtOpenProcess() { PageProtectOff(); RtlMoveMemory((PUCHAR)ModifyAddr, Recover_Byte, 6); PageProtectOn();} 功能演示 Hook前代码 Hook执行后 可以在DbgView中看到不断有NtOpenProcess函数的参数在被输出，说明Hook成功，实现了和SSDT Hook同样的功能。 打开Windbg断下后查看NtOpenProcess函数代码 发现原本的代码已经被替换成了我们自己的代码，会跳转到自己的函数中。 打开PC Hunter，内核钩子选项 可以看到PC Hunter同样检测到了我们的对大小为6个字节Hook的代码 最后，我们选择停止驱动的执行。完成UnHook的操作，这时再去查看代码 可以看到代码已经完整的修改回去了 完整代码c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include \"ntddk.h\"//定义系统服务表结构typedef struct _KSYSTEM_SERVICE_TABLE { PULONG ServiceTableBase; //服务函数地址表基址 PULONG Count; ULONG ServiceLimit; //服务函数的个数 PULONG ArgmentTableBase; //服务函数参数表地址}KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;//定义系统服务描述符表（SSDT）结构typedef struct _KSERVICE_DESCRIPTOR_TABLE { KSYSTEM_SERVICE_TABLE ntoskrnl; //ntoskrnl.exe的服务函数 KSYSTEM_SERVICE_TABLE win32k; //win32k.sys的服务函数，(GDI32.dll/User32.dll 的内核支持) KSYSTEM_SERVICE_TABLE notUsed1; KSYSTEM_SERVICE_TABLE notUsed2;}KSERVICE_DESCRIPTOR_TABLE, *PSERVICE_DESCRIPTOR_TABLE;extern PKSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;//函数声明VOID HookNtOpenProcess();VOID UnHookNtOpenProcess();VOID PageProtectOff();VOID PageProtectOn();VOID Driver_Unload(PDRIVER_OBJECT pDriverObj);//定义原函数为全局变量ULONG OriginFunctionAddr;ULONG ModifyAddr;ULONG JmpBackAddr;UCHAR Modify_Byte[6] = {0};UCHAR Recover_Byte[6] = {0x33, 0xc0, 0x8d, 0x7d, 0xd8, 0xab};//用于接收参数的全局变量ULONG ProcessHandle;ULONG DesiredAccess;ULONG ObjectAttributes;ULONG ClientId;VOID __declspec(naked) MyOwnNtFunction() { __asm { pushad pushfd mov eax, [ebp + 0x8] mov ProcessHandle, eax mov eax, [ebp + 0xc] mov DesiredAccess, eax mov eax, [ebp + 0x10] mov ObjectAttributes, eax mov eax, [ebp + 0x14] mov ClientId, eax } DbgPrint(\"ProcessHandle: %x, DesiredAccess: %x, ObjectAttributes: %x, ClientId: %x\\n\", ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); __asm { pushfd pushad xor eax, eax lea edi, [ebp - 0x28] stos dword ptr es : [edi] jmp JmpBackAddr }}NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) { DbgPrint(\"Driver is running!\\n\"); OriginFunctionAddr = (KeServiceDescriptorTable->ServiceTableBase)[0x7A]; ModifyAddr = OriginFunctionAddr + 0x14; JmpBackAddr = ModifyAddr + 0x6; DbgPrint(\"OriginFunctionAddr: %x\\n \\ ModifyAddr: %x\\n \\ JmpBackAddr: %x\\n\", OriginFunctionAddr, ModifyAddr, JmpBackAddr); //Check Modify Byte Modify_Byte[0] = '\\x68'; *(ULONG*)(Modify_Byte + 1) = (ULONG)(MyOwnNtFunction); Modify_Byte[5] = '\\xc3'; for (ULONG i = 0; i < 6; i++) { DbgPrint(\"%x \", Modify_Byte[i]); } HookNtOpenProcess(); pDriverObj->DriverUnload = Driver_Unload; return STATUS_SUCCESS;}VOID HookNtOpenProcess() { PageProtectOff(); RtlMoveMemory((PUCHAR)ModifyAddr, Modify_Byte, 6);// DbgPrint(\"Hook Starting...\\n\"); PageProtectOn();}VOID UnHookNtOpenProcess() { PageProtectOff(); RtlMoveMemory((PUCHAR)ModifyAddr, Recover_Byte, 6); PageProtectOn();}VOID PageProtectOff() { __asm { cli mov eax, cr0 and eax, not 0x10000 mov cr0, eax }}VOID PageProtectOn() { __asm { mov eax, cr0 or eax, 0x10000 mov cr0, eax sti }}VOID Driver_Unload(PDRIVER_OBJECT pDriverObj) { UnHookNtOpenProcess(); DbgPrint(\"Unload Success!\\n\");} 总结尽管Inline Hook相比较SSDT Hook而言，更不容易被查出来，但是PC Hunter还是可以查到我们Inline Hook的代码。到此为止，驱动这块内容就差不多了，和Win32窗口程序一样有着固定的格式，具体功能实现还是要看自己的需求。多核同步的关键在于同步，会在句柄表之后介绍。再接下来是更为复杂的APC，估计要花好一段时间来更新了。至于内核重载，可能要延一延了，涉及到的原理和3环逆向相关的较多。计划是在更新完APC后再复习3环逆向的一些内容，内核重载就更要靠后了。最近可能会确定开新坑了，把Android逆向基础的部分更一更，2月中旬以来，已经快俩月没碰Android了，手生了，需要回味一下。 参考资料参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=63 参考文章：https://blog.csdn.net/qq_41988448/article/details/103557383 参考文档：https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"SSDT Hook","slug":"SSDT_Hook","date":"2020-04-17T01:46:37.000Z","updated":"2020-04-19T16:49:44.861Z","comments":true,"path":"2020/04/17/SSDT_Hook/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/17/SSDT_Hook/","excerpt":"","text":"经过IRP那一章，发现如果文章篇幅过长（那篇我粘了很多结构定义的代码），网页端是无法显示出来博客内容的，只能分篇，看起来会比较麻烦，以后会尽量讲的精炼，也方便自己以后查看。虽然现在依然是4月19日，但是代码是4月17日写的，就算作是那天的博客吧。这一篇主要讲解一下SSDT Hook的手法，并实现一个简单的SSDT Hook 系统服务表&SSDT关于系统服务表和SSDT的细节可以参考这里，本篇不再赘述，仅作简要介绍。 系统服务表（SystemServiceTable）：之前在3环进0环时有讲过，因为3环调用0环函数时，需要提供一个系统服务号，就是在系统服务表里进行寻址用的。 SSDT（System Service Desciptor Table）：系统服务描述符表，是一张已经导出的包含了4张系统服务表的表。其中只有第一张系统服务表可见。 通过如下语句声明，即可获取到SSDT表的首地址 c1extern PKSYSTEM_SERVICE_TABLE KeServiceDescriptorTable; SSDT Shadow（System Service Desciptor Table Shadow）：一张未导出的表，与SSDT类似，不同的在于，SSDT Shadow两张表均可见。由于未导出，需要通过其它方式进行查找，例如内存搜索。 SSDT Hook原理Hook总的来说可以分为两类：表Hook（例如IAT Hook）和地址Hook（例如Inline Hook，下一篇会讲） 表Hook：主要是通过修改函数表中的函数，替换为自己的函数从而达到Hook的目的 地址Hook：通过修改函数内部的部分字节，从而跳转到指定地方，改变程序执行流程，从而达到Hook目的 本篇中介绍的SSDT Hook属于表Hook。SSDT Hook的原理在于，通过SSDT找对应的系统服务表，在系统服务表中找到指定的内核函数，将其替换为自己的函数，从而达到Hook的目的。 SSDT Hook思路找到系统服务表由于SSDT是导出的，声明后即可获取SSDT地址，但是内核文件并未提供SSDT及系统服务表的结构体，这里我们需要自己先定义SSDT和系统服务表的结构体，并声明SSDT，代码如下： c1234567891011121314151617//定义系统服务表结构typedef struct _KSYSTEM_SERVICE_TABLE { PULONG ServiceTableBase; //服务函数地址表基址 PULONG Count; ULONG ServiceLimit; //服务函数的个数 PULONG ArgmentTableBase; //服务函数参数表地址}KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;//定义系统服务描述符表（SSDT）结构typedef struct _KSERVICE_DESCRIPTOR_TABLE { KSYSTEM_SERVICE_TABLE ntoskrnl; //ntoskrnl.exe的服务函数 KSYSTEM_SERVICE_TABLE win32k; //win32k.sys的服务函数，(GDI32.dll/User32.dll 的内核支持) KSYSTEM_SERVICE_TABLE notUsed1; KSYSTEM_SERVICE_TABLE notUsed2;}KSERVICE_DESCRIPTOR_TABLE, *PSERVICE_DESCRIPTOR_TABLE;extern PKSYSTEM_SERVICE_TABLE KeServiceDescriptorTable; 构建自己的函数本次实验采用对NtOpenProcess进行Hook，所以我们需要构建一个自己的MyNtOpenProcess函数。构建自己的函数有如下注意事项： 参数必须与原函数一致，否则执行时会崩溃 实现自己的功能，例如打印参数等 调用原本的函数，若不调用原本的函数，该函数将无法执行下去实现原本的功能，也会造成程序崩溃。 所以需要先定义一个函数指针，并用一个全局变量保存原函数的地址（在系统服务表中找到NtOpenProcess，该函数的系统服务号是0x7A），在自己的MyNtOpenProcess中执行完自身的功能调用原函数完成整个程序的执行。代码如下： c123456789101112131415161718192021222324252627//定义调用NtOpenProcess的函数指针typedef NTSTATUS(*NTOPENPROCESS)( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId );//定义全局变量保存原函数地址ULONG OriginFunctionAddr = (KeServiceDescriptorTable->ServiceTableBase)[0x7A];//实现自己的MyNtOpenProcess函数NTSTATUS MyNtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId) { //执行自己的功能，这里是打印NtOpenProcess的参数 DbgPrint(\"ProcessHandle: %x, DesiredAccess: %x, ObjectAttributes: %x, ClientId: %x\\n\", ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); NTOPENPROCESS pOpenProcess = (NTOPENPROCESS)OriginFunctionAddr; pOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); return STATUS_SUCCESS;} 修改系统服务表地址NtOpenProcess的系统服务号是0x7A，这一步看上去很简单，只需要修改系统服务表中，下标为0x7A那个函数的地址为自己MyNtOpenProcess函数的地址即可。但是有一点需要注意的是，系统服务表所对应的物理页是只读的，所以在修改前我们需要先修改物理页的属性。有如下两种方式： 通过页表基址修改物理页属性 c1234567891011121314if(RCR4 & 0x00000020){//说明是2-9-9-12分页 KdPrint((\"2-9-9-12分页 %p\\n\",RCR4)); KdPrint((\"PTE1 %p\\n\",*(DWORD*)(0xC0000000 + ((HookFunAddr >> 9) & 0x007FFFF8)))); *(DWORD64*)(0xC0000000 + ((HookFunAddr >> 9) & 0x007FFFF8)) |= 0x02; KdPrint((\"PTE1 %p\\n\",*(DWORD*)(0xC0000000 + ((HookFunAddr >> 9) & 0x007FFFF8))));}else{//说明是10-10-12分页 KdPrint((\"10-10-12分页\\n\")); KdPrint((\"PTE1 %p\\n\",*(DWORD*)(0xC0000000 + ((HookFunAddr >> 10) & 0x003FFFFC)))); *(DWORD*)(0xC0000000 + ((HookFunAddr >> 10) & 0x003FFFFC)) |= 0x02; KdPrint((\"PTE2 %p\\n\",*(DWORD*)(0xC0000000 + ((HookFunAddr >> 10) & 0x003FFFFC))));} 通过修改CR0寄存器 代码如下： Code1234567891011121314151617VOID PageProtectOff() { __asm { cli mov eax, cr0 and eax, not 0x10000 mov cr0, eax }}VOID PageProtectOn() { __asm { mov eax, cr0 or eax, 0x10000 mov cr0, eax sti }} 本次实验采用的是第二种方式，修改Cr0寄存器达成Hook的目的，代码如下： c123456VOID HookNtOpenProcess() { PageProtectOff(); (KeServiceDescriptorTable->ServiceTableBase)[0x7A] = &MyNtOpenProcess; DbgPrint(\"Hook Starting...\\n\"); PageProtectOn();} 设置Unhook函数Hook完实现自身功能，达成目的之后，需要设置一个Unhook函数，把系统服务表再改回来，所以还需要设置一个Unhook函数，这个函数就比较简单了，只需要把原函数的地址再写回去即可，需要通过先前代码设置一个全局变量保存原函数的地址。代码如下： c12345678910//设置全局变量，保存原函数的地址ULONG OriginFunctionAddr = (KeServiceDescriptorTable->ServiceTableBase)[0x7A];//Unhook函数VOID UnHookNtOpenProcess() { PageProtectOff(); (KeServiceDescriptorTable->ServiceTableBase)[0x7A] = OriginFunctionAddr; DbgPrint(\"UnHook Finished!\\n\"); PageProtectOn();·} 功能演示在执行驱动前，查看PC Hunter，可以发现SSDT并没有函数被挂钩 执行后，在DebugView中可以看到，不断有NtOpenProcess的参数被写入，说明不断有新的进程被打开，我们打开一个记事本文件，同样会增加一些参数的打印 这时，我们再次查看PC Hunter，发现PC Hunter已经被检测到了SSDT表被挂钩子了，也说明这次实验SSDT Hook成功了 完整代码附上完整代码作为参考 c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include \"ntddk.h\"//定义调用NtOpenProcess的函数指针typedef NTSTATUS(*NTOPENPROCESS)( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId );//定义系统服务表结构typedef struct _KSYSTEM_SERVICE_TABLE { PULONG ServiceTableBase; //服务函数地址表基址 PULONG Count; ULONG ServiceLimit; //服务函数的个数 PULONG ArgmentTableBase; //服务函数参数表地址}KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;//定义系统服务描述符表（SSDT）结构typedef struct _KSERVICE_DESCRIPTOR_TABLE { KSYSTEM_SERVICE_TABLE ntoskrnl; //ntoskrnl.exe的服务函数 KSYSTEM_SERVICE_TABLE win32k; //win32k.sys的服务函数，(GDI32.dll/User32.dll 的内核支持) KSYSTEM_SERVICE_TABLE notUsed1; KSYSTEM_SERVICE_TABLE notUsed2;}KSERVICE_DESCRIPTOR_TABLE, *PSERVICE_DESCRIPTOR_TABLE;extern PKSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;//函数声明NTSTATUS MyNtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);VOID HookNtOpenProcess();VOID UnHookNtOpenProcess();VOID PageProtectOff();VOID PageProtectOn();VOID Driver_Unload(PDRIVER_OBJECT pDriverObj);//定义原函数为全局变量ULONG OriginFunctionAddr;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) { DbgPrint(\"Driver is running!\\n\"); OriginFunctionAddr = (KeServiceDescriptorTable->ServiceTableBase)[0x7A]; /* DbgPrint(\"%x, %x, %x, %x\\n\", KeServiceDescriptorTable->ServiceTableBase, KeServiceDescriptorTable->Count, KeServiceDescriptorTable->ServiceLimit, KeServiceDescriptorTable->ArgmentTableBase); */ // DbgPrint(\"OriginFunctionAddr: %x\", OriginFunctionAddr); HookNtOpenProcess(); pDriverObj->DriverUnload = Driver_Unload; return STATUS_SUCCESS;}NTSTATUS MyNtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId) { DbgPrint(\"ProcessHandle: %x, DesiredAccess: %x, ObjectAttributes: %x, ClientId: %x\\n\", ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); NTOPENPROCESS pOpenProcess = (NTOPENPROCESS)OriginFunctionAddr; pOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); return STATUS_SUCCESS;}VOID HookNtOpenProcess() { PageProtectOff(); (KeServiceDescriptorTable->ServiceTableBase)[0x7A] = &MyNtOpenProcess; DbgPrint(\"Hook Starting...\\n\"); PageProtectOn();}VOID UnHookNtOpenProcess() { PageProtectOff(); (KeServiceDescriptorTable->ServiceTableBase)[0x7A] = OriginFunctionAddr; DbgPrint(\"UnHook Finished!\\n\"); PageProtectOn();}VOID PageProtectOff() { __asm { cli mov eax, cr0 and eax, not 0x10000 mov cr0, eax }}VOID PageProtectOn() { __asm { mov eax, cr0 or eax, 0x10000 mov cr0, eax sti }}VOID Driver_Unload(PDRIVER_OBJECT pDriverObj) { UnHookNtOpenProcess(); DbgPrint(\"Unload Success!\\n\");} 总结通过PC Hunter我们可以发现，SSDT Hook是很容易被检测出来的，也就容易有反制措施，下一篇会介绍另一种Hook的方式：Inline Hook来达成同样的功能或者目的。 参考资料参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=62 参考文章：https://blog.csdn.net/qq_41988448/article/details/103527830 参考笔记：馍馍的笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"初探IRP（代码&程序演示）","slug":"IRP代码部分","date":"2020-04-14T15:58:28.000Z","updated":"2020-04-19T08:43:48.943Z","comments":true,"path":"2020/04/14/IRP代码部分/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/14/IRP%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86/","excerpt":"","text":"由于篇幅太长了，一篇没法装下，所以程序的完整代码和程序演示放到这篇来。程序演示部分需要结合前一篇文章一起看。这里不再赘述具体过程。 完整代码Ring3部分c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include \"stdafx.h\"#include \"Windows.h\"#include \"winioctl.h\"#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)#define SYM_LINK_NAME L\"\\\\\\\\.\\\\MyRing3Device\"int main(int argc, char* argv[]){ //Call IRP_MJ_CREATE getchar(); HANDLE hDevice = CreateFileW( SYM_LINK_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE){ printf(\"Create File Failed!\"); getchar(); return -1; } else { printf(\"Create File Success!\"); } //Call IRP_MY_DEVICE_CONTROL getchar(); char pInputBuffer[20] = {1, 2, 4, 8, 16, 32, 64, 0}; char pOutputBuffer[20] = {0}; DWORD dwReturnSize = 0; BOOL bDIC = DeviceIoControl(hDevice, OPCODE2, pInputBuffer, 8, pOutputBuffer, 20, &dwReturnSize, NULL); if(bDIC != 0){ printf(\"ReturnSize: %x\\n\", dwReturnSize); printf(\"OutputBuffer: \"); for(int i = 0; i < dwReturnSize; i++){ printf(\"%x \", pOutputBuffer[i]); } } else { printf(\"Communicate Failed!\\n\"); return -1; } printf(\"\\nRing3 And Ring0 Communicate Success!\\n\"); //Call IRP_MJ_CLOSE getchar(); BOOL bCH = CloseHandle(hDevice); if(bCH != 0){ printf(\"Close File Success!\"); } getchar(); return 0;} Ring0部分c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include \"ntifs.h\"#define DEVICE_NAME L\"\\\\Device\\\\MyDevice\"#define SYM_LINK_NAME L\"\\\\??\\\\MyRing3Device\"#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj);NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);//Driver Entry NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) { DbgPrint(\"Driver is running!\\n\"); PDEVICE_OBJECT pDeviceObj = NULL; NTSTATUS status = 0; //Create Deivce Object UNICODE_STRING DeviceName; RtlInitUnicodeString(&DeviceName, DEVICE_NAME); status = IoCreateDevice(pDriverObj, 0, &DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &pDeviceObj); if (status != STATUS_SUCCESS) { DbgPrint(\"Device Create Failed!\\n\"); return status; } else { DbgPrint(\"Device Create Success!\\n\"); } //Set Communicate Ways //注意这里一定要用\"|=\", 而不能直接用\"=\",因为在创建Device时会给Fllags赋上一个初值 pDeviceObj->Flags |= DO_BUFFERED_IO; //Create Symbollic Link UNICODE_STRING SymbolicLinkName; RtlInitUnicodeString(&SymbolicLinkName, SYM_LINK_NAME); IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName); //Set Dispatch Function pDriverObj->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc; pDriverObj->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc; pDriverObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc; //Set Unload Function pDriverObj->DriverUnload = Drvier_Unload; return STATUS_SUCCESS;}NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) { DbgPrint(\"Irp Create Dispatch Function...\\n\"); pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;}NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) { DbgPrint(\"Irp Close Dispatch Function...\\n\"); pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;}NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) { DbgPrint(\"Irp DeviceControl Dispatch Function...\\n\"); //获取缓冲区数据 PVOID pSystemBuffer = pIrp->AssociatedIrp.SystemBuffer; //获取IO_STACK_LOCATION PIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp); ULONG InputBufferLength = pStackLocation->Parameters.DeviceIoControl.InputBufferLength; ULONG FsControlCode = pStackLocation->Parameters.DeviceIoControl.IoControlCode; //判断操作码 switch (FsControlCode) { case OPCODE1: DbgPrint(\"不打印操作码\"); pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 2; break; case OPCODE2: DbgPrint(\"操作码：%x\\n\", FsControlCode); for (UINT32 i = 0; i < InputBufferLength; i++) { DbgPrint(\"Ring3 Data: %x\\n\", ((PUCHAR)pSystemBuffer)[i]); } pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 5; break; } IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;}VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj) { //Delete SymbolicLink UNICODE_STRING SymbolicLinkName; RtlInitUnicodeString(&SymbolicLinkName, SYM_LINK_NAME); IoDeleteSymbolicLink(&SymbolicLinkName); //Delete Deivce IoDeleteDevice(pDriverObj->DeviceObject); DbgPrint(\"Unload Success!\\n\");} 程序演示操作码1 操作码2","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"初探IRP（原理&程序思路）","slug":"初探IRP","date":"2020-04-14T15:43:42.000Z","updated":"2020-04-19T08:43:01.175Z","comments":true,"path":"2020/04/14/初探IRP/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/14/%E5%88%9D%E6%8E%A2IRP/","excerpt":"","text":"通过前一篇文章的学习了解到IRP是Windows系统中用于表达一个I/O请求的核心数据结构，当内核模式代码要发起一个I/O请求时，它会构造一个IRP，用于在处理该I/O请求的过程中代表该请求。 IRP结构IRP对象从一个I/O请求被发起时开始存在，一直到该I/O请求被完成或者取消为止，在此过程中，会有多方操纵此IRP对象，包括I/O管理器、即插即用管理器、电源管理器以及一个或多个驱动程序等。Windows I/O系统本质上支持异步I/O请求，所以，IRP对象必须携带足够多的环境信息，以便能够描述一个I/O请求的所有状态。下面来研究一下IRP这个结构。 看上去结构并不复杂，但其中有很多字段包含了结构体，结构体内又内嵌了结构体和联合体，下面结合官方文档中结构的定义来分析（写入到注释中） c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef struct _IRP { CSHORT Type; //IRP类型，等于IO_TYPE_IRP宏 USHORT Size; //IRP大小 PMDL MdlAddress; //该I/O请求的用户缓冲区的MDL，仅用于“直接I/O”类型 ULONG Flags; //用于记录各种标志 union { struct _IRP *MasterIrp; //若这是一个关联IRP，则指向主IRP __volatile LONG IrpCount; //若这是一个主IRP，则必须先完成多少个关联IRP PVOID SystemBuffer; //该操作被缓冲起来，指向系统地址空间缓冲区的地址 } AssociatedIrp; LIST_ENTRY ThreadListEntry; //链表项，可以加入到线程的未完成I/O请求链表中 IO_STATUS_BLOCK IoStatus; //I/O操作的状态 KPROCESSOR_MODE RequestorMode; //内核模式I/O请求或用户模式I/O请求 BOOLEAN PendingReturned; //未完成返回 CHAR StackCount; //栈单元（IO_STACK_LOCATION）计数 CHAR CurrentLocation; //当前栈单元位置 BOOLEAN Cancel; //该I/O请求是否已被取消 KIRQL CancelIrql; //取消自旋锁在哪级IRQL上被获取 CCHAR ApcEnvironment; //用于当该IRP被初始化时保存APC环境 UCHAR AllocationFlags; //该IRP内存的分配控制标志 PIO_STATUS_BLOCK UserIosb; //用户的I/O状态块 PKEVENT UserEvent; //用户事件对象 union { struct { union { PIO_APC_ROUTINE UserApcRoutine; //当I/O请求完成时执行的APC例程 PVOID IssuingProcess; }; PVOID UserApcContext; //传递给UserApcRoutine的环境参数 } AsynchronousParameters; LARGE_INTEGER AllocationSize; //分配块的大小 } Overlay; __volatile PDRIVER_CANCEL CancelRoutine; //若是可取消的I/O请求，该域包含了取消时调用的例程 PVOID UserBuffer; //调用者（即发起者，往往是3环程序）提供的输出缓冲区地址 //以下Tail联合成员用于当I/O管理器处理该I/O请求时存放各种工作信息 union { struct { union { KDEVICE_QUEUE_ENTRY DeviceQueueEntry; //设备队列项 struct { PVOID DriverContext[4]; //由驱动程序解释和使用 }; }; PETHREAD Thread; //指向发起者线程的EHTREAD PCHAR AuxiliaryBuffer; //辅助缓冲区 struct { LIST_ENTRY ListEntry; //存放到完成队列中的链表项 union { struct _IO_STACK_LOCATION *CurrentStackLocation; //指向当前栈单元，驱动程序不可直接访问 ULONG PacketType; //Minipacket的类型 }; }; PFILE_OBJECT OriginalFileObject; //指向原始的文件对象 } Overlay; KAPC Apc; //特殊内核模式APC或发起者的APC PVOID CompletionKey; //完成键，用于标识在不同文件句柄上的I/O请求 } Tail;} IRP; 根据注释，可以大致了解IRP结构各个字段的含义及作用，这里主要介绍几个接下来会用到的： AssociatedIrp.SystemBuffer：根据定义，可以发现它是一个指向系统地址空间缓冲区的指针。这个系统地址空间缓冲区又是什么？在前一篇中，我们曾介绍过，在创建完设备对象后，需要设置设备对象的Flags字段，也就是设置数据传输方式。而这个SystemBuffer字段，就是在采用缓冲区方式读写（DO_BUFFERED_IO）时，指向的内核空间中分配的一块用于数据复制、交换的内存 MdlAddress：和SystemBuffer类似，这个字段也是在通过缓冲区处理I/O请求时，与设置的数据传输方式有关，这个字段在设备对象采用直接方式读写（DO_DIRECT_IO）时有效。当使用这种方式进行数据读写时，I/O请求的发起者调用IoAllocateMdl函数申请一个MDL（Memory Descriptor List，内存描述符链表），将调用者指定的缓冲区的物理页面构成一个MDL，以便于设备驱动程序使用DMA方式来传输数据。这个字段就是记录了一个I/O请求所使用的MDL。 UserBuffer：同上。当设备对象采用的是默认方式读写（NEITHER_IO）时，就会使用这个字段。此时I/O管理器或者I/O请求的发起者不负责缓冲区管理工作，而由驱动程序自行决定该如何使用缓冲区。其中输出缓冲区的指针放在该字段内，缓冲区本身不做任何处理。 IoStatus：I/O操作的状态。这个字段是一个_IO_STATUS_BLOCK结构体 c123456789typedef struct _IO_STATUS_BLOCK { union { NTSTATUS Status; PVOID Pointer; }; ULONG_PTR Information;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK; 1）Status：表示IRP的完成状态，如果三环程序调用完后发生了错误，想通过GetLastError函数来获取错误码，实际上获取到的就是这个Status的值，也就是说，我们自己在驱动中编写特定IRP对应的派遣函数的话，是可以设置它的错误码的。 2）Information：这个数，决定了返回给3环多少数据。某些3环函数，会传入一部分数据进来（IN类型的参数），也会接收一部分数据（OUT类型的参数）。例如，3环传进来一个CHAR数组，有8个元素，但是我们在该函数的派遣函数中设置的Information的值是2，最后这个数组返回到3环时，就只有2个元素了。具体可以参考后面的程序演示部分。 栈单元实际上，IRP数据结构仅仅是一个I/O请求的固定描述部分，另一部分是一个或者多个栈单元。每个栈单元针对单个驱动程序，I/O管理器在处理一个I/O请求时，根据目标设备对象(DeviceObject)的StackSize 域，可以知道最多有多少个驱动程序需要参与到该I/O请求的处理过程中。下面来看一下栈单元这个结构： 看上去，这个结构并不复杂，但实际上要注意一下Parameters这个域，这是一个联合体，包含了不同IRP对应的3环函数原型所需的参数，一起来看一下： c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206union { struct { PIO_SECURITY_CONTEXT SecurityContext; ULONG Options; USHORT POINTER_ALIGNMENT FileAttributes; USHORT ShareAccess; ULONG POINTER_ALIGNMENT EaLength; } Create; struct { PIO_SECURITY_CONTEXT SecurityContext; ULONG Options; USHORT POINTER_ALIGNMENT Reserved; USHORT ShareAccess; PNAMED_PIPE_CREATE_PARAMETERS Parameters; } CreatePipe; struct { PIO_SECURITY_CONTEXT SecurityContext; ULONG Options; USHORT POINTER_ALIGNMENT Reserved; USHORT ShareAccess; PMAILSLOT_CREATE_PARAMETERS Parameters; } CreateMailslot; struct { ULONG Length; ULONG POINTER_ALIGNMENT Key; ULONG Flags; LARGE_INTEGER ByteOffset; } Read; struct { ULONG Length; ULONG POINTER_ALIGNMENT Key; ULONG Flags; LARGE_INTEGER ByteOffset; } Write; struct { ULONG Length; PUNICODE_STRING FileName; FILE_INFORMATION_CLASS FileInformationClass; ULONG POINTER_ALIGNMENT FileIndex; } QueryDirectory; struct { ULONG Length; ULONG POINTER_ALIGNMENT CompletionFilter; } NotifyDirectory; struct { ULONG Length; ULONG POINTER_ALIGNMENT CompletionFilter; DIRECTORY_NOTIFY_INFORMATION_CLASS POINTER_ALIGNMENT DirectoryNotifyInformationClass; } NotifyDirectoryEx; struct { ULONG Length; FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass; } QueryFile; struct { ULONG Length; FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass; PFILE_OBJECT FileObject; union { struct { BOOLEAN ReplaceIfExists; BOOLEAN AdvanceOnly; }; ULONG ClusterCount; HANDLE DeleteHandle; }; } SetFile; struct { ULONG Length; PVOID EaList; ULONG EaListLength; ULONG POINTER_ALIGNMENT EaIndex; } QueryEa; struct { ULONG Length; } SetEa; struct { ULONG Length; FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass; } QueryVolume; struct { ULONG Length; FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass; } SetVolume; struct { ULONG OutputBufferLength; ULONG POINTER_ALIGNMENT InputBufferLength; ULONG POINTER_ALIGNMENT FsControlCode; PVOID Type3InputBuffer; } FileSystemControl; struct { PLARGE_INTEGER Length; ULONG POINTER_ALIGNMENT Key; LARGE_INTEGER ByteOffset; } LockControl; struct { ULONG OutputBufferLength; ULONG POINTER_ALIGNMENT InputBufferLength; ULONG POINTER_ALIGNMENT IoControlCode; PVOID Type3InputBuffer; } DeviceIoControl; struct { SECURITY_INFORMATION SecurityInformation; ULONG POINTER_ALIGNMENT Length; } QuerySecurity; struct { SECURITY_INFORMATION SecurityInformation; PSECURITY_DESCRIPTOR SecurityDescriptor; } SetSecurity; struct { PVPB Vpb; PDEVICE_OBJECT DeviceObject; } MountVolume; struct { PVPB Vpb; PDEVICE_OBJECT DeviceObject; } VerifyVolume; struct { struct _SCSI_REQUEST_BLOCK *Srb; } Scsi; struct { ULONG Length; PSID StartSid; PFILE_GET_QUOTA_INFORMATION SidList; ULONG SidListLength; } QueryQuota; struct { ULONG Length; } SetQuota; struct { DEVICE_RELATION_TYPE Type; } QueryDeviceRelations; struct { const GUID *InterfaceType; USHORT Size; USHORT Version; PINTERFACE Interface; PVOID InterfaceSpecificData; } QueryInterface; struct { PDEVICE_CAPABILITIES Capabilities; } DeviceCapabilities; struct { PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList; } FilterResourceRequirements; struct { ULONG WhichSpace; PVOID Buffer; ULONG Offset; ULONG POINTER_ALIGNMENT Length; } ReadWriteConfig; struct { BOOLEAN Lock; } SetLock; struct { BUS_QUERY_ID_TYPE IdType; } QueryId; struct { DEVICE_TEXT_TYPE DeviceTextType; LCID POINTER_ALIGNMENT LocaleId; } QueryDeviceText; struct { BOOLEAN InPath; BOOLEAN Reserved[3]; DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type; } UsageNotification; struct { SYSTEM_POWER_STATE PowerState; } WaitWake; struct { PPOWER_SEQUENCE PowerSequence; } PowerSequence;#if ... struct { union { ULONG SystemContext; SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext; }; POWER_STATE_TYPE POINTER_ALIGNMENT Type; POWER_STATE POINTER_ALIGNMENT State; POWER_ACTION POINTER_ALIGNMENT ShutdownType; } Power;#else struct { ULONG SystemContext; POWER_STATE_TYPE POINTER_ALIGNMENT Type; POWER_STATE POINTER_ALIGNMENT State; POWER_ACTION POINTER_ALIGNMENT ShutdownType; } Power;#endif struct { PCM_RESOURCE_LIST AllocatedResources; PCM_RESOURCE_LIST AllocatedResourcesTranslated; } StartDevice; struct { ULONG_PTR ProviderId; PVOID DataPath; ULONG BufferSize; PVOID Buffer; } WMI; struct { PVOID Argument1; PVOID Argument2; PVOID Argument3; PVOID Argument4; } Others; } Parameters; 那这个Parameters该如何用呢？举个例子，假设3环程序调用了DeviceIoControl函数，在0环，就会构造一个IRP_MJ_DEVICE_CONTROL这个类型的IRP，然后我们就可以构建它的派遣函数了。在派遣函数中，当我们获得了当前驱动的栈单元时，就可以通过如下语句访问3环函数DeviceIoControl的参数了，例如： c12345//获取IO_STACK_LOCATIONPIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);//获取3环函数参数ULONG InputBufferLength = pStackLocation->Parameters.DeviceIoControl.InputBufferLength;ULONG FsControlCode = pStackLocation->Parameters.DeviceIoControl.IoControlCode; 其中，IoGetCurrentIrpStackLocation函数，将Irp指针传进去，可以获取当前驱动程序对应的栈单元。接着就可以通过栈单元获取我们想要的参数了 3环与0环通信（升级）操作码在了解了上述知识后，我们就可以对前一篇文章中的代码进行一次升级，更清晰的看到3环和0环的信息交互过程。在此之前，我们需要了解一个操作码。本次实验会在3环程序中新增一个DeviceIoControl函数，因为这个函数能既有传入的参数，也有输出的参数，可以比较直观的看明白3环和0环交互的数据。具体定义如图： 其中需要解释一下的，就是这个dwIoControlCode参数，这个就相当于Switch语句中传入的那个参数，用来判断程序执行流程用的，当操作码不同时，执行的功能也不同，操作码定义如下： c12#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS) CTL_CODE函数，会接收这四个参数，并通过某一种算法，生成一个四字节的操作码，3环和0环中用的是同一套操作码，其中第二个参数，这个值必须选定一个大于等于0x800的值，之前的值由系统保留使用。 新增代码本次实验新增的代码，就是在3环程序增加了DeviceIoControl这个函数，以及相应的驱动增加了派遣函数。具体变化如下： Ring3新增部分： c123456789101112131415161718192021#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)//Call IRP_MY_DEVICE_CONTROL getchar(); char pInputBuffer[20] = {1, 2, 4, 8, 16, 32, 64, 0}; char pOutputBuffer[20] = {0}; DWORD dwReturnSize = 0; BOOL bDIC = DeviceIoControl(hDevice, OPCODE2, pInputBuffer, 8, pOutputBuffer, 20, &dwReturnSize, NULL); if(bDIC != 0){ printf(\"ReturnSize: %x\\n\", dwReturnSize); printf(\"OutputBuffer: \"); for(int i = 0; i < dwReturnSize; i++){ printf(\"%x \", pOutputBuffer[i]); } } else { printf(\"Communicate Failed!\\n\"); return -1; } printf(\"\\nRing3 And Ring0 Communicate Success!\\n\"); 代码中传入一个初始化了8个字节的数组，并且用另一个空数组来接收0环的数据，DeviceIoControl执行完后，根据返回的长度大小，以及返回的Buffer，来打印返回的数据。 Ring0新增部分： c12345678910111213141516171819202122232425262728293031323334#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) { DbgPrint(\"Irp DeviceControl Dispatch Function...\\n\"); //获取缓冲区数据 PVOID pSystemBuffer = pIrp->AssociatedIrp.SystemBuffer; //获取IO_STACK_LOCATION PIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp); ULONG InputBufferLength = pStackLocation->Parameters.DeviceIoControl.InputBufferLength; ULONG FsControlCode = pStackLocation->Parameters.DeviceIoControl.IoControlCode; //判断操作码 switch (FsControlCode) { case OPCODE1: DbgPrint(\"不打印操作码\"); pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 2; break; case OPCODE2: DbgPrint(\"操作码：%x\\n\", FsControlCode); for (UINT32 i = 0; i < InputBufferLength; i++) { DbgPrint(\"Ring3 Data: %x\\n\", ((PUCHAR)pSystemBuffer)[i]); } pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 5; break; } IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;} 来简要看一下派遣函数的执行流程： 由于在设备对象的Flags字段定义过缓冲区读取的类型是（DO_BUFFERED_IO），因此我们可以直接从AssociatedIrp.SystemBuffer中读取3环传入的数据，也就是DeviceIoControl中pInputBuffer参数指向的数据。 通过IoGetCurrentIrpStackLocation函数获取到栈单元，再通过栈单元获取到Parameters中DeviceIoControl结构体里对应的参数 c123456struct { ULONG OutputBufferLength; ULONG POINTER_ALIGNMENT InputBufferLength; ULONG POINTER_ALIGNMENT IoControlCode; PVOID Type3InputBuffer; } DeviceIoControl; 这里我们仅取操作码IoControlCode，用于判断执行流程；以及InputBufferLength，用于打印传入数据 然后就是根据操作码的不同，执行不同的流程了： 1）操作码1：不做任何操作，向3环返回2字节大小的数据 2）操作码2：打印操作码的值；根据传入数据的长度，打印传入的数据；向3环返回5字节大小的数据 完整代码及演示见下篇参考链接参考书籍： 《Windows内核原理与实现》 参考文章： https://www.cnblogs.com/LittleHann/p/3450436.html https://www.cnblogs.com/lfls128/p/4982309.html https://blog.csdn.net/qq_41988448/article/details/103519478 参考笔记： Joney，张嘉杰 参考文档： https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp#irp_mj_read https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentirpstacklocation https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_status_block https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice 关于更新上周过的比较迷，不知道该干什么，因为进度远远落后于计划，日更变得困难了起来，白天完善代码，晚上也来不及更新博客。自身的确有很大问题，比起刚开始的热情，现在没那么有干劲了，人放松了很多，这是个不好的现象。实际上，经历了清明三天的假期，我也逐渐看清了自己。较差的自制力，学习时无法集中注意力等。看着四哥的RMI文章都已经更新到第九篇了，真的自愧不如，我才20出头，却如此懈怠，懒惰。现在已经是4月19号的下午了，而这篇文章原本是13号该更新的（按照日更的进度）。而我目前为止，已经完善的代码仅有SSDT Hook，Inline Hook的代码，在UnHook方面还有一定的瑕疵，还未能完好的解决。日更，不那么现实了，当然，更多的是自身的原因，如果不再日更，就更不知道自己还能不能坚持下来了。但这的确不该放弃，毕竟博客还是一个沉淀知识，分享知识的地方。 这几天，我曾考虑过，写点别的，内容较少的，来维持日更的状态，但是比较恐怖的是，我发现自己并没有足够的内容来写，自身真正掌握的知识太少了，这是非常恐怖的，我也学了这么久计算机了，但是发现，在很多领域，仅仅只是知道点皮毛而已，完全没有知识的积淀。所以，需要提升技术栈的同时也提升深度。 最后一个是，基本上更新完SSDT和Inline Hook这两篇后，驱动剩下的东西就不多了。接下来还有多核同步，句柄表以及APC。中级上的部分也就结束了，但是APC需要分析大量的内核函数，内容巨多，看到群友张嘉杰已经分析完了，真的是非常厉害。到了中级下，没了线上的视频，就得自己探索和扩展一些内容了。我计划在下周更新完内核重载后，就考虑更一些Android或者Web相关的基础内容了。不过由于决定不再日更了，后面内容可能也会更冗长了，但是会更细致一些","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"3环与0环通信（常规方式）","slug":"3环与0环通信（常规方式）","date":"2020-04-12T15:26:24.000Z","updated":"2020-04-16T03:34:31.170Z","comments":true,"path":"2020/04/12/3环与0环通信（常规方式）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/12/3%E7%8E%AF%E4%B8%8E0%E7%8E%AF%E9%80%9A%E4%BF%A1%EF%BC%88%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F%EF%BC%89/","excerpt":"","text":"本篇介绍一下3环与0环通信的原理（常规方式），介绍与之相关的结构体，对象等，最后代码实现并模拟操作系统进行3环和0环的通信。 设备对象内核通信的对象内核中的通信，与应用层窗口间的通信类似，只是封装消息的结构体不同，接收消息结构体的对象不同 窗口通信： 1）消息结构体：MSG 2）接收消息的对象：窗口对象（Hwnd） 内核通信： 1）消息结构体：IRP（I/O Request Package） 2）接收消息的对象：设备对象（DeviceObject） 所以想要在内核通信，需要有(至少)一个用来接收和发送消息的设备对象。 创建设备对象窗口对象的创建也与设备对象也有不少共同点，这里继续拿来类比 窗口对象：1）可以创建多个 2）需要指定父窗口 设备对象：1）可以创建多个 2）需要指定所属驱动对象 Windows提供了内核函数IoCreateDevice用来创建设备对象，参考如下代码： c1234567891011121314151617#define DEVICE_NAME L\"\\\\Device\\\\MyDevice\" PDEVICE_OBJECT pDeviceObj = NULL;UNICODE_STRING DeviceName;RtlInitUnicodeString(&DeviceName, DEVICE_NAME);NTSTATUS status = IoCreateDevice(pDriverObj, 0, &DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &pDeviceObj); if (status != STATUS_SUCCESS) { DbgPrint(\"Device Create Failed!\\n\"); return status;} pDriverObj：指定该设备创建后属于哪个驱动对象（PDRIVER_OBJECT） &DeviceName：定义了一个DEVICE_NAME的宏，被用来初始化设备对象的名字。这个名字不能随便改（即”\\\\Device\\\\xxxxx”形式），在设备创建时，会根据设备名，将该设备挂到一个名为Device的树形结构中，几乎所有设备都挂在这。若改变此值，则会挂到其它树中。 FILE_DEVICE_UNKNOWN：该处填写设备的类型，由于我们并没有实际的设备，所以选择UNKNOWN &pDeviceObj：这个参数可以看作是一个二级指针，它指向一个地址。这个地址存着一个指针pDeviceObj，这个指针指向一个设备结构体。另一个要说明的是，这个参数是一个OUT类型的参数，原本pDeviceObj指向的内容是空的，在执行完设备创建的函数后，其指向创建出的设备对象。 以上为几个比较关键的参数介绍，其余参数按照上述代码填写即可，具体含义可以参考官方文档 数据传输方式 首先查看一下设备对象这个结构体，发现它有很多字段，这里我们只需要关注其中一个，就是Flags，这是一个四字节的值，设置了3环和0环数据交互的方式。语法如下： c12//这里必须是“|=”，不能直接写成“=”pDeviceObj->Flags |= DO_BUFFERED_IO; 来看看有哪几种方式： 缓冲区方式读写（DO_BUFFERED_IO）：I/O管理器会在内核空间中分配一块内存，把用户空间的数据复制到这块内存中，这样内核程序就可以访问这些数据，实现数据通信。适合数据量较小时使用。（之前介绍的跨进程读取内存用的就是这种方法） 直接方式读写（DO_DIRECT_IO）：I/O管理器会将用户空间内的某片内存对应的物理页锁住，同时在内核空间再映射一份，这样内核空间线性地址与用户空间线性地址对应的是同一个物理页，这是双方均可以对这个物理页的内容进行读写，实现数据通信，此方法适合数据量较大时使用。（类似_KUSER_SHARED_DATA结构） 默认方式读写（NEITHER_IO）：当创建完设备对象后，不设置Flags的值，使用的就是此类读写方式。默认读写方式，仅仅提供给内核程序用户空间的线性地址，直接进行数据的读取。这样做的坏处是，如果发生线程切换，读取的就不再是同一份数据，容易造成程序读取错误。 通常情况下，我们实验的数据不会太大，主要采取DO_BUFFERED_IO这种方式。这里有一点要注意的是，在设置DeviceObject.Flags的值时，千万不要直接用”=”，必须使用”|=”，因为在创建设备对象结构体时，Flags是有初始值的，若这里直接给Flags赋值，会刷新掉之前的初始值，导致程序执行时发生错误（驱动技仅能成功执行一次，第二次会失败）。 设置符号链接Windows规定，应用层的程序是不能直接访问设备对象的，所以符号链接诞生了。符号链接可以与设备对象绑定，这样应用层的程序就可以通过符号链接进行对设备对象的访问。符号链接在内核与3环的形式有所不同： 内核：符号链接以”\\??\\“开头，例如C盘就是”\\??\\C:” 用户模式：符号链接以”\\\\.\\“开头，例如C就算”\\\\.\\C:” 具体在代码中还需要加入更多的“\\“用来转译符号，代码如下： Ring0c12345#define SYM_LINK_NAME L\"\\\\??\\\\MyRing3Device\"UNICODE_STRING SymbolicLinkName;RtlInitUnicodeString(&SymbolicLinkName, SYM_LINK_NAME);IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName); Ring3c1234567891011#define SYM_LINK_NAME L\"\\\\??\\\\MyRing3Device\"//3环这里直接使用符号链接指向0环创建设备作为CreateFile的参数//不用再次设置符号链接，符号链接是在0环设置的，这里在3环主要介绍用法HANDLE hDevice = CreateFileW( SYM_LINK_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); IRP与派遣函数对比消息处理先来看一张图 继续拿3环的窗口应用来做对比 用户空间：当用户单击鼠标时，会触发一个事件，操作系统会将这个事件的内容描述信息封装到一个MSG结构中，作为消息，发送给窗口对象，窗口对象接收到消息，会根据这个消息的类型，来执行相应的处理函数，我们称这种处理函数叫做回调函数。 1）触发事件：鼠标点击等 2）消息结构体：MSG 3）消息接收对象：窗口对象 4）处理函数：窗口回调函数 内核空间：当3环程序调用CreateFile函数时，这是操作系统会产生相应的IRP，这个IRP封装了3环程序调用的相关描述信息，接着会把IRP发送给内核空间的设备对象，设备对象会解析IRP，然后会根据IRP提供的信息，执行相应的派遣函数 1）触发事件：3环程序调用CreateFile函数等 2）消息结构体：IRP 3）消息接收对象：设备对象 4）处理函数：派遣函数 IRP的类型正如3环的窗口对象，在接收到不同类型消息时会执行不同的回调函数。当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数对设备进行操作时，也会使操作系统产生不同种类的IRP，这里简要总结一下部分3环函数与IRP的对应关系： 应用层函数 IRP种类 CreateFile IRP_MJ_CREATE ReadFile IRP_MJ_READ WriteFile IRP_MJ_WRITE CloseHandle IRP_MJ_CLOSE DeviceIoControl IRP_MJ_DEVICE_CONTROL 派遣函数1）注册派遣函数当IRP传递给设备对象后，会根据IRP的种类调用特定的派遣函数。不同的IRP对应不同的派遣函数，NT框架预定了28种派遣函数，可以在驱动对象MajorFunction数组中注册这些派遣函数 代码示例： c123//这里仅设置了两个用来演示pDriverObj->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;pDriverObj->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc; 其中IrpCreateProc和IrpCloseProc都是我们需要自己定义的派遣函数，遵守一定的格式 2）派遣函数格式这里以IrpCreateProc来举例： c1234567891011NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) { DbgPrint(\"Irp Create Dispatch Function...\\n\"); /* 处理自己的业务 */ pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;} 参数： 1）设备对象指针 2）IRP指针 IRP是一个结构体，通过指针可以指向IRP内部的一个字段IoStatus（_IO_STATUS_BLOCK结构），该结构中有两个字段： 1）Status：三环程序调用GetLastError得到的就是这个值 2）Information：返回给3环多少数据，没有则填0 IoCompleteRequest：表示调用方已完成所有I/O请求处理操作，并将给定的IRP返回给I/O管理器 以上是必须设置的值/执行的语句，完成后，即可 代码实现有了以上基础后就可以实现简单的3环和0环的通信了，这里附上代码： Ring0c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include \"ntifs.h\"#define DEVICE_NAME L\"\\\\Device\\\\MyDevice\"#define SYM_LINK_NAME L\"\\\\??\\\\MyRing3Device\"#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj);NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);//Driver Entry NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) { DbgPrint(\"Driver is running!\\n\"); PDEVICE_OBJECT pDeviceObj = NULL; NTSTATUS status = 0; //Create Deivce Object UNICODE_STRING DeviceName; RtlInitUnicodeString(&DeviceName, DEVICE_NAME); status = IoCreateDevice(pDriverObj, 0, &DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &pDeviceObj); if (status != STATUS_SUCCESS) { DbgPrint(\"Device Create Failed!\\n\"); return status; } else { DbgPrint(\"Device Create Success!\\n\"); } //Set Communicate Ways //注意这里一定要用\"|=\", 而不能直接用\"=\",因为在创建Device pDeviceObj->Flags |= DO_BUFFERED_IO; //Create Symbollic Link UNICODE_STRING SymbolicLinkName; RtlInitUnicodeString(&SymbolicLinkName, SYM_LINK_NAME); IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName); //Set Dispatch Function pDriverObj->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc; pDriverObj->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc; //Set Unload Function pDriverObj->DriverUnload = Drvier_Unload; return STATUS_SUCCESS;}NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) { DbgPrint(\"Irp Create Dispatch Function...\\n\"); pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;}NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) { DbgPrint(\"Irp Close Dispatch Function...\\n\"); pIrp->IoStatus.Status = STATUS_SUCCESS; pIrp->IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS;}VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj) { //Delete SymbolicLink UNICODE_STRING SymbolicLinkName; RtlInitUnicodeString(&SymbolicLinkName, SYM_LINK_NAME); IoDeleteSymbolicLink(&SymbolicLinkName); //Delete Deivce IoDeleteDevice(pDriverObj->DeviceObject); DbgPrint(\"Unload Success!\\n\");} Ring3c1234567891011121314151617181920212223242526272829303132333435363738#include \"stdafx.h\"#include \"Windows.h\"#include \"winioctl.h\"#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)#define SYM_LINK_NAME L\"\\\\\\\\.\\\\MyRing3Device\"int main(int argc, char* argv[]){ //Call IRP_MJ_CREATE getchar(); HANDLE hDevice = CreateFileW( SYM_LINK_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE){ printf(\"Create File Failed!\"); getchar(); return -1; } else { printf(\"Create File Success!\"); } //Call IRP_MJ_CLOSE getchar(); BOOL bCH = CloseHandle(hDevice); if(bCH != 0){ printf(\"Close File Success!\"); } getchar(); return 0;} 程序测试 载入并运行驱动 运行3环程序 执行CreateFile 执行CloseHandle 查看运行结果，可以看到，在调用3环函数时，会执行相应的驱动函数。若想增加相应功能，只需在派遣函数中写上，即可在调用3环函数时执行，实现3环和0环的通信。当然，这样的结果，看着并不明显，下一篇，会介绍IRP这个结构，并进一步完善这份代码 参考链接参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=61 参考笔记：Joney，张嘉杰 参考代码：Joney，张嘉杰","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"特征码搜索","slug":"特征码搜索","date":"2020-04-11T07:51:51.000Z","updated":"2020-04-13T16:02:42.408Z","comments":true,"path":"2020/04/11/特征码搜索/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/11/%E7%89%B9%E5%BE%81%E7%A0%81%E6%90%9C%E7%B4%A2/","excerpt":"","text":"本篇进行一个小实验，编写一个函数，通过特征码搜索一个未导出函数（PspTerminateProcess），并调用。看着不复杂，但是涉及到了很多细节，这里逐步分析。 什么是未导出函数先介绍一个概念，未导出函数。什么是未导出函数呢？ 这个举个简单的例子，Ntoskrnl.exe中有很多内核函数，其中包括我们之前分析过的NtReadVirtualMemory函数。这个函数是ReadProcessMemory在0环的实现，但它是一个未导出函数，用IDA打开Ntoskrnl.exe，在Exports（导出表）中搜索NtReadVirtualMemory 结果发现，并没有搜索到NtReadVirtualMemory，原因是它并没有被导出，所以导出表里面，没有该函数，但是这个函数又的确存在在Ntoskrnl.exe这个模块中。 未导出函数的主要目的，是不想提供给别人使用，官方文档也不会写入相关内容。因此，我们是不能通过函数名直接调用该函数的。 如何调用未导出函数调用未导出函数主要有两种办法： 特征码搜索，这也是本篇会着重介绍的。在前一篇文章中，提到过可以通过驱动结构体的DriverSection字段，找到一个_LDR_DATA_TABLE_ENTRY结构体，然后即可遍历内核的全部模块。这时，如果我们确定了未导出函数所在的模块，便可以通过在链表中找到模块对应的描述信息，例如模块基址，大小等。这时，我们再利用这些信息，结合未导出函数的特征码，搜索这个模块的内存，便能找到所需的未导出函数。这时只需定义一个函数指针，指向咱们找到的函数首地址，就可以实现对未导出函数的调用。 外层函数调用，如果有一个函数A调用了未导出函数B，那么函数A中一定有未导出函数B的函数地址，我们只要找到这个调用点，就可以确定函数B的地址了。然后再定义一个函数指针，就可实现这个过程。 特征码选择在特征码的选择上也是有讲究的，拿本次实验的PspTerminateProcess函数来举例 结合图片来看。 橙色方框圈住的地方就不适合作为特征码，这部分的语句，比较常见，在很多内核函数中都容易看到，因此不适合作为特征码，有可能会因此找到了别的内核函数。 红色方框圈住的地方相对来说就比较适合作为特征码，当然，连续四行完全相同的语句，还是比较少见的，因此，选中的代码段越多，就越合适作为特征码 有一点需要说明的是，特征码不是汇编，而是硬编码，具体应用时，可以将这些特征码放入到一个字符串中，例如： c1UCHAR AttrCode[6] = {0x8b, 0x75, 0x08, 0x3b, 0x70, 0x44} 然后与指定的内存进行逐一比较，若发现相同的地方，很有可能就找对了对方，然后再减去函数内的偏移，得到函数的首地址，就可以获取该函数了 代码实现这部分的代码实现不是非常难，并且用到了前一篇用到的知识，这里仅再重述一遍思路： 通过当前驱动结构体找到内核模块结构体链表 遍历内核模块，找到Ntoskrnl.exe（PspTerminateProcess所在模块）模块结构体 获取模块基址、模块大小 确定特征码 从模块基址开始的地方，与特征码依次进行比对，从而找到未导出函数PspTerminateProcess 用一个函数指针指向未导出函数 调用函数PspTerminateProcess c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include \"ntifs.h\"typedef NTSTATUS NTKERNELAPI(*PspTerminateProcess)(PEPROCESS Process, NTSTATUS ExitStatus);VOID Driver_Unload(PDRIVER_OBJECT driver);UINT32 FindKernelModule(PDRIVER_OBJECT driver);PVOID FindAttrCode(PDRIVER_OBJECT driver);VOID TestFunc(PDRIVER_OBJECT driver);NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING RegistryPath) { DbgPrint(\"Driver is running!\\n\"); TestFunc(driver); driver->DriverUnload = Driver_Unload; return STATUS_SUCCESS;}VOID TestFunc(PDRIVER_OBJECT driver) { PspTerminateProcess pFun; PEPROCESS pEprocess; pFun = FindAttrCode(driver); if (pFun != NULL) { // DbgPrint(\"Get Success\\n\"); //PID的值根据具体进程而定 PsLookupProcessByProcessId((HANDLE)1752, &pEprocess); pFun(pEprocess, 1); DbgPrint(\"Close notepad success!\"); } else { DbgPrint(\"Get Failed\\n\"); }}PVOID FindAttrCode(PDRIVER_OBJECT driver) { UINT32 i = 0; UINT32 ds = FindKernelModule(driver); UINT32 ModuleBase = *(PUINT32)(ds + 0x18); UINT32 ModuleSize = *(PUINT32)(ds + 0x20); //+0xC UCHAR Offset[15] = { 0x8b, 0x75, 0x08, 0x3b, 0x70, 0x44, 0x75, 0x07, 0xb8, 0x0d, 0x00, 0x00, 0xc0, 0xeb, 0x5a }; PUCHAR pModuleMemory = NULL; __try { DbgPrint(\"Name: %wZ, Base: %x, Size: %x\\n\", (PUINT32)(ds + 0x2c), ModuleBase, ModuleSize); while (i < (ModuleSize - 0xf)) { pModuleMemory = (PUCHAR)(ModuleBase + i); if (RtlCompareMemory(Offset, pModuleMemory, 0xf) == 0xf) { // DbgPrint(\"%016x\", *pModuleMemory); return pModuleMemory - 0xc; } i++; } } __except (1) { } return NULL;}UINT32 FindKernelModule(PDRIVER_OBJECT driver) { UINT32 ds, dsCurrent, dsDest; UNICODE_STRING dllStr; RtlInitUnicodeString(&dllStr, L\"ntoskrnl.exe\"); // DbgPrint(\"_Driver_Object: %x\\n\", driver); // DbgPrint(\"_LDR_DATA_TABLE_ENTRY: %x\\n\", driver->DriverSection); ds = (UINT32)(driver->DriverSection); dsCurrent = ds; // DbgPrint(\"Name: %wZ, Base: %x, Size: %x\\n\", (PUINT32)(ds + 0x2c), *(PUINT32)(ds + 0x18), *(PUINT32)(ds + 0x20)); while (1) { ds = *(PUINT32)ds; if (ds == dsCurrent) { break; } if (RtlCompareUnicodeString(&dllStr, (PUINT32)(ds + 0x2c), TRUE) == 0) { // DbgPrint(\"Name: %wZ, Base: %x, Size: %x\\n\", (PUINT32)(ds + 0x2c), *(PUINT32)(ds + 0x18), *(PUINT32)(ds + 0x20)); break; } } dsDest = ds; return dsDest;}VOID Driver_Unload(PDRIVER_OBJECT driver) { DbgPrint(\"Unload Success!\");} 结果验证 本次实验，计划通过调用未导出函数PspTerminateProcess关掉指定进程（本次实验采用记事本） 在PC Hunter确定记事本的Pid 写入到代码中 生成.sys驱动文件，复制到虚拟机。通过Kmd Manager注册 运行该驱动，查看结果 发现成功的关掉了记事本这个进程 总结本次实验，通过在内存中搜索特征码，调用了一个未导出函数PspTerminateProcess，并关掉了记事本这个进程，当然我们是手动将Pid填入代码后才实现的指定进程，随着进一步学习，会逐渐改进并完善这份代码 参考文章：https://blog.csdn.net/jjjyu123/article/details/13616277 参考代码：上善若水，葫芦娃救爷爷，Joney，张嘉杰","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"内核空间&内核模块","slug":"内核空间和内核模块","date":"2020-04-10T01:02:27.000Z","updated":"2020-04-11T08:08:36.285Z","comments":true,"path":"2020/04/10/内核空间和内核模块/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/10/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","excerpt":"","text":"对编写基础的驱动有所了解后，我们来进一步了解一下内核，本篇会介绍两个概念，内核空间以及内核模块，先从内核空间说起。 内核空间内核空间的概念，我们还是比较熟悉的。这里我们主要关注一点，就是不同进程在低2G内存空间对应的物理页往往是不同的，而在高2G内存空间对应的物理页往往是相同的。如图： 这一要素，主要运用于跨进程读取内存等手法，之前的文章也提到过，这里我们来验证一下这个理论： 第一步，写一个驱动，获取全局变量的地址，程序比较简单，就不贴代码了，直接上图 第二步运行驱动，在DebugView中可以看到该全局变量的线性地址：0xbac93000 然后我们随机打开一个应用，这里以记事本为例。打开后，在Windbg中，找到记事本的Cr3查看该进程在线性地址0xbad53c78处的值为多少 可以发现，我们在记事本这个进程中查看0xbad53c78这个线性地址对应的物理页时，它所存着的值恰好是我们在另一个驱动中定义的全局变量的值。这正说明了，不同进程在高2G中对应的物理页是相同的。（这里解释一下 .process 这个指令的作用，0xaaaabbbb对应着某个进程的进程结构体的地址，.process aaaabbbb这个指令就相当于切换到这个进程，之后所访问的地址，都是这个进程地址空间中的地址） 内核模块基本概念有了内核空间的概念，这里介绍另一个概念，内核模块。看图 硬件种类繁多，不可能做出一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员按照规定的格式编写“驱动程序”。当然，并不是每个驱动程序一定需要关联一个硬件，也可以仅仅是一个程序，就如同我们之前所写的。 这些驱动程序，每一个都是一个模块，称为“内核模块”，都可以加载到内核中，也都遵守PE结构。本质上，任意一个.sys文件与内核文件（例如ntoskrnl.exe）没有区别。 有了上述概念后，我们可以打个比喻，内核空间（高2G），相当于一个进程；而各个加载到内核中的内核模块，就相当于加载到进程中的DLL；内核模块提供0环的函数实现以及硬件的程序驱动，DLL为这个进程提供额外功能。这样就好理解了。 DRIVER_OBJECT在之前编写的驱动程序中，入口函数总会传递一个参数，它的类型是PDRIVER_OBJECT，说明这是一个指向DRIVER_OBJECT的指针，而DRIVER_OBJECT正是驱动模块对应的结构体，来描述该驱动的相关信息。 由图，这里着重介绍四个比较关键的字段： DriverStart(+0x00C)：驱动模块在内核中的地址 DriverSize(+0x010)：驱动模块在内核中的大小 DriverName(+0x01C)：驱动模块在内核中的名字 DriverSection(+0x014)：这个位置存的是一个指针，指向一个_LDR_DATA_TABLE_ENTRY结构体 LDR_DATA_TABLE_ENTRY驱动在内核中也属于内核模块，该结构体描述了内核模块的相关信息，同时包含串着所有内核模块的双向链表，通过该链表，可以遍历所有内核模块。 InLoadOrderLinks(+0x000)：串着所有内核模块的双向链表 DllBase(+0x018)：当前内核模块的基址 SizeOfImage(+0x020)：当前内核模块的大小 FullDllName(+0x024)：当前内核模块的完整路径 BaseDllName(+0x02C)：当前内核模块的模块名 内核模块遍历有了上面这些基础后呢，就可以自己实现内核模块遍历的功能了。这里先说一下思路： 首先我们写一个驱动，驱动函数的入口会传一个PDRIVER_OBJECT这个参数，我们就可以利用这个参数，获取到自身驱动的DRIVER_OBJECT 有了DRIVER_OBJECT结构体后，就可以通过其偏移0x014位置处的值，找到LDR_DATA_TABLE_ENTRY结构体，该结构体的第一个元素，就是串着所有内核模块的双向链表 写一个循环，遍历这个双向链表，打印出相应的信息 下面附上代码： c12345678910111213141516171819202122232425262728293031323334353637#include \"ntddk.h\"VOID Driver_Unload(PDRIVER_OBJECT driver);VOID EnumKernelModule(PDRIVER_OBJECT driver);NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING RegistryPath) { DbgPrint(\"Driver is running!\\n\"); EnumKernelModule(driver); driver->DriverUnload = Driver_Unload; return STATUS_SUCCESS;}VOID EnumKernelModule(PDRIVER_OBJECT driver) { UINT32 ds, dsCurrent; DbgPrint(\"_Driver_Object: %x\\n\", driver); DbgPrint(\"_LDR_DATA_TABLE_ENTRY: %x\\n\", driver->DriverSection); ds = (UINT32)(driver->DriverSection); dsCurrent = ds; DbgPrint(\"Name: %wZ, Base: %x, Size: %x\\n\", (PUINT32)(ds + 0x2c), *(PUINT32)(ds + 0x18), *(PUINT32)(ds + 0x20)); while (1) { ds = *(PUINT32)ds; if (ds == dsCurrent) { break; } DbgPrint(\"Name: %wZ, Base: %x, Size: %x\\n\", (PUINT32)(ds + 0x2c), *(PUINT32)(ds + 0x18), *(PUINT32)(ds + 0x20)); }}VOID Driver_Unload(PDRIVER_OBJECT driver) { DbgPrint(\"Unload Success!\");} 观察实验结果： 这里主要打印了模块名，基址以及大小。观察结构可以发现，内核模块中不仅包含驱动文件，还有一些系统的dll，exe。因为它们本质上都是PE结构，所以不论是驱动文件还是内核文件，在内核空间中，都是一种内核模块。 关系梳理之前，在学习完KPCR后，对进程结构体，线程结构体，KPCR进行了简单的关系梳理，不过需要指出一点，在后面分析线程切换函数SwapContext时也指出了，线程寻找进程，主要用的是KTHREAD+0x44偏移处的Process，而不是用ETHREAD+0x220的偏移处的EPROCESS，不过呢，通常情况下，这两个地方都可以用。 现在又学习完了驱动、内核相关的结构体，来看看它们之间的关系如何： 已知驱动遍历内核模块：PDRIVER_OBJECT -> DRIVER_OBJECT -> DriverSection -> _LDR_DATA_TABLE_ENTRY -> InLoadOrderLinks 遍历驱动结构体：PDRIVER_OBJECT -> DRIVER_OBJECT -> DriverSection -> _LDR_DATA_TABLE_ENTRY -> InLoadOrderLinks -> DllBase（模块名.sys） 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=60 参考文章：https://blog.csdn.net/qq_41988448/article/details/103514007 参考笔记：张嘉杰的笔记 参考代码：葫芦娃救爷爷，Joney，张嘉杰","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"内核编程基础","slug":"内核编程基础","date":"2020-04-09T09:10:07.576Z","updated":"2020-04-10T17:33:31.729Z","comments":true,"path":"2020/04/09/内核编程基础/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/09/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"前面两篇文章分别介绍了驱动的编写以及调试驱动的方式，这一篇就对一些基础的概念以及注意事项做一个概括 内核API的使用 在应用层编程我们可以使用Windows提供的各种API函数，只要导入头文件就可以了，但是在内核编程的时候，我们不能像在Ring3那样直接使用。微软为内核程序提供了专用的API，只要在程序中包含相应的头文件就可以使用了，例如： c1#include \"ntddk.h\" //假定你已经正确安装了WDK 在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，主要借助于官方文档 未导出函数的使用官方说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。获取未导出函数地址的方法有如下两种： 特征码搜索 解析内核PDB文件 基本数据类型 在内核编程的时候，尽量遵守WDK的编码习惯，不要这样写： c1unsigned long length; 尽量使用WDK自己的类型： c1234ULONG(unsigned long) PULONG(unsigned long *)UCHAR(unsigned char) PUCHAR(unsigned char *)UINT32(unsigned int) PUNIT32(unsigned int *) VOID(void) PVOID(void *) 返回值大部分内核函数的返回值都是NTSTATUS类型，如： c123NTSTATUS PsCreateSystemThread();NTSTATUS ZwOpenProcess();NTSTATUS ZwOpenEvent(); 这个类型的值用来说明函数执行的结果，例如： c123STATUS_SUCCESS 0x00000000 //成功STATUS_INVALID_PARAMETER 0xC000000D //参数无效STATUS_BUFFER_OVERFLOW 0x80000005 //缓冲区长度不够 当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以参考ntstatus.h文件 内核中的异常处理在内核中，一个小小的错误就可能导致蓝屏，例如读写一个无效的内存地址。为了让自己的内核程序更加健壮，在编写内核程序时，使用异常处理是非常有必要的。 Windows提供了结构化异常处理(SEH)机制，大部分编译器都有支持，大致如下： c123456__try { //可能出错的代码}__except(filter_value){ //出错时要执行的代码} 出现异常时，可根据filter_value的值来决定程序该如何执行，filter_value的值主要如下： c123EXCEPTION_EXECUTE_HANDLER 1 //代码进入except块EXCEPTION_CONTINUE_SEARCH 0 //不处理异常，由上一层调用函数处理EXCEPTION_CONTINUE_EXECUTION -1 //回去继续执行错误处的代码 常用的内核内存函数简要介绍一些对内存进行使用的功能函数：申请、设置、拷贝以及释放 C语言 内核中 malloc ExAllocatePool memset RtlFillMemory memcpy RtlMoveMemory free ExFreePool 以ExAllocatePool为例，对应的语法为： c1234PVOID ExAllocatePool( POOL_TYPE PoolType, SIZE_T NumberOfBytes); 其中POOL_TYPE的类型主要有 c12345678910111213141516171819202122232425typedef enum _POOL_TYPE { NonPagedPool, //这块内存不可以放到文件中，用于存放代码 NonPagedPoolExecute, PagedPool, //这块内存不常用时可以放到文件中(硬盘)，用于存放数据 NonPagedPoolMustSucceed, DontUseThisType, NonPagedPoolCacheAligned, PagedPoolCacheAligned, NonPagedPoolCacheAlignedMustS, MaxPoolType, NonPagedPoolBase, NonPagedPoolBaseMustSucceed, NonPagedPoolBaseCacheAligned, NonPagedPoolBaseCacheAlignedMustS, NonPagedPoolSession, PagedPoolSession, NonPagedPoolMustSucceedSession, DontUseThisTypeSession, NonPagedPoolCacheAlignedSession, PagedPoolCacheAlignedSession, NonPagedPoolCacheAlignedMustSSession, NonPagedPoolNx, NonPagedPoolNxCacheAligned, NonPagedPoolSessionNx} POOL_TYPE; 内核字符串字符串种类内核中的字符串主要有4种： CHAR(char) WCHAR(wchar_t) ANSI_STRING c12345typedef struct _STRING { USHORT Length; USHORT MaximumLength; PCHAR Buffer;}STRING; UNICODE_STRING c12345typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer;}UNICODE_STRING; 使用ANSI_STRING和UNICODE_STRING的好处是其结构包含最大长度，可以有效防止字符串越界崩溃的情况 字符串常用函数字符串常用的功能无非就是：创建、复制、比较以及转换等等 ANSI_STRING字符串 UNICODE_STRING字符串 RtlInitAnsiString RtlInitUnicodeString RtlCopyString RtlCopyUnicodeString RtlCompareString RtlCompareUnicoodeString RtlAnsiStringToUnicodeString RtlUnicodeStringToAnsiString 一般在驱动中会通过DbgPrint函数格式化输出到DbgView上，上述字符串有如下对应关系： c1234\"%s\"---ANSI_STRING.Buffer\"%S\"---UNICODE_STRING.Buffer\"%Z\"---&ANSI_STRING\"wZ\"---&UNICODE_STRING 打印GDT，IDT在简要了解了内存函数和字符串函数后，来做两个实验巩固一下知识吧 第一个实验：申请一块内存，并在内存中存储GDT、IDT的所有数据，然后在DebugView中显示出来，最后释放内存 代码实现原来比较简单，主要是熟悉函数的使用，这里就不详细分析了，直接上代码 c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include \"ntddk.h\"VOID Driver_Unload(PDRIVER_OBJECT driver) { DbgPrint(\"Unload Success!\");}NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING RegistryPath) { USHORT gdtl, idtl; UINT32 idtr, gdtr; UCHAR gdt[6], idt[6]; PULONG pGDT, pIDT; _asm { sgdt gdt sidt idt } gdtl = *(PUSHORT)&gdt[0]; idtl = *(PUSHORT)&idt[0]; gdtr = *(PUINT32)&gdt[2]; idtr = *(PUINT32)&idt[2];// DbgPrint(\"%2x, %2x, %8x, %8x\\n\", gdtl, idtl, gdtr, idtr); gdtl++; idtl++; pGDT = ExAllocatePool(PagedPool, gdtl); pIDT = ExAllocatePool(PagedPool, idtl); if (pGDT == NULL || pIDT == NULL) { DbgPrint(\"Allocate Failed!\"); return STATUS_UNSUCCESSFUL; } RtlFillMemory(pGDT, gdtl, 0); RtlFillMemory(pIDT, idtl, 0); RtlMoveMemory(pGDT, (PUINT32)gdtr, gdtl); RtlMoveMemory(pIDT, (PUINT32)idtr, idtl); for (int i = 0; i < (gdtl/0x4); i += 0x4) { DbgPrint(\"%08x: %08x`%08x\\t%08x`%08x\\n\", gdtr+i, *(pGDT + i + 1), *(pGDT + i), *(pGDT + i + 3), *(pGDT + i + 2)); } for (int i = 0; i < (idtl/0x4); i += 0x4) { DbgPrint(\"%08x: %08x`%08x\\t%08x`%08x\\n\", idtr+i, *(pIDT + i + 1), *(pIDT + i), *(pIDT + i + 3), *(pIDT + i + 2)); } ExFreePool(pGDT); ExFreePool(pIDT); driver->DriverUnload = Driver_Unload; return STATUS_SUCCESS;} 测试结果 截取GDT部分内容 ： 截取IDT部分内容： Windbg中打印部分内容验证结果是否正确： 字符串操纵第二个实验，应用刚刚学习的字符串函数，操纵字符串实现如下功能： 初始化一个字符串 拷贝一个字符串 比较两个字符串是否相等 进行ANSI_STRING与UNICODE_STRING的转化 代码实现c12345678910111213141516171819202122232425262728293031323334353637383940414243#include VOID Driver_Unload(PDRIVER_OBJECT driver);VOID Manipulate();NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { DbgPrint(\"Load Driver\"); Manipulate(); DriverObject->DriverUnload = Driver_Unload; return STATUS_SUCCESS;}VOID Manipulate() { ANSI_STRING aStr, bStr = {0}, cStr, dStr; UNICODE_STRING uStr; ULONG ul; //Initialize RtlInitAnsiString(&aStr, \"TestANSI\"); RtlInitAnsiString(&cStr, \"TestCOMPARE\"); RtlInitUnicodeString(&uStr, \"TestUnicode\"); DbgPrint(\"%x, %x, %s\", aStr.Length, aStr.MaximumLength, aStr.Buffer); DbgPrint(\"%x, %x, %s\", cStr.Length, cStr.MaximumLength, cStr.Buffer); DbgPrint(\"%x, %x, %s\", uStr.Length, uStr.MaximumLength, uStr.Buffer); //Copy RtlCopyString(&bStr, &aStr); DbgPrint(\"%x, %x, %s\", bStr.Length, bStr.MaximumLength, bStr.Buffer); //Compare ul = RtlCompareString(&aStr, &cStr, 1); DbgPrint(\"%d\", ul); //Transfer RtlUnicodeStringToAnsiString(&dStr, &uStr, TRUE); DbgPrint(\"%x, %x, %s\", dStr.Length, dStr.MaximumLength, dStr.Buffer);}VOID Driver_Unload(PDRIVER_OBJECT driver) { DbgPrint(\"Unload Success!\");} 测试结果 由结果可以看出，代码测试存在问题，请教了Joney，他猜测其原因在于，可能由于编译器的优化，定义的字符串结构体仅仅是引用了字符串常量（在常量区，无法写），并没有真正获取它，因而在进行拷贝操作时，无法获取另一个字符串结构体的内容。猜想没有去验证，因为我太懒了，字符串这东西，真的是麻烦，以后用到的话，会在研究一下的……. 参考教程：https://www.bilibili.com/video/av68700135?p=59 参考笔记：张嘉杰的笔记 参考代码：Joney的代码，葫芦娃救爷爷的代码","categories":[],"tags":[]},{"title":"驱动调试","slug":"驱动调试","date":"2020-04-08T01:47:11.000Z","updated":"2020-04-08T07:05:16.222Z","comments":true,"path":"2020/04/08/驱动调试/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/08/%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95/","excerpt":"","text":"之前介绍了如何编写一个简单的驱动程序，相比exe程序，可以直接拖进OD内调试，驱动文件必须依赖操作系统才能执行。所以需要依靠Windbg进行双机调试来实现（配置双机调试可以参考这里）。具体如何调试驱动，下面一起来看看吧 PDB文件在学习驱动调试之前，先要了解PDB文件。PDB文件（Program DateBase File）有什么用呢？我们来看个例子： 在Windbg中，通过u（unassemble）指令可以看到指定地址的汇编；当我们给定一个特定的地址时，它往往可以识别出这个函数，亦或是给定一个函数名，它可以直接定位到特定的地址 这到底是如何做到的呢？ 我们先看定义，PDB文件是一类用于存储程序调试信息的属性文件。它会伴随着源文件编译时创建出来。 结合上图和定义可以发现，无论是exe，dll还是sys文件，都有对应的pdb文件，且pdb文件体积很大，这是因为pdb包含了大量调试用的信息，这也是为什么Windbg能够快速识别各类0环函数信息，因为它加载了Windows符号表。Windows符号表是一组包含了内核函数调试信息的pdb文件。 加载符号表加载符号表的步骤非常简单，之前进行过双击调试的小伙伴应该已经自行加载过了，这里再演示一遍： 进入Windbg界面，File -> SymbolFilePath 进入后，可以看到，这是我导入的Windows符号表，里面包含了内核函数的pdb文件 由于Windows官方不再提供符号表，这里我使用的是Xp sp3的符号表，可以作为参考(提取码：3akx ) 实际情况最好选择与操作系统版本相适应的符号表 导入符号表后，在Windbg中键入.reload指令完成符号信息加载 驱动调试示例有了前面的基础，我们来尝试一下如何调试一个驱动程序吧 首先，写一个驱动程序，加入用于测试的代码 Code12345678910111213141516171819202122#include \"ntddk.h\"VOID DriverUnload(PDRIVER_OBJECT driver){ DbgPrint(\"驱动程序已停止.\\r\\n\");}NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath){ //中断到调试器 _asm { int 3 mov eax, eax mov eax, eax mov ecx, ecx } DbgPrint(\"驱动程序已运行.\\r\\n\"); DriverObject->DriverUnload = DriverUnload; return STATUS_SUCCESS;} 这里面嵌入了一段汇编，这样可以在程序执行时中断到调试器 然后，我们将该驱动程序的pdb文件路径拷贝到Windbg的SymbolFilePath中 这样Windbg就加载了我们驱动程序的符号文件了 有了符号文件，就可以用Windbg调试驱动了： 将驱动程序复制到调试机器，运行后发现会操作系统卡死 进入Windbg发现程序中断到了int 3指令的位置，并在左边显示了咱们编写的驱动程序 执行t指令可以进行单步调试 调试完后可键入g指令继续执行程序 这样，一次简单的驱动调试就完成啦 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=58 参考文章： https://blog.csdn.net/qq_41988448/article/details/103497372 https://blog.csdn.net/q1007729991/article/details/52710390","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"第一个驱动程序","slug":"第一个驱动程序","date":"2020-04-07T07:15:54.000Z","updated":"2020-04-07T08:49:05.568Z","comments":true,"path":"2020/04/07/第一个驱动程序/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"在完成了进程和线程的学习后，我们发现，很多实验都受限于权限的限制，很难直接操纵0环的结构，然而，依靠中断门等提权方式进入0环，需要手动在Windbg中设置段描述符，就会变得很麻烦。而驱动恰恰可以解决这个问题，驱动可以直接和操作系统打交道，话不多说，开始驱动的学习吧。 环境配置搭建环境及工具 Visual Studio 2017：下载地址 WDK（Windows Driver Kit）:下载地址 DbgView：下载地址 KmdManager 先安装Visual Studio 2017在本机，再安装WDK到本机。DbgView和KmdManager则安装至虚拟机上。因为驱动若发生错误，则会导致系统崩溃，因而选择在虚拟机上进行实验。 项目创建 安装完VS2017后，要安装SDK，且版本要与WDK的版本一致，如图我的SDK版本是17763 那么安装的WDK版本，也得是17763 校验好版本后，来创建驱动程序，新建项目 -> Visual C++ -> 测试 -> Legacy -> Empty WDM Driver 有人可能会问了，为什么要创建WDM的驱动程序，而不创建WDF的驱动程序呢？因为如果创建了WDF的驱动程序，在xp上执行会发生系统找不到指定文件的错误 具体原因也不是很清楚，至于这俩的区别可以参考WDM和WDF之间的差异 接着点击确定，即可创建驱动程序项目了，但是需要注意一点，就是第一步中，SDK和WDK的版本必须要一致，否则会出现一个奇怪的错误 如果版本相同，就不会出现这样的错误啦 项目属性配置 右键项目，进入属性页，来配置一下项目的属性 接下来按照图中框中地方进行矫正即可 配置完即可创建文件了 编写第一个驱动程序创建过程 依然是按部就班的来，右键SourceFiles创建源文件 这里后缀名要用的c的，因为如果编写c++程序的驱动的话，编译器会做过多的优化，因而无法做到指令级别的掌控 修改文件编译属性，由于刚刚没有创建源文件，所以在项目属性配置时，并不能配置完全部属性，这里需要再配置一下 编写驱动代码，具体如下 c12345678910111213141516#include \"ntddk.h\"//卸载函数VOID DriverUnload(PDRIVER_OBJECT driver){ DbgPrint(\"驱动程序已停止.\\r\\n\");}//驱动程序入口函数，相当于控制台的main函数NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath){ DbgPrint(\"驱动程序已运行.\\r\\n\"); //设置一个卸载函数 便于退出 DriverObject->DriverUnload = DriverUnload; return STATUS_SUCCESS;} 选择生成HelloDriver 结果验证 将HelloDriver/Debug目录下的HelloDriver.sys复制进虚拟机Windows Xp中 打开DbgView，勾选Capture Kernel选项，用于捕获内核调试信息 打开KmdManager，导入HelloDriver.sys，注册并运行，验证结果。 总结总体不难，但是第一次搞驱动，踩了不少坑，最终还是花了一个上午的时间才弄好。真的非常感谢Joney老大解答问题，这让我少花了很多时间，不然我可能搞到晚上都弄不出来。。。 参考文章： https://blog.csdn.net/qq_41988448/article/details/103456086 https://blog.csdn.net/liny000/article/details/81260385 https://docs.microsoft.com/zh-cn/windows-hardware/drivers/wdf/differences-between-wdm-and-kmdf","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"跨进程读写内存","slug":"跨进程读写内存","date":"2020-04-05T17:15:42.000Z","updated":"2020-04-07T13:18:56.576Z","comments":true,"path":"2020/04/06/跨进程读写内存/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/06/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/","excerpt":"","text":"要点回顾跨进程的本质是“进程挂靠”，正常情况下，A进程的线程只能访问A进程的地址空间，如果A进程的线程想访问B进程的地址空间，就要修改当前的Cr3的值为B进程的页目录表基址（KPROCESS.DirectoryTableBase） 即： Code1mov cr3, B.DirectoryTableBase 跨进程操作A进程中的线程代码如下： Code1234mov cr3,B.DirectoryTableBase //切换Cr3的值为B进程mov eax,dword ptr ds:[0x12345678] //将进程B 0x12345678的值存的eax中mov dword ptr ds:[0x00401234],eax //将数据存储到0x00401234中mov cr3,A.DirectoryTableBase //切换回Cr3的值 这是一个模拟跨进程读写内存的操作，但是代码实际上是存在问题的。代码中，将数据写入到0x00401234这个地址里，但这个地址是位于B进程地址空间的，因此A进程中是无法读出来这个值的。那该如何读写另一个进程的内存呢？ 之前，在学习保护模式内容的时候，发现不同进程低2G对应的物理页往往是不同的，但是高2G对应的物理页往往是相同的。可以利用这一点，可以先将数据暂存到高2G的内存，然后切换到另一个进程中，进入读写操作。具体我们来参考一下NtReadVirtualMemory的实现理念。 NtReadVirtualMemory流程 NtWriteVirtualMemory流程 通过分析这两个函数实现跨进程读写的原理可以发现，都是利用了进程高2G地址对应的物理页相同这个特性，先将数据暂存到高2G的位置，然后切换进程，再在另一个进程是进行读取操作。 总结这篇比较简短，进程和线程的也算是收尾了。当然，的确也没有太多内容，算是水了一篇吧，至于手动实现跨进程的实验，就搁置了，再次复习时，或许会在后续单独写一篇来更新吧。 写这篇的时候，已经是4月6号晚上了，自3月5号开始更新博客以来，过去整整一个月了。有时候还是会很怠慢，部分没有更新完拖到第二天的情况也很常见，好在，还是坚持了下来。进入Q2了，这对我来说非常关键，按照计划，也应该在6月21日之前更新完内核相关的内容，当然，实际进度或许更快一些，但我却有些着急了，这是不该的，稳扎稳打，才是最稳妥的。第一个月下来，对自己的打分勉强及格吧。但这算是开始，相比之前的颓废，情况有些好转了，Q2是至关重要的，等4月下旬，按照顺序更新完APC，我可能会开始更新一些Android安全或者Web安全自己学习过的内容，作为复习的同时，也算是强化自身的技能池吧，虽然很早就说了更Android，但是正向方面一直不是很了解，加上平时更新内核也比较慢，也就鸽了。对我来说，4月6号，是比较重要的第一天吧，2017年那天的凌晨，因为失眠，发了脾气。2017.4.5~4.15这段在滨海新区前端学习的时光，我依旧记得，虽然有一些不快，但是却印象深刻，我忘不了某一天晚上结束后在等大巴车时吹的海风，虽然距离海边还有很远的距离，而且还冷飕飕的，比在厦门晚上吹的海风还冷一些，但是能给人这种感觉的，也只有海边吹来的风了。我忘不了那段时间早起，晚归，过了0点才入睡，专注于学习的时光，后来我在想，这可能是我大学最努力的时光了吧，现在毕业了一年了，发现，的确是的。虽然没有初三那段时间那么拼命，但是，真的疲惫了，真的投入了，真的尽力了。对我来说，那是段还不错的记忆，尽管过去了这么久。有句话说，中年人（虽然我才23）别总回忆过去，才不会令人讨厌。可是没办法，这的确是特殊的一天，2017.4.6的早上，一整夜一分钟都没睡着的我，拖着疲惫的身躯，上了去公司的大巴车，在车上，我循环着Maroon5的Cold，睡了一小会，今天，我又循环了很多遍这首歌，循着承载着记忆的歌。回忆了这么多，难免人会有些失落，是啊，下一次吹海风会是什么时候呢。失落不总是差的，但也不能总是失落，人总得找到轻松的方法获得快乐才行。难得，矫情了一下，博客，还是要继续更新的，现在的我比以前更现实了，实力才是生活的保证，坚持学习，不断提升自身的技能池吧","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"进程挂靠","slug":"进程挂靠","date":"2020-04-05T00:46:28.000Z","updated":"2020-04-06T14:32:21.935Z","comments":true,"path":"2020/04/05/进程挂靠/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/05/%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0/","excerpt":"","text":"在学习进程挂靠之前，先回顾一下进程与线程相关的知识 进程与线程的关系基本关系 一个进程可以包含多个线程 一个进程至少要有一个线程 进程为线程提供资源，也就是提供Cr3的值，Cr3中存储的是页目录表基址，Cr3确定了，线程能访问的内存也就确定了。 代码分析来看这样一行代码： Code1mov eax,dword ptr ds:[0x12345678] CPU如何解析0x12345678这个地址呢？ CPU解析线性地址时，需要通过页目录表（PDT）来找到对应的物理页，页目录表基址存在Cr3寄存器中，这些都是保护模式的内容，已经很熟悉了 当前的Cr3的值来源于当前的进程（_KPROCESS.DirectoryTableBase(+0x018)） 线程找进程线程找进程有两种情况： KHTREAD.ApcState.Process(+0x44) ETHREAD.ThreadProcess(+0x220) 所以，从KTHREAD以及ETHREAD均能找到当前线程的进程，这里引用海哥的叫法，把KTHREAD找到的Process(+0x44)叫做养父母，把ETHREAD找到的ThreadProcess(+0x220)叫做亲生父母 养父母负责提供Cr3线程切换的时候，会比较KTHREAD结构体0x044处指定的EPROCESS是否为同一个，如果不是同一个，会将0x044处指定的EPROCESS的DirectoryTableBase的值取出，赋值给Cr3。这部分在分析SwapContext的Part3部分提到过，这里不多赘述。可以跳转或者参考下图的紫色部分 所以，线程所需要的Cr3的值，来源于0x044偏移处指定的EPROCESS，所以得出如下结论： 0x220：亲生父母，这个线程谁创建的 0x044：养父母，谁在为这个线程提供资源（也就提供Cr3）。一般情况下，0x220与0x044指向的是同一个进程 进程挂靠有了上述概念后，我们知道了，正常情况下，Cr3的值是由养父母提供的，但是Cr3的值也可以改成和当前线程毫不相干的其它进程的DirectoryTableBase。 观察下面的代码： Code123456mov cr3,A.DirectoryTableBasemov eax,dword ptr ds:[0x12345678] //A进程的0x12345678内存mov cr3,B.DirectoryTableBasemov eax,dword ptr ds:[0x12345678] //B进程的0x12345678内存mov cr3,C.DirectoryTableBasemov eax,dword ptr ds:[0x12345678] //C进程的0x12345678内存 将当前Cr3的值改为其它进程，称为“进程挂靠”。 进程挂靠存在的意义是什么呢，上面的代码，分别将不同进程的DirectoryTableBase的值写入Cr3。这时，每次读入的0x12345678这个线性地址上的值，分别是对应进程上0x12345678线性地址所对应物理页的内容。有了进程挂靠，就意味着可以读取其它进程的内存。 分析NtReadVirtualMemory我们知道，ReadProcessMemory这个三环API是可以读取其它进程的内存的，该函数在0环的实现是NtReadVirtualMemory，来分析一下这个函数，看看它是如何读取其它进程内存的： 首先，进入NtReadVirtualMemory，由于这个函数非常复杂，就直接挑重点来说了 这里调用了一个_MmCopyVirtualMemory函数，看名字就感觉，这个和别的进程的内存可能有点关系，毕竟是Copy来的…. 进入_MmCopyVirtualMemory继续查看 这个函数不大，有一个函数很关键MiDoPoolCopy，这个函数Push了一大堆参数，内部应该实现了重要的功能，继续更近 跟进_MiDoPoolCopy函数 往下翻，有一个KeStackAttachProcess，由名字可知，这个函数和进程挂靠有关 再进一步，进入_KeStackAttachProcess函数 看到这里，就是真正的挂靠函数，进入分析看看Windows到底是如何实现进程挂靠的 直接看图 这里面进行了两个主要的操作： 1）修改养父母，即KTHREAD.ApcState.Process的值，修改为将要访问的进程的进程结构体 2）调用进程切换函数KiSwapProcess（本质是切换Cr3） 进入KiSwapProcess看看这个函数具体做了什么 来看最关键的部分，KiSwapProcess函数，先从外部参数，获取到了将要访问的进程的Cr3，然后分别修改TSS.Cr3和KPROCESS+0x18（DirectoryTableBase）处的值，然后便完成了进程切换。可以发现，进程切换，实际上就是切换了Cr3 小结简要分析完了NtReadVirtualMemory函数后可以发现，这个函数主要做了两件事，第一件事，修改线程养父母，第二件事，修改进程Cr3。随后就可以访问和读取另一个进程的内存了。 那么小盆友要问了，可不可以只修改Cr3，而不修改养父母呢？当然是不可以的，如果不修改养父母的值，一旦发生线程切换，再切回来的时候，读取的内存，是由养父母提供的Cr3，而养父母没有修改，因此读取的还是自己线程所在的进程，即变成了自己读自己了。 总结正常情况下，当前线程使用的Cr3是由其所属进程提供的（KTHREAD+0x44偏移处指定的EPROCESS），正是因为如此，A进程中的线程只能访问A的内存。 如果要让A进程中的线程能够访问B进程的内存，就必须要修改Cr3的值为B进程的页目录表基址（B.DirectoryTableBase），这就是所谓的“进程挂靠” 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=54 参考文章： https://blog.csdn.net/weixin_42052102/article/details/83268680 https://blog.csdn.net/qq_38474570/article/details/104286261 https://blog.csdn.net/qq_41988448/article/details/103435464","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"线程优先级","slug":"线程优先级","date":"2020-04-04T14:04:35.000Z","updated":"2020-04-06T08:12:02.884Z","comments":true,"path":"2020/04/04/线程优先级/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/04/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"前面分析过了SwapContext函数，用来线程切换的；线程切换需要2个线程，一个是当前线程，一个是用来切换的目标线程，我们知道当前线程可以通过KPCR+0x124位置的CurrentThread获得，那么目标线程该如何获得呢？下面一块来研究一下 线程切换的方式先回顾一下线程切换三种方式的过程： 当前线程主动调用API： API函数 -> KiSwapThread -> KiSwapContext -> SwapContext 当前线程时间片到期： KiDipatchInterrupt -> KiQuantumEnd -> SwapContext KPCR中存有备用线程： KiDispatchInterrupt -> SwapContext 在有备用线程的条件下，SwapContext的目标线程参数可以通过(KPCR.PrcbData.NextThread)直接取出。那么另外两种方式，是如何找到下一个要切换的线程呢？ 先看主动调用API的方式，进入IDA分析一下KiSwapContext函数执行之前的流程 由图，我们可以看出，KiSwapThread函数内，会先执行KiFindReadyThread取出目标线程，之后再执行KiSwapContext函数的 再看时间片到期的方式，我们进入KiQuantumEnd进行分析 发现，KiQuantumEnd内部，也会先执行KiFindReadyThread函数，返回一个线程结构体 通过分析可以得知，线程切换的目标线程，与KiFindReadyThread有关，接下来就结合KiFindReadyThread函数来分析一下如何获取目标线程。 线程查找在分析查找线程之前，我们先来回顾一下之前学习的调度链表的知识 调度链表共32个，如果说一个线程，它满足运行条件了，就会被扔到这个链表里面(根据优先级)，也就是说，线程切换的时候，就是从这个调度链表里面找一个线程出来，而KiFindReadyThread函数就是干这事的。 KiFindReadyThread查找方式这个函数的查找方式非常简单暴力，会按照优先级别进行查找：31..30..29..28 换句话说，在本次查找中，如果级别31的链表里面有线程，那么就不会查找级别为30的链表，直接从级别31的链表里取一个出来 如何高效查找调度链表有32个，如果每次都从开始查找效率就太低了，因此Windows通过一个DWORD类型的变量来记录： 当向调度链表（32个）中挂入或者摘除某个线程时，会判断当前级别的链表是否为空，会判断当前级别的链表是否为空，为空则将DWORD变量（_KiReadySummary）对应位置0，否则置1。大致如下图： 多CPU下会随机寻找KiDispatcherReadyListHead指向的数组中的线程。线程可以绑定某个CPU（使用API：setThreadAffinityMask） 如果没有就绪线程怎么办这里我们先了解一下如何看调度链表 大致分三种情况： 双向链表的值一样，且等于当前地址，说明该链表是空的 双向链表的值一样，但是不等于当前地址，说明该链表只有一个线程 双向链表的值不一样，说明链表中存在2个或者2个以上个线程 那么，如果32个调度链表都是空的怎么办？ 我们来进入IDA看一下执行流程： 查看KiFindReadyThread执行后的代码 若eax值为空（即没有取到线程）那么会跳转到loc_8000EA85的位置执行 来看看loc_8000EA85处做了什么 实际上只做了一件事，就是给eax赋值，因为KiFindReadyThread函数没有找到就绪线程，因此eax值是空的，这里给eax赋的值，就是KPCR.PrcbData.IdleThread。也就是KPCR中存着的空闲线程 这下我们弄明白了，如果就绪链表中没有线程，那么发生线程切换时，会切换到一个Idle线程继续执行，从而保证CPU一直稳定的执行 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=53 参考文章： https://blog.csdn.net/qq_38474570/article/details/104286223 https://blog.csdn.net/qq_41988448/article/details/103435464 参考笔记：张嘉杰的笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"分析SwapContext","slug":"分析SwapContext","date":"2020-04-03T14:46:28.000Z","updated":"2020-04-05T17:13:26.639Z","comments":true,"path":"2020/04/03/分析SwapContext/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/03/%E5%88%86%E6%9E%90SwapContext/","excerpt":"","text":"SwapContext这个函数是Windows线程切换的核心，无论是主动切换还是系统时钟导致的线程切换，最终都会调用这个函数。在这个函数中，除了切换堆栈以外，还做了一些其它事情，了解这些细节对我们学习操作系统至关重要。 遗留问题在分析SwapContext函数之前，来回顾两个之前的文章中并没有交代的问题： 我们知道，在程序从3环进入0环时，会发生权限的切换，这就意味着堆栈发生了切换，也必然，线程发生了切换。之前学习过，3环进入0环，有两种方式，分别是中断门进0环以及快速调用。这里我们来简单的回顾一下： 通过中断门进0环时，会从TSS中获取到esp0的值。 快速调用进入0环时，则是从MSR寄存器中获取esp0的值，但是实际情况是，在分析快速调用进0环使用的KiFastCallEntry函数时，我们发现，快速调用进入0环时也是通过TSS来获取esp0的值的，所以MSR寄存器给的值，实际上只是作为中间过渡用 那么问题来了，TSS寄存器里面的这个esp0，到底是哪来的？如何保证每次切换线程后，TSS中的esp0对应的仍然是当前线程的esp0呢？分析SwapContext函数时便会找到答案。 另一个问题呢，是关于FS的；我们知道FS:[0]寄存器在3环时指向TEB，进入0环后FS:[0]指向KPCR；系统中同时存在很多个线程，那该如何保证FS:[0]在3环时一定是指向的当前正在运行的线程呢？同样，想知道这个答案，我们也需要通过分析SwapContext函数来解开。 SwapContextSwapContext函数比较长，就分为5个部分来进行分析，当然，这5个部分是连续的。另外，由于我已经在IDA中分析好了，这里就不贴上源码，直接通过图片来分析了。 Part1 来看看这部分做了些啥事，首先将目前线程(即将切换的线程)的线程状态置为2。这一部分有几个外部通过寄存器传进来的参数的含义，具体可以看图 第二步将Eflags入栈，在线程切换时，会有很多判断操作，势必会影响到标志寄存器的值，这里需要保存一下 接下来的4行，放在一起看。这里有两个操作： 1）将ExceptionList入栈，由于将发生线程切换，需要保存当前线程的异常链表。ebx指向的KPCR，所以[ebx]的值刚好是KPCR的第一个成员NtTib内的第一个成员，也就是ExceptionList 2）KPCR+0x994的位置是DPCRoutineActive，DPC是延迟过程调用，和APC相对，这里不再扩展，需要注意一点，这个会有个判断，如果DPCRoutineActive的值不为0，那就执行蓝屏程序 第四步，这个_PPerfGlobalGroupMask，仅仅在Windows Server2003中，5.2版本出现的一个字段，位于NtTib+0x08的位置，主要与日志，调式相关的。 到这就差不多了，接下来从mov ebp, cr0这条指令开始，开始第二部分的分析 Part2 来看第二部分，先让edx获取当前线程的Cr0寄存器的值。这里仅作暂存，具体后面会用到 KPCR中需要保存当前线程的相关信息，所以接下来，获取到目标线程的DebugActive写入到KPCR的DebugActive位上 这一步，比较好理解。毕竟一会要进行线程切换，总不能切换到一半去执行别的任务吧。因此就把中断屏蔽了 保存当前线程的esp到KernelStack字段中，这是我们熟知的经典线程切换操作的第一步。为什么没有紧接着进行第二步的操作呢？因为还有一些细节需要处理。接着往下看 第五步，主要做一些准备工作，这里能有两个操作，分别来看看 1）将目标线程的StackLimit保存到KPCR的StackLimit位置上 2）将目标线程的InitialStack处的值减去0x210后，赋到StackBase上。为什么要减去0x210呢？这里涉及到了内核堆栈的结构 每个线程的内核堆栈，栈底开始共有0x210个字节用于存储浮点寄存器相关的内容。因此KPCR中记录的栈基址需要减去0x210个字节 第六步，仍然是与浮点寄存器相关，在KTHREAD+0x031的位置，有一个字段叫做NpxState。这里主要是判断NpxState有没有浮点支持，以及上一个线程和当前线程对于浮点的支持是否相同，来决定是否需要重新修改Cr0寄存器的值。 下一部分，从loc_80004983开始 Part3 这部分内容较多，慢慢来看，第一步eax-0x10，结合Part2的分析可以知道，eax刚刚提升了0x210个字节，用于存储浮点寄存器相关内容，这里又提升0x10个字节的目的，同样可以根据上图可知，_Trap_Frame结构的开始部分，有0x10字节存储的内容是用于虚拟8086模式下的值，因此这里再次提升0x10字节的堆栈 第二步是最为关键的一步，这里实现了两个关键的操作： 1）将eax存的值赋值给TSS.esp0的位置，之前分析3环进0环时，有提到过，进入0环后的esp的位置，这里回顾一下： 而此时，eax所存的值，刚好位于快速调用进0环后esp所处的位置(InitialStack-0x210-0x10)。所以这个值，就是3环进0环后esp0的值，此处将这个值赋值给了TSS.esp0，自然也就解释了为什么TSS中存的esp0总是指向当前线程的0环堆栈，原因就是，每次堆栈切换发生时，SwapContext函数内，都会将切换后，线程堆栈栈顶存储到TSS.esp0的位置 2）第二个操作，哎，是我们非常熟悉的线程切换的经典步骤第二步，切换堆栈。这里就不多解释了，总之，至此，堆栈切换完成了，但是还是有一些善后工作需要处理。相比海哥的ThreadSwitch模拟切换函数来说，SwapContext还是略微复杂些的。 第三步，很容易看懂，设置KPCR.NtTib.Self指向Teb。这步有啥用呢？到Part4就能明白啦 第四步，就做了一个事，判断线程切换前后的2个线程，是不是属于同一个进程，方法也很简单，分别取两个线程KTHREAD+0x44位置指向的值（这里要注意下，在KTHREAD+0x34的偏移处，有一个ApcState结构体，其中+0x10位置存着指向当前线程所属进程的指针） 然后比较一下，若值不相同的话，那就将新的线程所属进程结构体的指针保存到edi中 第五步，紧接着第四步继续，如果俩线程的所属进程不同，就会走到这一步。这一步也有两个操作： 1）因为进程切换了，因此Cr3的值也要跟着变，因此这里从新的进程中获取Cr3，并保存到TSS中 2）同理，另一个需要更新的值，IO位图，也就是TSS最后一个元素，当然，这个值不重要，详情见图 下一部分，从loc_800049D7开始 Part4 这一部分，也就做一些收尾工作了，毕竟线程切换已经完了嘛。这里的第一步，最为关键。Part3的第三步，让KPCR.NtTib.Self指向了Teb。这里就用上了。我们有了这个Teb的地址后，就通过移位，将这个地址分3个部分(根据段描述符的结构)，写入到GDT表中，下标为7的这个段描述符中。这个段描述符对应的段选择子是0x3B，也就是3环FS寄存器存着的段选择子。这就解释了文章开头提到的第二个问题，为什么3环FS:[0]指向的一定是当前线程的Teb，原因就在这里，因为每次线程切换时，都会给3环FS:[0]对应的段描述符赋上当前线程Teb的地址 第二步，主要做了一些统计相关的操作，例如，CPU发生了多少次线程切换，以及这个线程被切换了多少次 第三步，主要做了一些恢复现场的工作，具体看图中注释。 总结至此，SwapContext函数已分析完毕，我们进一步了解了线程切换的细节，以及线程切换时，对TSS，FS的影响 参考教程： https://www.bilibili.com/video/BV1NJ411M7aE?p=51 https://www.bilibili.com/video/BV1NJ411M7aE?p=52 参考文章：https://blog.csdn.net/weixin_42052102/article/details/83217867 参考笔记：张嘉杰的笔记，Joney的笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"时间片管理与备用线程","slug":"时间片管理","date":"2020-04-02T08:11:54.000Z","updated":"2020-04-03T02:04:01.151Z","comments":true,"path":"2020/04/02/时间片管理/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/02/%E6%97%B6%E9%97%B4%E7%89%87%E7%AE%A1%E7%90%86/","excerpt":"","text":"前一篇，我们主要分析了线程切换的几种情况，其中一种是时钟中断，但并不是说只要有时钟中断就一定会切换线程，时钟中断时，两种情况会导致线程切换： 当前线程的CPU时间片到期 存在备用线程（KPCR.PrcbData.NextThread处值不为空） CPU时间片ThreadQuantum当一个新的线程开始执行时，初始化程序会在KTHREAD.Quantum赋初始值，该值的大小由KPROCESS.ThreadQuantum决定 随机选择一个进程查看，发现ThreadQuantum的值为6。这个值，就是该进程的线程执行时的CPU时间片。那如何使用这个值呢？我们接下来继续看。 分析KeUpdateRunTime每次时钟中断发生时都会先调用KeUpdateRunTime函数，我们来看看这个函数干了什么事 结合两张图来看，ebx保存的是当前线程的KTHREAD，接着将当前线程的Quantum的值-3。这下就清晰一些了，前面说了，一个线程初始的Quantum值为6，这里将Quantum的值 减了3。然后还做了什么呢，根据上面的信息，可以得知eax保存的KPCR，下面有一个逻辑判断，如果减3后值不为0，这里程序就跳转了，但是如果为0，此时程序会给KPCR+0x9AC处（QuantumEnd）的值赋上一个不为0的值，这个操作有什么用呢？往后看就知道了。 分析KiDispatchInterrupt这里小盆友可能会奇怪了，为什么突然就从KeUpdateRunTime就跳到这了呢？这里需要说明一下，KeUpdateRumTime函数，是每次时钟中断发生时都会调用的函数，这个函数做了两件事： 将当前线程的KTHREAD.Quantum的值减3 若Quantum的值减到了0，则会将KPCR.QuantumEnd的值置为一个不为0的数 之后这个函数就执行完了，接着，就是我们上一篇分析过的，时钟中断的执行流程，最终，在进行线程切换之前，会执行到KiDispatchInterrupt函数，接下来，就来看看刚刚修改过的两个值，和这个函数有何关系： 进入KiDispatchInterrupt函数，这里有一个判断，稍作分析 这里的ebx存着的是KPCR，然后程序会去判断KPCR.QuantumEnd处的值是否为0，如果不是0，说明时间片走完了，也就是KTHREAD.Quantum值被减为0了，这是就会进行跳转，图中会跳转到loc_404902的位置 跟到loc_404902的位置继续观察， 这里先将KPCR.QuantumEnd的值置零，然后跳转到KiQuantumEnd函数中继续执行（为什么先赋值，再清零呢？因为已经判断过了，已经跳转到这里了，将QuantumEnd的值置零，也是为了下一个执行的线程） 好，进入KiQuantumEnd函数 具体细节看图，这部分，主要是重新设置了当前这个线程的CPU时间片的值为ThreadQuantum。接着往下看 然后这个函数调用了KiFindReadyThread函数，在就绪队列中找到一个线程，接着就返回了 执行完KiQuantumEnd函数后，我们又回到了KiDispatchInterrupt函数 如果刚刚在KiFindReadyThread可以在就绪队列中找到一个线程，那么eax的值就不为空，如图，接下来会跳转到loc_4048BB的位置 接着看4048BB的位置 看到了我们熟悉的线程切换函数 小结通过分析KeUpdateRunTime和KiDispatchInterrupt函数，我们可以发现。在CPU时间片用完的情况下，当时钟中断发生时，会发生线程的切换，这里做个小结： 当一个新的线程开始执行时，初始化程序会在KTHREAD.Quantum赋初始值，该值的大小由KPRCOESS.ThreadQuantum决定 每次时钟中断会调用KeUpdateRunTime函数，该函数每次将当前线程Quantum减少3个单，如果减到0，则将KPCR.PrcbData.QuantumEnd的值设置为非0 KiDispatchInterrupt判断时间片到期后，调用KiQuantumEnd函数（重新设置时间片、找到要运行的线程） 备用线程这里我们直接定位到KiDispatchInterrupt的位置，看图 可以发现，这是刚刚判断时间片是否到期的位置，这里共有两个判断： 若CPU时间片到期（即KPCR.QuantumEnd的值为非0），则跳转，否则继续执行 若存在备用线程，则将备用线程取出。啥是备用线程呢？就是KPCR+0x128的位置，该处成员名称叫做NextThread，是一个KTHREAD结构。如果这个位置的值不为0，那么程序会继续执行 后面的事情，看图片也就知道了。取出备用线程后，会先将当前线程放入就绪链表。这里为什么不放入等待链表呢？因为该线程处于就绪状态，只是在时钟中断发生时CPU时间片走完了或者存在备用线程，所以不会放入等待链表中。 当然。如果两个判断都没有执行，程序会直接跳到最后，返回了，也就是不发生线程切换 总结 当前线程主动调用API： KiSwapThread -> KiSwapContext -> SwapContext 当前线程时间片到期：KiDispatchInterrupt -> KiQuantumEnd -> SwapContext 存在备用线程：KiDispatchInterrupt -> SwapContext 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=50 参考文章： https://blog.csdn.net/qq_41988448/article/details/103421772 https://blog.csdn.net/qq_38474570/article/details/104273704","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows线程切换","slug":"Windows线程切换","date":"2020-04-01T15:36:56.000Z","updated":"2020-04-02T06:12:24.389Z","comments":true,"path":"2020/04/01/Windows线程切换/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/01/Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/","excerpt":"","text":"前一篇介绍了海哥写的一份Windows线程切换代码，通过对代码的分析和学习，我们知道了线程切换的本质就是堆栈的切换，其中有一个非常关键的函数：SwitchContext，当调用这个函数时，就会导致线程切换。同样，Windows也有一个用于线程切换的函数：KiSwapContext KiSwapContext分析我们先从这个函数开始说起，当然，相比海哥写的代码，Windows中切换线程的代码更为复杂，但本质还是一样的，这里不作详细分析，分析关键函数，找到KiSwapContext的核心实现。 首先定位到KiSwapContext 根据这几步，我们发现，外层函数传来了一个未知的参数ecx 我们跟进调用KiSwapContext的KiSwapThread 分析调用KiSwapContext的代码 可以发现，ecx的值，来源于KiFindReadyThread的返回值，顾名思义，这是一个在就绪队列中查找线程的函数，因此返回值应为一个KTHREAD 有了上面几步的分析，再回来看，就好理解了 这几步的含义是，先把当前运行的线程取出到edi中，然后将刚刚从就绪队列中取出来的线程，放到KPCR中。我们可以看到，目前esi，edi，分别存放了切换后将执行的线程和正在执行的线程，但这里没有实现，需要进一步跟进SwapContext函数。 进入SwapContext函数后，忽略细节，我们可以很快找到线程切换最精髓的两条语句 堆栈切换，回忆一下，上一篇海哥写的程序里，线程切换最关键的两条语句也是这样的原理，将esp保存到原线程的KernelStack中，并将新线程的KernelStack的值赋给esp，从而实现堆栈的切换，这也就是线程切换的本质。 主动切换函数调用过程在分析完KiSwapContext函数后，我们可以总结出这样一个调用过程： c1KiSwapThread -> KiSwapContext -> SwapContext(内部实现线程切换) 虽然，真正的切换是SwapContext函数实现的，但是经过分析，从KiSwapThread到KiSwapContext再到SwapContext是一个顺序执行的过程。所以我们可以认为，凡是调用了KiSwapThread函数，就一定会触发线程切换。 在IDA中查看KiSwapThread的交叉引用表 我们可以看到，一共有7个函数调用了KiSwapThread函数，说明执行这些函数时，都会发生线程切换 随机选取其中一个调用KiSwapThread的函数：KeWaitForSingleObject，查看KeWaitForSingleObject的交叉引用表 我们可以看到有很多函数都调用了KeWaitForSingleObject，这也意味着这些函数在执行时，都会发生线程切换，因为它们最终都会调用SwapContext函数 小结我们可以看到，Windows中绝大部分API都会直接或间接调用SwapContext这个函数，也就是说，只要调用这些API函数，就会发生线程切换，这种通过调用API函数导致的线程切换叫做主动切换。 时钟中断切换上面介绍了主动切换，需要依赖对系统API函数的调用才能触发。那么，如果不去主动调用系统API函数，该如何触发线程切换呢？这里介绍另一个导致线程切换的方式，通过时钟中断。 为何要采用时钟中断的方式呢？实际上我们在切换线程时，必须先让当前执行的线程停下来，保存了线程当前的环境后，再去切换线程。线程的暂停也意味着程序的暂停。那么，如何中断一个正在执行的程序呢？ 异常：例如缺页异常或者INT N指令 中断：例如时钟中断 系统时钟 （IDT表）中断号 IRQ 说明 0x30 IRQ0 时钟中断 在Windows操作系统中，每10~20毫秒便会触发一次时钟中断 想要获取当前版本Windows时钟间隔值，可使用Win32API：GetSystemTimeAdjustment 时钟中断的执行流程进入IDA，我们一起来分析一下时钟中断的执行流程 Alt+T 搜索_IDT，找到IDT表 之前中断门进0环学习过，int 2e执行的是KiSystemService，而时钟中断是int 30，所以我们可以很快定位它的中断例程是KiStartUnexpectedRange() 进入KiStartUnexpectedRange 发现里面跳转到了KiEndUnexpectedRange函数 继续跟进KiEndUnexpectedRange 内部跳转到函数KiUnexpectedInterruptTail 进入KiUnexpectedInterruptTail内部 在这个函数结束前，我们可以看到，它调用了一个外部函数HalEndSystemInterrupt，在导入表中可以看到，这个外部函数位于HAL.dll 用IDA打开hal.dll，找到HalEndSystemInterrupt继续分析，这个函数不大，一眼看完就可以发现，它又调用了一个外部函数KiDispatchInterrupt 我们再次进入导入表查看 巧了嘛！这个函数是ntoskrnl的，那我们又调回去了。。。 我们进入KiDispatchInterrupt康康 哦吼，我们发现了什么？这不是就是SwapContext嘛！就是线程切换函数！ 经过这么多步，终于找到了关键的函数，这里简单梳理一下流程 小结分析完时钟中断的执行流程可以发现，时钟中断最终会执行SwapContext函数，同样会发生线程切换。 异常处理还有一种导致线程切换的就是异常处理了。当程序发生异常时，会根据中断号，跳转到相应中断处理例程进行处理，也会导致线程的切换，这里不作详细分析了。具体的可以参考任务段这篇通过TSS模拟实现进程切换。本质同样是堆栈的切换。 关于进程切换本质上，进程的切换就是线程的切换，所以并不存在真正意义上进程的切换，与普通线程的切换相比，进程的切换仅仅是，两个线程不属于同一进程。因此在线程切换的过程中，Cr3换了，从而进程也就换了。 总结 如果一个线程不调用API，并且在代码中屏蔽中断（通过CLI指令），并且程序不会出现异常，那么当前线程将永久占有CPU（单核CPU占用率100%，2核CPU占用率50%） Windows并且是“抢占式”操作系统，所谓的“抢“必须是当前线程允许其它线程“抢”，否则是“抢”不到的 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=48 参考文章： https://blog.csdn.net/qq_41988448/article/details/103406636 https://blog.csdn.net/qq_38474570/article/details/104273704","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"模拟线程切换","slug":"模拟线程切换","date":"2020-03-31T13:15:33.000Z","updated":"2020-04-04T14:30:04.831Z","comments":true,"path":"2020/03/31/模拟线程切换/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/31/%E6%A8%A1%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/","excerpt":"","text":"我们知道CPU执行和调度的单位是线程，在有了线程结构体（ETHREAD）以及等待链表，调度链表的概念后，这一篇简单介绍一下线程切换，通过分析模拟线程切换的代码（源于滴水编程达人海东老师编写）来了解线程切换的过程及原理。 示例代码c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#include #include #define MAXGMTHREAD 0x100#define GMTHREADSTACKSIZE 0x80000#define GMTHREAD_CREATE 0x1#define GMTHREAD_READAY 0x2#define GMTHREAD_RUNING 0x4#define GMTHREAD_SLEEP 0x8#define GMTHREAD_EXIT 0x100#define _SELF abcd1234typedef struct //定义线程结构体{ char* name; //线程名 int Flags; //定义状态：Ready/Sleep/Running int SleepMillisecondDot; //休眠时间 void* InitialStack; //栈底 void* StackLimit; //栈限长 void* KernelStack; //栈顶 void *lpParameter; //线程函数参数 void (*func)(void *lpParameter); //线程函数}GMThread_t;int CurrentThreadIndex = 0;void* WindowsStackLimit = NULL;GMThread_t GMThreadList[MAXGMTHREAD] = {NULL, 0};void PushStack(unsigned int** Stackpp, unsigned int v);int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter); void InitGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void * lpParameter); void GMThreadStartup(GMThread_t* GMThreadp);void Scheduling(void); void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp);void GMSleep(int Milliseconds); void Thread1(void* lpParameter); void Thread2(void* lpParameter);void Thread3(void* lpParameter);void Thread4(void* lpParameter);int main(int argc, char* argv[]){ RegisterGMThread(\"Thread1\", Thread1, NULL); RegisterGMThread(\"Thread2\", Thread2, NULL); RegisterGMThread(\"Thread3\", Thread3, NULL); RegisterGMThread(\"Thread4\", Thread4, NULL); while(1) { Sleep(20); Scheduling(); } return 0;}//向栈中压入值void PushStack(unsigned int** Stackpp, unsigned int v) { *Stackpp -= 1; **Stackpp = v; return;}//将一个函数注册为单独线程执行int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter){ int i = 0; for (i=1; GMThreadList[i].name; i++) { if (0 == strcmp(GMThreadList[i].name, name)) { break; } } InitGMThread(&GMThreadList[i], name, func, lpParameter); return i;}//初始化线程的信息void InitGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void * lpParameter){ unsigned char* StackPages; unsigned int* StackDWORDParam; GMThreadp->Flags = GMTHREAD_CREATE; GMThreadp->name = name; GMThreadp->func = func; GMThreadp->lpParameter = lpParameter; StackPages = (unsigned char*)VirtualAlloc(NULL, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE); memset(StackPages, NULL, GMTHREADSTACKSIZE); GMThreadp->InitialStack = StackPages + GMTHREADSTACKSIZE; GMThreadp->StackLimit = StackPages; StackDWORDParam = (unsigned int*)GMThreadp->InitialStack; PushStack(&StackDWORDParam, (unsigned int)GMThreadp); PushStack(&StackDWORDParam, (unsigned int)9); PushStack(&StackDWORDParam, (unsigned int)GMThreadStartup); PushStack(&StackDWORDParam, 5); PushStack(&StackDWORDParam, 7); PushStack(&StackDWORDParam, 6); PushStack(&StackDWORDParam, 3); PushStack(&StackDWORDParam, 2); PushStack(&StackDWORDParam, 1); PushStack(&StackDWORDParam, 0); GMThreadp->KernelStack = StackDWORDParam; GMThreadp->Flags = GMTHREAD_READAY; return;}//启动线程的函数void GMThreadStartup(GMThread_t* GMThreadp){ GMThreadp->func(GMThreadp->lpParameter); GMThreadp->Flags = GMTHREAD_EXIT; Scheduling(); return;}//线程调度函数，这个函数使得当前线程让出CPU，从队列里重新选择一个线程执行void Scheduling(void){ int i; int TickCount; GMThread_t* SrcGMThreadp; GMThread_t* DstGMThreadp; TickCount = GetTickCount(); SrcGMThreadp = &GMThreadList[CurrentThreadIndex]; DstGMThreadp = &GMThreadList[0]; for (i=1; GMThreadList[i].name; i++) { if (GMThreadList[i].Flags & GMTHREAD_SLEEP) { if (TickCount > GMThreadList[i].SleepMillisecondDot) { GMThreadList[i].Flags = GMTHREAD_READAY; } } if (GMThreadList[i].Flags & GMTHREAD_READAY) { DstGMThreadp = &GMThreadList[i]; break; } } CurrentThreadIndex = DstGMThreadp - GMThreadList; SwitchContext(SrcGMThreadp, DstGMThreadp); }//切换线程__declspec(naked) void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp) { __asm { push ebp mov ebp, esp push edi push esi push ebx push ecx push edx push eax mov esi, SrcGMThreadp mov edi, DstGMThreadp mov [esi + GMThread_t.KernelStack], esp //经典线程切换的实现，本质就是切换堆栈 mov esp, [edi + GMThread_t.KernelStack] pop eax pop edx pop ecx pop ebx pop esi pop edi pop ebp ret }}void GMSleep(int Milliseconds){ GMThread_t* GMThreadp; GMThreadp = &GMThreadList[CurrentThreadIndex]; if (GMThreadp->Flags != 0) { GMThreadp->SleepMillisecondDot = GetTickCount() + Milliseconds; GMThreadp->Flags = GMTHREAD_SLEEP; } Scheduling(); return;}void Thread1(void* lpParameter){ while(1) { printf(\"Thread1\\n\"); GMSleep(500); }}void Thread2(void* lpParameter){ while(1) { printf(\"Thread2\\n\"); GMSleep(200); }}void Thread3(void* lpParameter){ while(1) { printf(\"Thread3\\n\"); GMSleep(10); }}void Thread4(void* lpParameter){ while(1) { printf(\"Thread4\\n\"); GMSleep(1000); }} 代码分析上述代码较长，且每行长短不一，故注释较乱，这里进行一些简要分析 模拟线程结构体c12345678910111213typedef struct //定义线程结构体{ char* name; int Flags; //定义状态：Ready/Sleep/Running int SleepMillisecondDot; //线程等待时间 void* InitialStack; //栈底 void* StackLimit; //栈限长 void* KernelStack; //栈顶 void *lpParameter; //线程函数参数 void (*func)(void *lpParameter); //线程函数}GMThread_t; 这是这份代码里最重要的结构体，它定义了我们模拟线程的结构，实际上，就是一个乞丐版的ETHREAD，只是很多ETHREAD中的成员我们用不到，就省去了，但仍然可以模拟线程切换的过程，这也算是个五脏俱全的线程结构体，我们来看看都有哪些成员吧： name：很好理解，线程的名字，用于标记线程 Flags：线程的状态，我们可以根据线程的状态将它放入等待链表或者让它执行 SleepMillisecondDot：线程的休眠时间。 InitialStack/StackLimit/KernelStack：可以说这是线程切换最重要的3个成员，每个线程执行时都需要有自己的堆栈，而具体该如何分配堆栈就要依靠这3个值，InitialStack提供了线程的栈底(ebp)；KernelStack提供了栈顶(esp)；StackLimit决定了栈的边界，可以这样理解，该线程的堆栈只能位于[ebp, ebp+StakLimit]的范围内，一旦超出这个范围，就会发生错误 lpParameter/func：分别是线程函数参数和线程函数，可以执行特定函数显示具体线程 全局变量和宏c1234567891011#define MAXGMTHREAD 0x100#define GMTHREADSTACKSIZE 0x80000#define GMTHREAD_CREATE 0x1#define GMTHREAD_READAY 0x2#define GMTHREAD_RUNING 0x4#define GMTHREAD_SLEEP 0x8#define GMTHREAD_EXIT 0x100int CurrentThreadIndex = 0;GMThread_t GMThreadList[MAXGMTHREAD] = {NULL, 0}; MAXGMTHREAD：指明线程最多能有多少个 GMTHREADSTACKSIZE：这里说的是线程分配的堆栈能有多大，每个线程都拥有自己的堆栈，但是不能无限大，大小的限制由KTHREAD结构里的KernelStack决定 GMTHREAD_CREATE/READAY/RUNING/SLEEP/EXIT：均为线程的状态 CurrentThreadIndex：可以理解为Index，用于遍历，这里作为全局变量进行声明。 GMThreadList：这里的类型是GMThread_t，说明这是模拟线程结构体链表，在KTHREAD结构体中，使用了WaitListEntry和SwapListEntry，根据线程的状态，将线程放入不同的链表中。这里，海东老师只用了一个数组，用来存放线程，其中下标0的位置，存放主函数的线程，其余位置存放不同状态的线程。 主函数c1234567891011121314int main(int argc, char* argv[]){ RegisterGMThread(\"Thread1\", Thread1, NULL); //注册线程1， 2， 3，4 RegisterGMThread(\"Thread2\", Thread2, NULL); RegisterGMThread(\"Thread3\", Thread3, NULL); RegisterGMThread(\"Thread4\", Thread4, NULL); while(1) { Sleep(20); //短暂等待 Scheduling(); //线程调度 } return 0 程序是从主函数开始执行的，我们按照函数执行的顺序进行分析 RegisterGMThread()：将一个函数注册为单独的线程来执行 Scheduling()：调度函数，使得当前线程让出CPU，并从队列中（GMThreadList）重新选择一个线程执行 线程注册函数c123456789101112131415int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter){ int i = 0; for (i=1; GMThreadList[i].name; i++) { if (0 == strcmp(GMThreadList[i].name, name)) { break; } } InitGMThread(&GMThreadList[i], name, func, lpParameter); return i；} 参数：线程名，线程函数，线程函数参数 前面提到了，下标0的位置，存放着是main线程，所以这里从下标1开始写入，对数组中未初始化的线程通过初始化函数InitiGMThread()进行初始化 压栈函数c1234567void PushStack(unsigned int** Stackpp, unsigned int v) { *Stackpp -= 1; //栈减一个int长度，就是4字节 **Stackpp = v; //并在这个位置存值 return;} 在介绍线程初始化函数前，先看一下这个压栈函数，这个函数非常简单，传了2个参数，一个指针，一个数。压栈函数的作用就是，指针-1（因为是*Stackpp，所以减的是int类型，即4字节），并在压栈后的地址存这个数，文字叙述可能不好理解，我们把这个转换一下就好理解了，其实就是代码实现的一个简单压栈操作 Code1234567891011_asm { sub esp, 4 mov eax, v mov esp, eax}or _asm { push v} 线程初始化函数c123456789101112131415161718192021222324252627282930313233343536373839void InitGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void * lpParameter){ unsigned char* StackPages; unsigned int* StackDWORDParam; //初始化线程结构体 GMThreadp->Flags = GMTHREAD_CREATE; GMThreadp->name = name; GMThreadp->func = func; GMThreadp->lpParameter = lpParameter; //分配80个连在一起的可以直接用的物理页 StackPages = (unsigned char*)VirtualAlloc(NULL, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE); //将分配的内存先都清0 memset(StackPages, NULL, GMTHREADSTACKSIZE); //设置栈底ebp GMThreadp->InitialStack = StackPages + GMTHREADSTACKSIZE; //设置栈的最大上限 GMThreadp->StackLimit = StackPages; //将ebp赋值StackDWORDParam StackDWORDParam = (unsigned int*)GMThreadp->InitialStack; PushStack(&StackDWORDParam, (unsigned int)GMThreadp); PushStack(&StackDWORDParam, (unsigned int)9); PushStack(&StackDWORDParam, (unsigned int)GMThreadStartup); PushStack(&StackDWORDParam, 5); //ebp PushStack(&StackDWORDParam, 7); //edi PushStack(&StackDWORDParam, 6); //esi PushStack(&StackDWORDParam, 3); //ebx PushStack(&StackDWORDParam, 2); //ecx PushStack(&StackDWORDParam, 1); //edx PushStack(&StackDWORDParam, 0); //eax //令KernelStack指向栈顶esp GMThreadp->KernelStack = StackDWORDParam; //修改线程状态Create->Ready GMThreadp->Flags = GMTHREAD_READAY; return;} 线程初始化：线程初始化总共分为2步，一个是对线程结构体的初始化，另一个是对线程所在堆栈的初始化 线程结构体初始化：对代码中定义的简约版线程结构体GMThread_t中的部分成员进行初始化，包括线程状态，线程名，线程函数及参数。 线程堆栈初始化：我们知道，每一个线程，都得有属于自己堆栈，总不能跑到别人的堆栈上执行吧，这样就乱套了因此线程得拥有自己的堆栈。来看一下模拟线程切换的代码中是如何实现的： 第一步用VirutalAlloc函数申请一块连续的内存（分配类型使用MEM_COMMIT） 初始化这块内存（置零） 设置栈底，栈顶，边界，这部分非常关键，也是设置线程堆栈的核心步骤。在KTHREAD结构中，有InitialStack/StackLimit/KernelStack决定线程的堆栈相关参数。本次的模拟程序里也定义了这三个成员，我们来看下他们是如何运作的。 InitialStack：这个成员相当于栈底，也就是ebp，在Windows中，堆栈的由高地址向低地址延申的，所以这里设置ebp的值为申请内存的首地址+堆栈限制大小 StackLimit：这个成员定义栈的边界，栈的范围应在[InitialStack, StackLimit]内，这里令其等于申请内存的首地址，因为栈由高地址向下延申，因此栈的边界会位于此处 KernelStack：这个成员指向栈顶，相当于esp。这里的几步非常关键，按照顺序依次push了线程结构体，一个数，一个执行线程的函数GMThreadStartup()，接着又是一堆数，最后，将栈顶（通过压栈函数减了很多次），赋值给了KernelStack 以上就是线程初始化最关键的部分，可以参考这张图 线程调度函数回到主函数，线程注册函数执行完后（线程初始化函数中的线程调用函数并未执行，只是被压栈了，所以稍后分析），就到了线程调度函数，一起来看一下线程调度函数都做了些什么吧 c12345678910111213141516171819202122232425262728293031323334353637void Scheduling(void){ int i; int TickCount; GMThread_t* SrcGMThreadp; GMThread_t* DstGMThreadp; TickCount = GetTickCount(); //指向正在执行的线程 SrcGMThreadp = &GMThreadList[CurrentThreadIndex]; //指向准备执行的线程 DstGMThreadp = &GMThreadList[0]; //遍历线程数组，找到第一个状态为就绪的线程 for (i=1; GMThreadList[i].name; i++) { if (GMThreadList[i].Flags & GMTHREAD_SLEEP) { if (TickCount > GMThreadList[i].SleepMillisecondDot) { GMThreadList[i].Flags = GMTHREAD_READAY; } } if (GMThreadList[i].Flags & GMTHREAD_READAY) { DstGMThreadp = &GMThreadList[i]; break; } } //得到即将执行的线程下标 CurrentThreadIndex = DstGMThreadp - GMThreadList; //线程切换 SwitchContext(SrcGMThreadp, DstGMThreadp); } 线程调度函数不是很复杂，比较好理解，这里简要概括下： 开头部分定义了两个线程结构体指针：SrcGMThreadp，DstGMThreadp SrcGMThreadp指向正在运行的线程，DstGMThreadp遍历线程数组，找到第一个状态为就绪的线程并指向它 保存DstGMThreadp指向的线程在数组中的下标（下次调度时好知道，正在运行的线程位于什么位置） 通过SwitchContext将这两个线程进行切换 线程切换函数c1234567891011121314151617181920212223242526272829303132__declspec(naked) void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp { __asm { push ebp mov ebp, esp push edi push esi push ebx push ecx push edx push eax mov esi, SrcGMThreadp mov edi, DstGMThreadp mov [esi + GMThread_t.KernelStack], esp //经典线程切换!!!本质是堆栈的切换！ mov esp, [edi + GMThread_t.KernelStack] pop eax pop edx pop ecx pop ebx pop esi pop edi pop ebp ret }} 这是本篇最高能的地方了，我们来详细分析一下，这个看上去简单的代码是如何实现线程切换的。我们来一步步的看： 最开始，一堆push，非常好理解，就是保存寄存器的值嘛！ 接下来，两个mov操作，将指向正在运行的线程结构体的指针赋给了esi，将指向准备运行的线程结构体的指针赋给了edi 然后，线程切换最经典的操作来了！将当前esp，赋值给esi指向线程的KernelStack；同时，将edi指向线程的KernelStack赋给esp。我们知道KernelStack存的是线程自己堆栈的esp，程序中的esp，是当前CPU执行的时的堆栈，而这个操作就是把当前堆栈保存到即将被切换的线程的KernleStack中，同时，让CPU执行所在的堆栈变成切换后的线程的KernelStack，说简单点，这个操作就是一次堆栈的切换！ 还没完！后面还有一堆pop，你以为就没用了嘛？仔细想想，堆栈已经发生了切换了！所以即将pop的那些值已经不是上面push进去的值了！那pop出来的值又是什么值呢？ 没错，就是在线程初始化函数中Push进去的那些值，一直到pop ebp都比较好理解 接下来，一个ret，又是一个精髓指令，通过这个ret指令，刚好调用一个用来执行线程的函数GMThreadStartup()，这个函数会让线程调用自己的线程函数。这里有一个细节，就是这个函数传递了一个线程结构体指针，但是在裸函数中，ret语句执行完就跳转到GMThreadStartup()函数的开始处执行，那么它又是如何获取参数的呢？我们来查看一下反汇编 根据这个函数的反汇编可以发现，它是通过[ebp+8]来获取参数的，而这个位置，刚好就是在初始化函数中，第一个push进去的线程结构体，紧接着push了一个9，仅仅是用来占位，从而使得[ebp+8]刚好可以指向线程结构体，从而获取参数，u1s1，这里细节妙不可言 这里贴一张群友张嘉杰做的笔记，做的非常好，结合着看更易看懂代码 执行线程函数c123456789void GMThreadStartup(GMThread_t* GMThreadp){ GMThreadp->func(GMThreadp->lpParameter); GMThreadp->Flags = GMTHREAD_EXIT; //线程切换 Scheduling(); return;} 这个函数，在上面刚讲过，主要就是最后，会再执行一次线程调度函数，实现下一次的线程切换，说明了一点，线程是主动切换的，主动让出CPU 程序运行结果最后，来看一下程序运行时的样子，就是在不断的线程切换 总结至此，程序主要部分就基本分析完毕，真的是非常巧妙的代码，海东老师太厉害了！这里对模拟线程切换做一个总结： 线程不是被动切换的，而是主动让出CPU 线程切换并没有使用TSS来保持寄存器，而是使用堆栈。 线程切换的过程就是切换堆栈的过程 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=47 参考文章： https://blog.csdn.net/qq_38474570/article/details/104245111 https://blog.csdn.net/qq_41988448/article/details/103098367 参考笔记：张嘉杰，Joney，米高扬设计局，馍馍","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"等待链表&调度链表","slug":"等待链表-调度链表","date":"2020-03-30T15:38:42.000Z","updated":"2020-03-30T16:28:53.447Z","comments":true,"path":"2020/03/30/等待链表-调度链表/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/30/%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8-%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"在前面介绍进程结构体时，进行了断链实验，程序可以正常运行，原因是CPU执行与调度的单位是线程，因此进程的断链并不影响程序的正常执行。对线程的断链也是一样的，断链后虽然可以隐藏断掉的线程，但同样不影响程序的执行。这说明，CPU调度时根本没有用到ThreadListEntry这个链表。接下来介绍两个与调度相关的链表：等待链表&调度链表 33个链表 线程有3种状态：就绪、等待、运行 正在运行中的线程存储在KPCR中，就绪和等待的线程全在另外的33个链表中。包括1个等待链表，32个就绪链表 这些链表都使用了_KTHREAD+0x060这个位置（如果是Win7的话，位于KTHREAD+0x074的位置），也就是说，线程在某一时刻，只能属于其中一个链表内 等待链表 查询指令：dd KiWaitListHead 说明： 等待链表是一个双向链表 当线程调用了Sleep()或者WaitForSingleObject()等函数时，就挂到这个链表 结构图： 关系梳理：KiWaitListHead -> WaitListEntry(KTHREAD+0x60) -> ThreadProcess(ETHREAD+0x220) -> EPROCESS 调度链表 查询指令：dd KiDispatcherReadyListHead L70 说明： 调度链表共32个双向链表 有32个调度链表的原因是，运行中的线程是有线程优先级，根据下标表示线程优先级别（0~31） 32位系统中，调度链表有32个（一组），64位系统则有64个（一组） 普通操作系统，只有一组调度链表，服务器版本系统中，调度链表的数量等于CPU的数量，但等待链表只有一个 结构图： 总结 正在运行的线程位于KPCR中 准备运行的线程根据线程优先级的不同，分布在32个调度链表中； KiDispatcherReadyListHead是个数组，存储了32个链表头 等待状态的线程存储在等待链表里，KiWaitListHead存储了链表头 这些圈均挂在KTHREAD+0x060的位置（XP系统）","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"KPCR","slug":"KPCR","date":"2020-03-30T01:06:50.000Z","updated":"2020-03-30T15:22:42.805Z","comments":true,"path":"2020/03/30/KPCR/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/30/KPCR/","excerpt":"","text":"进程在内核中对应结构体：EPROCESS 线程在内核中对应结构体：ETHREAD CPU在内核中也有一个对应的结构体：KPCR（Processor Control Region） KPCR结构我们已经很熟悉了，在API函数的调用过程中，多次使用到了KPCR，也简要介绍过一点。在保存现场之前有一个步骤就是将fs寄存器写入0x30，并根据GDT表，让fs寄存器指向KPCR。 KPCR介绍 当线程进入0环时，FS:[0]指向KPCR（3环时FS:[0] -> TEB） 每个CPU都有一个KPCR结构体（一个核一个） KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息。 在Windbg中执行指令：dt _KPCR 查看KPCR结构 结构图： KPCR成员+0x000 NtTib 成员名：NtTib 数据类型：_NT_TIB 说明：KPCR的第一个成员，存储部分关键信息（TEB的第一个成员也是这个结构） 结构图： +0x000 ExceptionList 成员名：ExceptionList 数据类型：Ptr32 _EXCEPTION_REGISTRATION_RECORD 说明：指向当前线程的异常链表（SEH），包含了当前线程的异常处理函数。Ring0（KPRC的ExceptionList）和Ring3（TEB的ExceptionList）的异常处理函数不同 +0x004 StackBase/+0x008 StackLimit 成员名：StackBase/StackLimit 数据类型：Ptr32 Void 说明：当前线程内核栈的基址和大小（KPCR中的是Ring0相关，TEB中就是Ring3相关） +0x018 Self 成员名：Self 数据类型：Ptr32 _NT_TIB 说明：指向自己（也就是指向_NT_TIB结构）这样设计的目的是为了查找方便。Ring0->KPCR，Ring3->TEB +0x01c SelfPcr 成员名：SelfPcr 数据类型：Ptr32 _KPCR 说明：指向自己，方便寻址 +0x020 Prcb 成员名：Prcb 数据类型：Ptr32 _KPRCB 说明：指向扩展结构体KPRCB +0x038 IDT 成员名：IDT 数据类型：Ptr32 _KIDTENTRY 说明：指向IDT表首地址 +0x03c GDT 成员名：GDT 数据类型：Ptr32 _KGDTENTRY 说明：指向GDT表首地址 +0x040 TSS 成员名：TSS 数据类型：Ptr32 _KTSS 说明：指向TSS，每个CPU都有一个TSS +0x051 Number 成员名：Number 数据类型：UChar 说明：CPU编号 +0x120 PrcbData 成员名：PrcbData 数据类型：_KPRCB 说明：KPCR的扩展结构体 结构图： KPRCB结构体KPRCB（Kernel Processor Control Block）是KPCR的扩展结构体 +0x004 CurrentThread成员名：CurrentThread 数据类型：Ptr32 _KTHREAD 说明：指向当前线程的KTHREAD +0x008 NextThread成员名：CurrentThread 数据类型：Ptr32 _KTHREAD 说明：指向下一个要执行线程的KTHREAD +0x00c IdleThread成员名：IdleThread 数据类型：Ptr32 _KTHREAD 说明：指向空闲线程的KTHREAD +0x88c QuantumEnd成员名：QuantumEnd 数据类型：Uint4B 说明：CPU时间片标志 关系梳理在简单了解完进程结构体（EPROCESS）、线程结构体（ETHREAD）、CPU结构体（KPCR）以后，来梳理一下它们之间的关系。 已知进程遍历进程：PsActiveProcessHead -> ActiveProcessLinks(EPROCESS+0x88)…… 遍历线程：PsActiveProcessHead -> ActiveProcessLinks(EPROCESS+0x88) -> ThreadListHead(KPROCESS+0x50 / EPROCESS+0x190) -> ThreadListEntry(KTHREAD+0x1b0 / ETHREAD+0x22c)…… 已知线程遍历进程：ETHREAD+0x220 -> EPROCESS -> ActiveProcessLinks(EPROCESS+0x88)…… 遍历线程：ETHREAD+0x22c / ETHREAD+0x1b0 -> ThreadListEntry…… 已知KPCR遍历进程：进入0环后 -> fs:[0] -> KPCR -> PrcbData(KPCR+0x120) -> CurrentThread(KPRCB+0x4) -> EPROCESS(ETHREAD+0x220) -> ActiveProcessLinks(EPROCESS+0x88)…… 遍历线程：进入0环后 -> fs:[0] -> KPCR -> PrcbData(KPCR+0x120) -> CurrentThread(KPRCB+0x4) -> ETHREAD+0x22c / ETHREAD+0x1b0 -> ThreadListEntry…… 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=45 参考文档：张嘉杰笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"线程结构体","slug":"线程结构体","date":"2020-03-29T09:01:47.000Z","updated":"2020-03-30T15:22:17.474Z","comments":true,"path":"2020/03/29/线程结构体/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/29/%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"Windows中每个进程会包含一个或多个线程，每个线程在0环都有一个对应的结构体：ETHREAD，这个结构体包含了线程所有重要的信息，下面来简单了解一下。 ETHREADWindbg中，执行dt _ETHREAD可以看到这个完成的结构： +0x000 Tcb 成员名：Tcb 数据类型：_KTHREAD Windbg查询指令：dt _KTHREAD 结构图： 说明：KTHREAD这个结构应该已经比较眼熟了，在API函数的调用过程（保存现场），就多次用到了KTHREAD结构里的成员。 +0x000 Header 成员名：Header 数据类型：_DISPATCHER_HEADER 说明：结构体内若包含_DISPATCHER_HEADER这个数据类型，说明这是一个可等待对象 可等待对象：Mutex，Event都是可等待对象，可被作用于WaitForSingleObject这类函数 +0x018 InitialStack/+0x01c StackLimit/+0x028 KernelStack 成员名：InitialStack/StackLimit/KernelStack 数据类型：Ptr32 Void 说明：这三个成员与线程切换有关。有印象的话，在分析KiFastCallEntry函数保存现场的过程中，曾有一行代码获取了InitialStack的值，并存到了ebp中。 此外，线程切换发生时，会根据KernelStack修改TSS的ESP0。更多关于这三个成员的用法，会在后面线程切换的地方再提到 +0x020 Teb 成员名：Teb（Thread Environment Block），线程环境块 数据类型：Ptr32 Void 大小：4KB 结构图： 说明： 0x20位置存着一个指向Teb结构的指针 Teb是在3环用来描述线程的一个结构。 0环时，FS:[0]指向KPCR；3环时，FS:[0]指向TEB +0x02c DebugActive 成员名：DebugActive 数据类型：UChar 说明：在分析KiSystemService进行保存现场的过中遇到过，若这个位置的值不是-1，说明处于调试状态，程序会跳转到执行一个将Dr0~Dr7保存到_Trap_Frame里面的操作。从而衍生出了一个反调试手段，将这个位置的值置为-1，从而不能使用8个调试寄存器 +0x02d State 成员名：State 数据类型：UChar 说明：线程状态-就绪/等待/运行 +0x060 WaitListEntry/SwapListEntry 成员名：WaitListEntry/SwapListEntry 数据类型：WaitListEntry为_LIST_ENTRY / SwapListEntry为 _SINGLE_LIST_ENTRY 说明：此处为Wait链表或Ready链表。Windows线程总是处于Wait/Running/Ready这三种状态之一 +0x06c BasePrioirty 成员名：BasePriority 数据类型：Char 说明：其初始值是所属进程的BasePrioirty值（KPROCESS->BasePriority），以后可以通过KeSetBasePriorityThread()函数重新设定 +0x070 WaitBlock 成员名：WaitBlock 数据类型：[4]_KWAIT_BLOCK 说明：当前线程，正在等待哪个可等待对象（WaitForSingleObject）这个可等待对象的信息就会被写入这个_KWAIT_BLOCK结构的数组里。 +0x0E0 ServiceTable 成员名：ServiceTable 数据类型：Ptr32 Void 说明：这个应该很熟悉了，指向系统服务表基址；通过系统服务表，可以找到函数地址表，根据系统服务号提供的偏移，就可以在函数地址表中找到3环API接口对应的0环内核函数 +0x134 TrapFrame 成员名：TrapFrame 数据类型：Ptr32 _KTRAP_FRAME 说明：这个也很熟悉了，进0环时，保存现场的原理就是填充寄存器及相关数据到TrapFrame结构中，最后更新TrapFrame位置的值，使其指向新保存的TrapFrame +0x140 PerviousMode 成员名：PerviousMode 数据类型：Char 说明：在调用0环函数，保存现场的过程时，会将先前模式保存到TrapFrame结构中，以便根据先前模式，能够正确的返回到调用它的函数。 +0x1b0 ThreadListEntry 成员名：ThreadListEntry 数据类型：_LIST_ENTRY 说明： 双向链表，一个进程所有的线程，都挂在一个链表中，挂的就是这个位置 链表头位于KPROCESS+0x50的位置以及EPROCESS+0x194的位置，相当于ThreadListEntry的PsThreadListHead 一共有两个这样的链表 APC相关（位于KTHREAD内） 成员位置 成员名 数据类型 0x034 ApcState _KAPC_STATE +0x0e8 ApcQueueLock Uint4B +0x138 ApcStatePointer [2] Ptr32 _KAPC_STATE +0x14c SavedApcState _KAPC_STATE 说明：这些均为与APC相关的结构，具体到APC章节再做分析，这里仅作了解 +0x1ec Cid 成员名：Cid 数据类型：_CLIENT_ID 说明：共八字节，包含两个值，当前进程的PID和当前线程的CID 结构图： +0x220 ThreadProcess 成员名：ThreadProcess 数据类型：Ptr32 _EPROCESS 说明：指向自己所属进程 +0x22c ThreadListEntry 成员名：ThreadListEntry 数据类型：_LIST_ENTRY 说明： 双向链表，一个进程所有的线程，都挂在一个链表中，挂的就是这个位置 链表头位于KPROCESS+0x50的位置以及EPROCESS+0x194的位置，相当于ThreadListEntry的PsThreadListHead 一共有两个这样的链表 这个双向链表的内容和0x1b0位置的完全一样，构建2个双向链表主要是为了方便，一个位于KPROCESS内，一个位于EPROCESS内 结构图： 关于断链在进程结构体中，我们通过断链实现了简单的进程隐藏，其原理在于，任务管理器在查询进程便是通过遍历ActiveProcessLink实现的。尽管进程已经不在活动进程链表上，但是仍然可以运行，原因是Windows调度的基本单位是线程，而不是进程，所以才有从进程链表上摘除自身进程的隐藏方法，这虽然从进程链表上摘除了自身，但不会影响操作系统的调度，所以不影响程序运行。 不过这里没能完成线程断链的实验，原因可能在于VMware虚拟机的指令问题，Windbg无法中断操作系统时间过长，所以经常实验到一半，就无法继续执行指令了，只能重启虚拟机，后续到驱动章节会此实验作为练习补上。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=44 参考文章：https://blog.csdn.net/emaste_r/article/details/8916786 参考笔记：张嘉杰的笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"进程结构体","slug":"进程结构体","date":"2020-03-28T15:50:13.000Z","updated":"2020-03-30T01:46:19.225Z","comments":true,"path":"2020/03/28/进程结构体/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/28/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"进程，站在内核的角度来说，它就是个结构体。当操作系统想要创建一个进程时，本质上就是分配一块内存，填充一个结构体，今天就来了解一下这个进程结构体EPROCESS。 EPROCESS每个Windows进程在0环都有一个对应的结构体：EPROCESS，这个结构体包含了进程所有重要的信息。 在Windbg中，执行指令dt _EPROCESS 我们就可以看到这个完整的结构。 这个结构非常的庞大，本篇先混个眼熟，介绍一些比较关键的字段，其余在后续文章中用到时再详细介绍。 +0x000 Pcb 成员名：Pcb 数据类型：_KPROCESS 说明：在EPROCESS开始的位置，有一个Pcb，它是一个KPROCESS结构，同样包含了描述进程的信息，先来看一下这个结构比较关键的一些字段。 结构图： +0x000 Header 成员名：Header 数据类型：_DISPATCHER_HEADER 说明：结构体内若包含_DISPATCHER_HEADER这个数据类型，说明这是一个可等待对象 可等待对象：Mutex，Event都是可等待对象，可被作用于WaitForSingleObject这类函数 +0x018 DirectoryTableBase 成员名：页目录表基址 数据类型：[2] Uint4B 说明：进程结构体中最重要的成员，控制整个进程的物理页，进程切换时会将值填入Cr3 +0x038 KernelTime/+0x03c UserTime 成员名：KernelTime/UserTime 数据类型：Uint4B 说明：统计信息，记录了一个进程在内核模式/用户模式下所花的时间 +0x050 ThreadListHead 成员名：ThreadListHead 数据类型：_LIST_ENTRY 说明：指向当前进程的，线程链表 +0x05c Affinity 成员名：Affinity 数据类型：Uint4B 说明：规定进程里面的所有线程能在哪个CPU上跑 如果值为1，那这个进程的所有线程只能在0号CPU上跑（00000001） 如果值为3，那这个进程的所有线程能在0、1号CPU上跑（000000011） 如果值为4，那这个进程的所有线程能在2号CPU上跑（000000100） 如果值为5，那这个进程的所有线程能在0，2号CPU上跑（000000101） 4个字节共32位，所以最多只能32核，Windows64位，就64核；如果只有一个CPU，把这个值设置为4，那么这个进程就死了。 +0x062 BasePriority 成员名：BasePriority 数据类型：Char 说明：表示基础优先级/最低优先级，该进程中的所有线程一创建出来时最初的优先级 到这里KPROCESS内部的主要成员就介绍完了，现在又要回到EPROCESS这个结构中了 +0x063 ThreadQuantum 成员名：ThreadQuantum 数据类型：Char 说明：线程时间片的初始值 +0x070 CreateTime/+0x078 ExitTime 成员名：CreateTime/ExitTime 数据类型：_LARGE_INTEGER 说明：进程的创建/退出时间 +0x084 UniqueProcessId 成员名：UniqueProcessId 数据类型：Ptr32 Void 说明：进程的编号，任务管理器中显示的PID就是这个值 +0x088 ActiveProcessLinks 成员名：ActiveProcessLinks 数据类型：_List_Entry 说明：双向链表，所有的活动进程都连接在一起，构成了一个链表 PsActiveProcessHead指向全局链表头 第一个成员指向后一个进程结构体0x88偏移的位置，第二个成员指向前一个结构体0x88偏移的位置 通过断链，可以实现简单的进程隐藏 结构图： 查询示范： +0x090 QuotaUsage/+0x09c QuotaPeak 成员名：QuotaUsage/QuotaPeak 数据类型：[3] Uint4B 说明：物理页相关的统计信息（到内存部分会详细分析） +0x0a8 CommitCharge/+0x0ac PeakVirtualSize/+0x0b0 VirtualSize 成员名：CommitCharge/PeakVirtualSize/VirtualSize 数据类型：Uint4B 说明：虚拟内存相关的统计信息（到内存部分会详细分析） +0x11c VadRoot 成员名：VadRoot 数据类型：Ptr32 Void 说明：指向一个平衡二叉树，标识了0~2G哪些内存被分配了，哪些没被分配；该成员和内存遍历，模块隐藏有关 +0x0bc DebugPort /+0x0c0 ExceptionPort 成员名：DebugPort/ExceptionPort 数据类型：Ptr32 Void 说明：调试相关，通过清零DebugPort，是一种简单的反调试手段，具体关于调试的内容，到调试相关章节会详细分析 +0x0c4 ObjectTable 成员名：ObjectTable 数据类型：Ptr32 _HANDLE_TABLE 说明：句柄表，存储在0环，记录了当前进程所使用的别的进程的句柄地址，可以通过遍历所有进程的句柄表来查看当前程序是否被调试。在句柄表的章节，会详细讲解这个成员的内容 +0x174 ImageFileName 成员名：ImageFileName 数据类型：[16]UChar 说明：进程镜像文件名，最多16个字节。如上面查询活动进程链表的实验中，可以看到进程名为”System” 0x1a0 ActiveThreads 成员名：ActiveThreads 数据类型：Uint4B 说明：活动线程的数量 0x1b0 Peb 成员名：Peb 数据类型：Ptr32_PEB 说明：PEB（Process Enviroment Block 进程环境快）：位于3环的一个描述进程的结构，里面包含了进程的模块列表、是否处于调试状态，等信息 结构图： 下面简单介绍其中2个成员： 0x2 BeingDebugged 成员名：BeingDebugged 数据类型：Uchar 说明：当进程属于被调试的时候，这个位置的值会被置1。调试器可以通过不断清零这个值，做到简单的反反调试 0xc Ldr 成员名：Ldr 数据类型：_PEB_LDR_DATA 该结构内有3个双向链表成员，存储了当前进程所有的模块（只是顺序不同），通过断链可以实现简单的模块隐藏 结构图： 进程隐藏在前面介绍了EPROCESS里有一个双向链表ActiveProcessLinks，我们可以通过断链，实现简单的进程隐藏。 打开OD，然后打开任务管理器，可以看到，OD这个进程 然后找到活动进程链表头 从后往前遍历（刚打开的进程，位于链表靠后的位置），找到OD这个进程对应的EPROCESS 修改OD前后进程结构体的活动进程链表，将OD断链 再次打开任务管理器，发现没有OD这个进程了，但是程序仍能正常执行 说明任务管理器是通过遍历活动进程链表来查询所有进程的 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=43 参考文章： https://blog.csdn.net/qq_41988448/article/details/103005060 https://blog.csdn.net/qq_38474570/article/details/103722984","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（系统服务表）","slug":"API函数的调用过程（系统服务表）","date":"2020-03-27T15:49:50.000Z","updated":"2020-03-29T13:08:03.028Z","comments":true,"path":"2020/03/27/API函数的调用过程（系统服务表）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/","excerpt":"","text":"前面的学习过程中，我们了解到程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做_Trap_Frame的结构体中。在3环部分，程序将一个编号存到了eax中，这个编号叫做系统服务号，此外，在保存现场的过程中，程序还让edx指向了3环第一个参数的地址。回忆起这两步，接下来，就可以继续探究执行内核函数的过程了。 系统服务表在分析代码前，我们先来学习一个结构，系统服务表（System Service Table） 在Windows XP系统下，系统服务表有两张，这两张表存着内核文件的导出函数（不包括内核文件的所有函数，主要是3环函数常用的内核函数）。第一张表导出的内核函数主要来源于ntoskrl.exe，实现大部分3环函数基本功能；第二张表导出的内核函数主要来源于win32k.sys，主要实现图形界面相关功能（例如GDI32.dll的底层实现）。 系统服务表结构根据示例图，我们先简单认识一下系统服务表，先从结构看起： ServiceTable：指向一个函数地址表，通过系统服务号可以在函数地址表中找到指定的内核函数。 Count：指当前系统服务表被调用的次数。 ServiceLimit：函数地址表的大小，即系统服务函数的个数 ArgmentTable：系统服务函数参数的大小，以字节为单位，每个成员大小为1个字节。 系统服务表位置这个系统服务表位于KTHREAD结构的0xE0偏移处。这样，在进入0环后我们可以通过fs:[0]找到KPCR结构，然后在KPCR->0x124找到当前线程的KTHREAD结构，再根据KTHREAD->0xE0就可以找到当前线程所拥有的系统服务表。 Code1fs:[0] -> KPCR -> KPCR+0x124 -> KTHREAD -> KTHREAD+0xE0 -> 系统服务表 系统服务号系统服务号用来定位所要寻找的系统服务表的函数。 系统服务号只有低13位是有用的 下标12：判断去查服务表，0去查第一张表；1去查第二张表 下标0~11：函数地址表的索引 SharedCode分析在前面保存现场的代码分析中，由于进入0环的方式不同，中断进0环（int 2E）和快速调用（sysenter）保存现场的方式也不一样，但是当这两种方式，将寄存器保存到_Trap_Frame结构中以后（保存现场），便会从同一个地放（KiFastCallEntry+0x8D）开始执行，我们把这一部分共同的代码称作SharedCode（引用Joney的文中的称呼），接下来，我们简要分析一下SharedCode到底做了什么事。 这里还是将代码放在一起分析，更有连贯性，具体细节可以到Windbg中动手实现 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455804df781 8bf8 mov edi,eax //eax保存的是系统服务号(参考3环部分)，edi获804df781 //取服务号804df783 c1ef08 shr edi,8 //将edi右移8位，系统服务号只用到13位，这样还804df783 //剩下5位804df786 83e730 and edi,30h //将余下的5位与0x30(0011 0000)进行与804df786 //算,得到的结果只有可能是0x10或者0，这里非常巧804df786 //妙，因为0x10刚好是16个字节804df789 8bcf mov ecx,edi //将与后的结果，赋值给ecx804df78b 03bee0000000 add edi,dword ptr [esi+0E0h] //esi指向KTHREAD，[esi+0xE]就算获取到第一个系804df78b //统服务表的首地址，然后加上edi。这里如果edi的804df78b //值是0x10，运算后，edi就会指向第二个系统服务804df78b //表的首地址，所以上一步的与运算很巧妙804df791 8bd8 mov ebx,eax //ebx获取服务号804df793 25ff0f0000 and eax,0FFFh //对服务号进行与运算，因为上面的步骤已经确定了804df793 //从哪一个系统服务表里找，这里将下标12的位置零804df793 //，获取在函数地址表里的索引804df798 3b4708 cmp eax,dword ptr [edi+8] //[edi+8]指向ServiceLimit，这里与系统服务号作804df798 //比较，防止系统符服务号越界804df79b 0f8341fdffff jae nt!KiBBTUnexpectedRange (804df4e2) //若越界则跳转异常处理804df7a1 83f910 cmp ecx,10h //这里判断系统服务号属于哪个表(虽然前面的步骤判804df7a1 //断过一次了，前面是为了判断服务号是否越界，这804df7a1 //里主要是找到合适的处理函数)804df7a4 751a jne nt!KiFastCallEntry+0xcc (804df7c0) //若不等，就跳转到处理查找第一个系统服804df7a4 //务表的例程804df7a6 8b0d18f0dfff mov ecx,dword ptr ds:[0FFDFF018h] //若要去查找第二个系统服务表，从这里走，不作详细804df7a6 //分析804df7ac 33db xor ebx,ebx804df7ae 0b99700f0000 or ebx,dword ptr [ecx+0F70h]804df7b4 740a je nt!KiFastCallEntry+0xcc (804df7c0)804df7b6 52 push edx804df7b7 50 push eax804df7b8 ff1564b25580 call dword ptr [nt!KeGdiFlushUserBatch (8055b264)]804df7be 58 pop eax804df7bf 5a pop edx804df7c0 ff0538f6dfff inc dword ptr ds:[0FFDFF638h] //如果查第一个表，会跳到这里来 [0xffdff638]804df7c0 //KPRCB结构的0x518偏移处，存的是KeSystemCalls804df7c0 //，这里自增1(具体用处到APC那块会讲到)804df7c6 8bf2 mov esi,edx //edx存着3环第一个参数的地址，赋给esi804df7c8 8b5f0c mov ebx,dword ptr [edi+0Ch] //ebx获取函数参数表地址804df7cb 33c9 xor ecx,ecx //清空ecx，之前用来判断寻找哪个系统服务表804df7cd 8a0c18 mov cl,byte ptr [eax+ebx] //cl获取函数参数个数804df7d0 8b3f mov edi,dword ptr [edi] //另edi直接指向函数地址表首地址804df7d2 8b1c87 mov ebx,dword ptr [edi+eax*4] //ebx获取到0环实现的内核函数804df7d5 2be1 sub esp,ecx //提升堆栈，ecx里存的是参数个数的总字节804df7d7 c1e902 shr ecx,2 //相当于运算ecx/4，方便rep movsd，因为rep804df7d7 //movsd是4字节运算804df7da 8bfc mov edi,esp //rep movsd指令用，Copy的目的地804df7dc 3b35d40b5680 cmp esi,dword ptr [nt!MmUserProbeAddress (80560bd4)]//检测三环参数地址范围是否越界804df7e2 0f83a8010000 jae nt!KiSystemCallExit2+0x9f (804df990) //若越界，进行异常处理804df7e8 f3a5 rep movs dword ptr es:[edi],dword ptr [esi] //将参数复制到堆栈804df7ea ffd3 call ebx //调用0环函数！804df7ec 8be5 mov esp,ebp804df7ee 8b0d24f1dfff mov ecx,dword ptr ds:[0FFDFF124h]804df7f4 8b553c mov edx,dword ptr [ebp+3Ch]804df7f7 899134010000 mov dword ptr [ecx+134h],edx 至此，这块KiFastCallEntry和KiSystemService最终都会执行的一段被我们称作SharedCode的代码段，就分析完了， SSDT前文提到了，我们可以通过fs找到KPCR，在通过KPCR找到KTHREAD，然后在KTHREAD+0xE0处找到系统服务表，这里再介绍另一种找到系统服务表的办法，通过SSDT。 SSDT&SSDT ShadowSSDT（System Services Descriptor Table）系统服务描述符表，在这个结构中包含4个成员，每个成员都是一个系统服务表的结构体，可以在Windbg中通过dd KeServiceDescriptorTable指令进行查看（在程序中可以直接声明全局变量KeServiceDescriptorTable，从而找到找到系统服务表。）： 我们可以看到第一个成员的ServiceTable，Count，ServiceLimit，ArgmentTable字段，Windows Xp只使用了2张表，所以第三个和第四个成员的位置是空的，此外，由于SSDT第二个成员是未导出的，所以第二个成员的位置也是空的。这里介绍一个新的指令，dd KeServiceDescriptorTableShadow，通过全局变量KeServiceDescriptorTableShadow可以查看两张完整的系统服务表。 但是，全局变量KeServiceDescriptorTableShadow也是未导出的，在实际写程序时，不能通过直接访问win32k.sys导出的第二张系统服务表的函数地址，因为里面的函数地址都是无效的。原因是，win32k.sys导出的第二张系统服务表只有在当前进程访问GDI相关的API时，里面的函数地址表才会挂载到物理页上。如果进程没有用到GDI相关的API，那么第二张系统服务表里面的函数地址表就不会挂载到物理内存，那么里面的函数也无效。 内核函数查找有了SSDT表，我们查找3环API对应的内核函数就很简单了，拿之前分析过的3环API函数ReadProcessMemory举例，在进入0环之前，给eax赋值了一个系统服务号0xba，那我们就用这个ba来查看这个这个函数在内核的实现。 通过这张图，可以很清晰的看出来，ReadProcessMemory所实现的功能，在底层是由一个叫做NtReadVirtualMemory完成的。 总结API函数的调用过程，从3环进入0环，再到找到对应的内核函数，这部分到这就差不多了，当然，真正的调用过程并没有到此结束，因为调用完0环的函数，总得返回3环呀！只是这部分需要用到APC的知识点，因此这里还不能完整实现。此外，在API函数调用这块，还有个小实验，在SSDT表中追加一个函数地址(NtReadVirtualMemory),自己编写API的3环部分调用这个新增的函数(注意：使用2-9-9-12分页，10-10-12会蓝屏)，就留到后面补上了 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=41 参考文章： https://www.cnblogs.com/joneyyana/p/12585469.html https://blog.csdn.net/qq_38474570/article/details/103674271 https://blog.csdn.net/qq_41988448/article/details/102994374","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（保存现场）","slug":"API函数的调用过程（保存现场）","date":"2020-03-26T01:30:03.000Z","updated":"2020-03-27T13:45:22.749Z","comments":true,"path":"2020/03/26/API函数的调用过程（保存现场）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/26/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA%EF%BC%89/","excerpt":"","text":"现在我们知道如何进入0环了，有两种方式，通过中断门或者快速调用。上一篇中最后留下了几个问题，其中一个就是关于如何保存那些3环寄存器原先的值（俗称保存现场），从而能够在执行完0环实现的功能后，顺利的返回到3环，今天我们就来探究一下这个问题，首先我们来认识几个结构：Trap_Frame，ETHREAD/KTHREAD，KPCR _Trap_Frame在Windbg中通过dt _KTrap_Frame进行查看 （0x7c~0x88）在保护模式下没有被使用，只在虚拟8086模式中用得到 （0x68~0x78）中断门进0环时，用于存储3环的CS，SS，ESP，EIP，EFLAGS （0x48~0x64）保存现场 （0x00~0x44）调式及其它作用 简要介绍完了Trap_Frame结构，了解了这是保存现场用到的结构，后面在分析KiSystemService时，会介绍保存现场的主要过程。 ETHREAD&KTHREADETHREAD（执行体线程块）是执行体层上的线程对象的数据结构。在Windows内核中，每个进程的每一个线程都对应着一个ETHREAD数据结构。 在Windbg中通过dt _ETHREAD进行查看 ETHREAD结构内嵌了一个KTHREAD对象作为第一个数据成员，因此一个指向ETHREAD对象的指针同时也是一个指向KTHREAD对象的指针。 在Windbg中通过dt _KTHREAD进行查看 大致先解下这些结构即可，后续在介绍到线程与进程处时，会慢慢分析各个字段。 KPCR描述： 全称为CPU控制区（Processor Control Region） 每一个CPU都有一个CPU控制区，跟TLB一样，一核一个KPCR 指令： dt _KPCR：查看KPCR结构 dd KeNumberProcessors：查看KPCR数量 dd KiProcessorBlock：查看KPCR位置 由于当前虚拟机只分配了一个核，所以数量是1 同理，因为单核，这里只显示了一个值，这个地址显示的是ffdff120，也就是KPCR偏移0x120的位置。KPCR偏移0x120的位置是 _KPRCB，可以理解为扩展的KPCR KiSystemService了解完上面介绍的结构，下面我们就可以分析一下0环函数KiSystemService，到底是如何保存现场的。 函数主体并不长，按照填充的结构不同我们来逐步分析。 0x1Code123456804df631 6a00 push 0 //ErrorCode804df633 55 push ebp804df634 53 push ebx804df635 56 push esi804df636 57 push edi804df637 0fa0 push fs 首先来看这一段，为什么要push 0起手呢？ 这里先回顾一下Trap_Frame结构。 这是一个结构，换句话说，就是进入0环后的堆栈将会像这种形式组织起来，在刚进0环是，esp是位于 (0x78) 的位置，我们知道，通过中断门进0环时，会将3环的寄存器压栈，包括CS，SS，EIP，ESP和EFLAGS。因此在进入0环后，ESP的位置是位于 (0x68) 处。虽然2E号中断只会压入5个值，但是有些情况会压入6个值，而第6个值，就是ErrCode，为了对齐，保持堆栈平衡，操作系统这里会自己补一个0，这也就解释了为什么第一步是push 0。 接下来，就是保存ebp，ebx，esi，esi，fs依次压栈，保存到Trap_Frame结构中描述的位置。 0x2Code1234567804df639 bb30000000 mov ebx,30h804df63e 8ee3 mov fs,bx //写入fs段寄存器804df640 ff3500f0dfff push dword ptr ds:[0FFDFF000h] //保存旧的异常链表(ExceptionList)804df646 c70500f0dfffffffffff mov dword ptr ds:[0FFDFF000h],0FFFFFFFFh //将新的异常链表赋值为-1804df650 8b3524f1dfff mov esi,dword ptr ds:[0FFDFF124h] //获取当前线程KTHREAD804df656 ffb640010000 push dword ptr [esi+140h] //将先前模式(PreviousMode)压栈804df65c 83ec48 sub esp,48h //提升堆栈（栈顶执行Trap_Frame头） 我们来看这部分做了什么事 首先是将段选择子0x30写入fs段寄存器 根据段选择子确定段描述符，然后可以发现fs指向的地方(0xffdff000)刚好是KPCR这个结构。 然后压栈了KPCR首地址位置的值 可以发现，KPCR首地址位置存的是异常链表(ExceptionList)，这里压栈了旧的异常链表，并将异常链表的值置为-1。至于异常链表的结构，留到后面再讲。 接着获取到KPCR + 0x124位置的值，并存入esi，然后将esi+0x140处的值压栈 可以发现KPCR+0x124处（赋给esi）的值，存的是当前线程（CurrentThread）的KTHREAD，我们再找到(esi)KTHREAD+0x140偏移，发现压栈的字段叫做先前模式（PerviousMode） 最后提升堆栈0x48个字节 经过这一部分的操作后，堆栈栈顶刚好指向_Trap_Frame的首地址，并完成了异常链表和先前模式的压栈操作。 0x3Code12345678804df65f 8b5c246c mov ebx,dword ptr [esp+6Ch] //取进入中断门压栈的CS804df663 83e301 and ebx,1 //计算出调用中断门前的权限804df666 889e40010000 mov byte ptr [esi+140h],bl //重新填写KTHREAD中的先前模式 804df66c 8bec mov ebp,esp //让ebp指向_Trap_Frame首地址804df66e 8b9e34010000 mov ebx,dword ptr [esi+134h] 804df674 895d3c mov dword ptr [ebp+3Ch],ebx //将旧的_Trap_Frame保存到edx中804df677 89ae34010000 mov dword ptr [esi+134h],ebp //更新_Trap_Frame804df67d fc cld 继续分析这一部分 我们来看前3行，它做了什么事呢，先取出_Trap_Frame 0x6C偏移处的值，即进入中断门前，程序CS的值，然后和1进行了与运算，并将bl的值，填入上面提到的先前模式 为什么和1进行与运算就可以算出先前模式呢？难道不直接填3吗？首先我们知道，Windows只用了0环和3环，其次，即使执行中断门，执行前的程序也可以是0环程序，所以保守起见，这里和CPL的最低位进行与运算；若结果为1，说明是3环程序执行了中断门，若为0，说明是0环程序执行的中断门。从而算出先前模式，并填入到当前线程KTHREAD的先前模式字段中。 上面3行更新了先前模式，接下来4行的作用就是更新了_Trap_Frame，我们知道栈顶指向Trap_Frame的首地址，现在让栈底也指向Trap_Frame的首地址，便于寻址。 由0x2的分析可知esi指向KTHREAD，KTHREAD+0x134则指向Trap_Frame，这里的Trap_Frame是旧的地址（这里则是Null），因此将它保存至堆栈，再将现在的Trap_Frame的地址写入，也就完成了更新。 cld指令修改了EFLAGS寄存器的DF位 0x4Code12345678910804df67e 8b5d60 mov ebx,dword ptr [ebp+60h] //取3环的ebp给ebx804df681 8b7d68 mov edi,dword ptr [ebp+68h] //取3环的eip给edi804df684 89550c mov dword ptr [ebp+0Ch],edx //edx存的是3环第一个参数的地址，赋到_Trap_Frame的DbgArgPointer的位置804df687 c74508000ddbba mov dword ptr [ebp+8],0BADB0D00h //将操作系统用的标志赋给DbgArgMark804df68e 895d00 mov dword ptr [ebp],ebx //将3环的ebp赋值到DbgEbp804df691 897d04 mov dword ptr [ebp+4],edi //将3环的eip赋值到DbgEip804df694 f6462cff test byte ptr [esi+2Ch],0FFh //判断DebugActive处的值是否为-1804df698 0f858efeffff jne nt!Dr_kss_a (804df52c) //跳转至调试寄存器保存函数804df69e fb sti804df69f e9dd000000 jmp nt!KiFastCallEntry+0x8d (804df781) 来看最后一部分 前6行，很好理解，主要是对_Trap_Frame调试部分的填充，一张图就可以概括 接下来的两行，会比较esi+0x2C的位置是否为-1 这个地方值如果不是-1，说明处于调试状态，紧接着会跳转到Dr_kss_a这个例程里，这个例程作用是将Dr0~Dr7这些调试寄存器的值保存到_Trap_Frame中，用于调试。同样的，了解了这个字段后，我们可以写一个程序，不断的修改这个值，将DebugActive这个值置为-1，这样程序就不会保存调试寄存器，也就无法调试，这是一种反调试的手段。 最后，程序会跳转到KiFastCallEntry+0x8D这个位置继续执行，而这个位置，也是KiFastCallEntry执行完后跳转的地方。之所以分了两种方式，是因为中断门进0环时，压栈了5个值（ESP，EIP，CS，SS，EFLAGS）而快速调用没有，导致它们在填写_Trap_Frame结构的方式不同，但是在填完后，保存现场以后，后面执行的函数就一样了。 KiFastCallEntryKiFastCallEntry保存现场的方式略微发杂，因为没有通过中断门对3环的5个寄存器进行压栈。由于分析的代码较多，这部分就不贴图了，可以参照KiSystemService的方法，在Windbg中找到对应结构进行分析。 KiFastCallEntry要分为两个部分来看，第一个部分，是和KiSystemService所做的一样，对_Trap_Frame结构的填充，进行保存现场。完了之后，第二个部分，从KiFastCallEntry+0x8D开始，这是KiSystemService执行完后跳转的地方，也是KiFastCallEntry顺序执行的地方，是双方都要执行的代码，这也意味着，从这个地方开始，两种进0环的方式就统一了。 本篇只介绍第一部分，看看KiFastCallEntry在填充_Trap_Frame时与KiSystemService有何不同吧。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849kd> u KiFastCallEntry L55nt!KiFastCallEntry:804df6f0 b923000000 mov ecx,23h804df6f5 6a30 push 30h804df6f7 0fa1 pop fs //令fs寄存器指向KPCR首地址804df6f9 8ed9 mov ds,cx //令ds=0x23804df6fb 8ec1 mov es,cx //令es=0x23804df6fd 8b0d40f0dfff mov ecx,dword ptr ds:[0FFDFF040h] //另ecx指向TSS 804df703 8b6104 mov esp,dword ptr [ecx+4] //取TSS中的esp0赋值给当前esp804df706 6a23 push 23h //将3环ss压栈(_Trap_Frame+0x78)804df708 52 push edx //将3环栈顶esp3压栈(+0x74)804df709 9c pushfd //将eflags寄存器压栈(+0x70)804df70a 6a02 push 2 804df70c 83c208 add edx,8 //获取外部第一个参数的位置(ReadProcessMemory共Call804df70c //了两次才到sysenter，因此压栈了2个返回地址，需要+8)804df70f 9d popfd //将2写入eflags寄存器804df710 804c240102 or byte ptr [esp+1],2 //没看懂有啥用804df715 6a1b push 1Bh //将3环cs压栈(+0x6c)804df717 ff350403dfff push dword ptr ds:[0FFDF0304h] //将3环eip压栈(+0x68)804df71d 6a00 push 0 //将Errcode压栈(+0x64)804df71f 55 push ebp //将3环ebp压栈(+0x60)804df720 53 push ebx //将3环ebx压栈(0x5c)804df721 56 push esi //将3环esi压栈(+0x58)804df722 57 push edi //将3环edi压栈(+0x54)804df723 8b1d1cf0dfff mov ebx,dword ptr ds:[0FFDFF01Ch] //将指向KPCR自己的指针存到ebx里804df729 6a3b push 3Bh //将3环fs压栈(+0x50)804df72b 8bb324010000 mov esi,dword ptr [ebx+124h] //将当前线程的KTHREAD存到esi804df731 ff33 push dword ptr [ebx] //将异常链表(ExceptionList)压栈(+0x4c)804df733 c703ffffffff mov dword ptr [ebx],0FFFFFFFFh //更新异常链表的值为-1804df739 8b6e18 mov ebp,dword ptr [esi+18h] //通过KTHREAD的InitialStack更新0环栈底804df73c 6a01 push 1 //将旧的先前模式(PreviousMode)压栈(+0x48)804df73e 83ec48 sub esp,48h //令esp指向_Trap_Frame首地址804df741 81ed9c020000 sub ebp,29Ch //这部分没看懂，舒默的分析是计算初试stack的Trap_Frame基址804df741 //这个0x29c的值等于：NPX_FRAME_LENGTH + TRAP_FRAME_LENGTH804df741 //其中NPX_FRAME_LENGTH = 0x210, TRAP_FRAME_LENGTH = 0x8c804df747 c6864001000001 mov byte ptr [esi+140h],1 //更新先前模式为1804df74e 3bec cmp ebp,esp //比较两个Trap_Frame基址，若不同则跳转去处理804df750 0f8572ffffff jne nt!KiFastCallEntry2+0x24 (804df6c8)804df756 83652c00 and dword ptr [ebp+2Ch],0 //将Dr7的值置0(+0x2c)804df75a f6462cff test byte ptr [esi+2Ch],0FFh //判断当前线程的DebugActive是否为-1804df75e 89ae34010000 mov dword ptr [esi+134h],ebp //更新当前线程的_Trap_Frame基址804df764 0f8546feffff jne nt!Dr_FastCallDrSave (804df5b0)//若DebugActive不为-1则跳转804df76a 8b5d60 mov ebx,dword ptr [ebp+60h] //将3环的Ebp赋值给当前ebx804df76d 8b7d68 mov edi,dword ptr [ebp+68h] //将3环的Eip赋值给当前edi804df770 89550c mov dword ptr [ebp+0Ch],edx //将第一个参数的地址存到DbgArgPointer804df773 c74508000ddbba mov dword ptr [ebp+8],0BADB0D00h //将0x0BADB0D00存到DbgArgMark804df77a 895d00 mov dword ptr [ebp],ebx //将3环ebp存到DbgEbp804df77d 897d04 mov dword ptr [ebp+4],edi //将3环eip存到DbgEip804df780 fb sti //设置EFLAGS的IF位，允许中断发生 这里就先分析到这，至于从KiFastCallEntry+0x8D开始的第二部分，由于是KiSystemService和KiFastCallEntry的公共代码，两种进0环的方式都会执行，就不再本篇中分析了，留到下一篇介绍系统服务表和SSDT时再介绍。 总结这一篇通过学习_Trap_Frame，KTHREAD，KPCR这些结构，分析KiSystemService&KiFastCallEntry了解了在进入0环后，保存现场的方式。尽管采用了两种不同的手段，但是思路总体来说是一样的，就是通过填充Trap_Frame结构完成3环寄存器的保存。在下一篇中，我们将继续探究，在保存完现场后，程序是如何找到想要执行的函数的。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=40 参考文章：https://blog.csdn.net/qq_41988448/article/details/102886413 ​ https://blog.csdn.net/qq_38474570/article/details/103652993","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（3环进0环）","slug":"API函数的调用过程（3环进0环）","date":"2020-03-25T12:40:57.000Z","updated":"2020-03-25T16:44:04.591Z","comments":true,"path":"2020/03/25/API函数的调用过程（3环进0环）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/25/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E8%BF%9B0%E7%8E%AF%EF%BC%89/","excerpt":"","text":"上一篇中分析了ReadProcessMemory函数的3环部分，它实际上没有做太多工作，只是提供了一个调用0环函数的接口，今天我们接着向下分析，看看函数是如何进入0环的。 _KUSER_SHARED_DATA_KUSER_SHARED_DATA结构 上一篇讲到了NtReadVirtualMemory这部分，调用了一个函数地址0x7FFE0300。那这个地址有什么用呢？这就要介绍一个新的结构_KUSER_SHARED_DATA： 在User层和Kernel层分别定义了一个_KUSER_SHARED_DATA结构区域，用于User层和Kernel层共享某些数据 它们使用固定的地址值映射，_KUSER_SHARED_DATA结构区域在User和Kernel层地址分别为： User层地址为：0x7FFE0000 Kernel层地址为：0xFFDF0000 虽然指向的是同一个物理页，但在User层是只读的，在Kernel层是可写的 SystemCall现在我们知道，0x7FFE0000处是_KUSER_SHARED_DATA结构，使用dt指令查看结构，查找0x300偏移处，也就是0x7FFE0300的位置，这个字段是SystemCall 那这个SystemCall有什么用呢？ SystemCall的作用是选择以什么方式进入0环。这要看CPU是否支持sysenter/sysexit 支持：ntdll.dll!KiFastSystemCall() 不支持：ntdll.dll!KiFastSystemCall() 那如何看CPU是否支持sysenter/sysexit指令呢？ （OD打开任一程序）将eax置1（参数） 将ecx，edx置0（方便查看） 执行指令cpuid 查看edx的SEP位（下标11的位置），若值为1，说明支持sysenter/sysexit FBFF -> 1111 1011 1111 1111 说明本机支持sysenter/sysexit KiIntSystemCall进0环在学过调用门，中断门后，我们知道，凡是提权（例如进0环），都伴随着寄存器中的值发生改变，包括CS，SS，EIP，ESP。所以我们分别分析一下两种进0环方式，看看他们是如何修改寄存器的值的，先从KiIntSystemCall开始。 获取提权后寄存器的值 KiIntSystemCall进0环的方式非常简单，就是我们最熟悉中断门。（这里第一条指令的作用是获取参数的首地址） 中断门就很熟悉了，进入IDT表看下0x2E对应的门描述符 根据中断门描述符，可以很快得到： CS = 0x8 EIP = 8053e481 至于SS，和ESP，会在程序提权时，由tr寄存器指向的TSS中的ESP0和SS0提供。 KiSystemService根据EIP的值，0x8053e481我们可以定位到一个内核函数KiSystemService 这样就说明进入0环了，所以KiIntSystemCall进0环非常好理解，就是中断门的知识，进入0环后，就跳转到KiSystemService继续执行，至于如何找到想要执行的函数，会在后面的文章中介绍。接下来我们来看支持sysenter/sysexit的KiFastSystemCall是如何进入0环的。 KiFastSystemCall进0环事实上，基本上现在的CPU都支持sysenter/sysexit，默认也是通过KiFastSystemCall进0环，为什么呢？顾名思义，因为快啊。因为KiFastSystemCall不需要像中断门进0环时，去查IDT表找CS，EIP，查TSS找ESP和SS，而是直接从寄存器里读取这些数据。 获取提权后寄存器的值 来看KiFastSystemCall，只有两行指令。sysenter指令，又称作快速调用，当CPU支持sysenter指令时，操作系统会提前将CS，SS，ESP，EIP写入到MSR寄存器中，当sysenter指令执行时，CPU直接从MSR中将这些值写入相应寄存器中，没有读取内存的过程，所以叫做快速调用。 MSR寄存器由于MSR寄存器非常大，这里不细讲，只列出用到的值 可以通过RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器） 这里读取ESP，EIP，CS的值（SS的值可以通过CS+8计算而得） 这样，在进入0环时，便能通过MSR寄存器切换4个寄存器的值了 KiFastCallEntry前面讲了KiIntSystemCall进入0环后执行KiSystemService，KiFastSystemCall当然也有，执行的是另一个函数，通过MSR得到的EIP我们可以找到函数KiFastCallEntry，同样是内核函数。 这样便成功进入0环了。 总结进0环的过程非常好理解，一种是咱们熟悉的中断门，另一种快速调用，也仅仅是利用了寄存器实现，不是很困难。但是有没有考虑一个问题，我们虽然成功的从3环进入到0环了，那该怎么出来呢？3环程序调用API实现功能，总该返回继续执行程序吧。既然要从0环返回3环，那就得恢复原来的寄存器的值，那么这些值又保存到了哪里呢？除此之外，现在进入了0环了，但又如何找到所要执行的函数呢？带着这些问题，我们继续学习下面的知识。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=39 参考文章：https://blog.csdn.net/qq_41988448/article/details/102825241","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（3环部分）","slug":"API函数的调用过程（3环部分）","date":"2020-03-25T07:09:24.000Z","updated":"2020-03-25T10:15:51.746Z","comments":true,"path":"2020/03/25/API函数的调用过程（3环部分）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/25/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E9%83%A8%E5%88%86%EF%BC%89/","excerpt":"","text":"保护模式暂时告一段落了，接下来开始API函数调用的学习，来一步步分析Windows在调用API的过程中到底做了些什么事，函数到底是如何实现的。 Windows API Application Programming Interface，简称API函数 Windows有多少个API？ 上万个，主要存放在 C:\\WINDOWS\\system32 下面所有的dll中 几个重要的DLL Kernel32.dll：最核心的功能模块， 比如管理内存、进程和线程相关的函数等。 User32.dll：是Windows用户界面相关应用程序接口，如创建窗口和发送消息等。 GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。例如，要显示一个程序窗口，就调用了其中的函数来画这个窗口。 Ntdll.dll：大多数API都会通过这个DLL进入内核（0环）。 分析ReadProcessMemory为了能够直观的了解API的调用过程，我们来分析一个Windows API函数，ReadProcessMemory，这个API函数位于Kernel32.dll，功能是读取指定进程的内存，打开IDA我们来看看它都做了些什么。 ReadProcessMemory在Kernel32.dll中选择导出函数，按下Ctrl+F，然后搜索ReadProcessMemory 找到后进入函数主体 我们可以看到，ReadProcessMemory函数总体分为3个部分，首先是参数的压栈，其次调用了一个函数NtReadVirtualMemory，接着就开始处理函数的返回值了，可以发现，真正读取内存的功能并不是在ReadProcessMemory中实现的，所以我们需要进一步去查看NtReadVirtualMemory。 把鼠标放在NtReadVirtualMemory上，发现该函数是外部函数，不属于Kernel32.dll，所以我们得去Kernel32.dll的导入函数中找一下这个函数属于哪个dll。 可以见得，NtReadVirtualMemory属于Ntdll.dll，接下来进入NtReadVirtualMemory继续分析。 NtReadVirtualMemory找到函数主体的步骤和上面一样，不再赘述。 NtReadVirtualMemory的函数主体部分只有4行，其中最关键的是前两行： mov eax, 0BAh：这一步给eax赋值了一个编号，这个编号的作用是在进入0环后，找到真正需要调用的函数。记住，这个编号存在eax中。 mov edx, 7FFE03000h：这一步同样关键，这是一个函数地址。它决定了进入0环的方式（具体在下一篇中会详细分析），同样，也要记住edx存了这个值。 经过简单的分析，可以发现，在3环层面上， 并没有真正实现函数的功能，API函数的实现，大部分都在0环（只有少部分函数是在3环实现）。拿ReadProcessMemory来说，只是相对于0环给上层提供的一个接口，通过这个接口，我们可以实现读取指定地址的内存 重写API函数现在我们知道，API函数的真正实现实际上是在底层（0环），3环上的API函数实际上只是起到一个接口的作用。那么我们可以自己重写3环的API，自己去调用0环函数，这样做的好处是，可以避免3环恶意挂钩（例如有黑客Hook了OpenFile函数，每次我们调用OpenFile时，黑客就知道我们打开了什么文件，如果重写API函数，黑客就无法通过Hook OpenFile函数来获取我们打开的文件内容，除非黑客在0环动手脚） 实现功能 实现的功能大致如此，读取变量a所在地址的内容，将内容改写后，再写入该地址，先用Windows API提供的ReadProcessMemory和WriteProcessMemory实现一遍。可以看到，原本变量a的值为0x123，随后被修改成了0x567 重写ReadProcessMemory这里以ReadProcessMemory为例，在先前的分析中， 我们知道ReadProcessMemory仅仅做了参数压栈的工作，而NtReadVirutalMemory先给eax赋值了一个编号，接着给edx赋了一个函数地址，并调用此函数，然后平衡堆栈。所以我们只需要将这些功能组合一下即可： c1234567891011121314151617181920212223void _stdcall MyReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead){ _asm { //ReadProcessMemory lea eax, [ebp+0x14] push eax //lpNumberOfBytesRead push [ebp+0x14] //nSize push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtReadVirtualMemory mov eax, 0xBA mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x14 }} 当然，仅仅这样做还不够，这样虽然编译能过，但是执行会报错。因为在ReadProcessMemory中调用NtReadVirutalMemory用了call语句，call语句的使用会导致返回地址压栈，也因此，我们重写的API函数在执行 Code1call dword ptr [edx] 这条语句时，esp处的值为hProcess，而Windows在执行这条语句时，[esp+4]处的值才是hProcess！如果这里不做修改，后面函数返回时，堆栈会不平衡，因此我们需要手动修改一下堆栈： 增加了这两行后，我们自己重写的ReadProcessMemory就算完成了。同理，WriteProcessMemory也是如此。 实验结果 可以看到，我们使用了自己重写的API函数，但是实现了同样的功能。同理，别的函数也可以通过重写，从而防止3环的恶意挂钩。 完整代码c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include \"stdafx.h\"#include void _stdcall MyReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead){ _asm { //ReadProcessMemory lea eax, [ebp+0x14] push eax //lpNumberOfBytesRead push [ebp+0x14] //nSize push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtReadVirtualMemory sub esp, 0x4 //Call NtReadVirtualMemory mov eax, 0xBA mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x18 }}void _stdcall MyWriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesWritten){ _asm { //WriteProcessMemory lea eax, [ebp+0x8] //hProcess push eax //lpNumberOfBytesRead push [ebp+0x14] //NumberOfBytesToWrite push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtWriteVirtualMemory sub esp, 0x4 //Call NtWriteirtualMemory mov eax, 0x115 mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x18 }}int main(int argc, char* argv[]){ int a = 0x123; int buffer = 0; printf(\"Before: a=%x\", a); MyReadProcessMemory(GetCurrentProcess(), &a, &buffer, 4, NULL);// printf(\"%x\", buffer); buffer = 0x567; getchar(); MyWriteProcessMemory(GetCurrentProcess(), &a, &buffer, 4, NULL); printf(\"After: a=%x\\n\", a); getchar(); return 0;} 总结对于API函数的调用过程，我们对三环的部分有了一定的了解，发现，大部分API的实现都是在0环，接下来的文章中，我们就跟进去，找找API函数在0环中的实现在哪。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=37 参考文章：https://blog.csdn.net/qq_41988448/article/details/102786700 参考资料：Joney的笔记，张嘉杰的笔记，XIAOYSHIJI的代码","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"TLB，控制寄存器","slug":"TLB，控制寄存器","date":"2020-03-24T01:14:36.000Z","updated":"2020-03-24T09:53:26.650Z","comments":true,"path":"2020/03/24/TLB，控制寄存器/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/24/TLB%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"","text":"保护模式的内容接近尾声，这一篇文章补充一下琐碎的知识点，下面先从TLB开始 TLB设计原因 假设我们通过一个线性地址访问一个物理页，想要去读取物理页上某个字节。但是实际过程中，并非只读了1个字节，我们需要先读取PDE，再读取PTE，最后再读取存放1个字节的物理页，读取的内容远远超过1个字节了。 在2-9-9-12分页下，会多读24个字节，如果读取的内容跨页了（存在两个不同的物理页上），那多读的字节会更多 为了提高效率，只能通过做记录来进行弥补。 因此CPU内部设计了一个表，用来做记录；由于位于CPU内部，速度和寄存器一样快，当然，表也不能做的过大。这个表叫做TLB（Translation Lookaside Buffer），用于地址解析 TLB结构 LA（线性地址） PA（物理地址） ATTR（属性） LRU（统计） xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 说明： ATTR（属性)：PAE分页，用PDPE&PDE&PTE。10-10-12分页则PDE&PTE 不同CPU的TLB表大小不一样 只要Cr3改变了（说明进程切换了），先前的TLB则会失效，换一套新的TLB，一核一套TLB 由于操作系统中的高2G映射基本不变，如果Cr3改了，直接刷新TLB，对于重建高2G以上的对应关系很浪费，所PDE和PTE中有个标志位G位，刷新TLB时将不会刷新PDE/PTE的G位为1的页。若TLB满了，则CPU会根据统计信息将不常用的地址废弃，保留最近最常用的 注意：只有当PDE的PS位为1时（即当前物理页为大页），G位才有效。 TLB种类TLB在x86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在x86的CPU里，一般都设有如下4组TLB： 缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB） 缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB） 缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB） 缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Instruction-TLB） TLB验证呵呵，这个破实验花了我一下午，我真是太菜了，一个原因是0地址挂物理页，踩了好几次坑，第二个是VC6很多强转不支持，耽误了很多时间。给0地址挂物理页的步骤就不赘述了，这里采用的10-10-12分页，只是采用了代码挂物理页的方式，具体可以参考基址小实验这一篇，这里就讲讲验证的过程。 我们先给0地址挂上第一个地址（0x425000，这是我随便选的，选错了可能蓝屏）的物理页，然后取0地址的处的置，发现值为0。 这时，我们注释掉给0地址挂第一个地址（0x425000）的物理页的代码，并给0地址挂第二个地址（0x426000）的物理页。这时再取0地址处的值，发现值为0x43，可以发现，这两个线性地址所对应的物理页上的值是不同的。 这时我们把上面的注释拿掉，先给0地址挂第一个地址的物理页，然后再给0地址挂第二个地址的物理页，按照道理，这时我们取到的值应该是第二个地址对应物理页上的值，我们来查看结果： 神奇的事情发生了，我们取到的仍然是第一个地址对应物理页上的值，这其实就是TLB的作用。 这时，我们增加一条语句 Code1invlpg dword ptr ds:[0] 再次运行程序发现，仅仅多了这一条语句，读取0地址的值，就变成了第二个地址对应物理页上的值，Invlpg是让指定页TLB无效化的指令，因此再次访问时，原先的TLB已经被废弃，就需要重新去物理页读取，此时0地址对应的物理页已经是第二个地址的物理页了。当然，除了使用Invlpg指令，修改Cr3也可以做到让TLB无效化。 下面附上完整代码 c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include \"stdafx.h\"#include DWORD phyAddr, phyAddr2, temp;__declspec(naked) Test() { _asm { pushad pushfd } phyAddr = (DWORD)(0xc0000000 + ((0x425000 >> 0xa) & 0x3ffffc)); phyAddr2 = (DWORD)(0xc0000000 + ((0x426000 >> 0xa) & 0x3ffffc)); _asm{ mov eax, phyAddr mov eax, [eax] mov dword ptr ds:[0xc0000000], eax mov eax, dword ptr ds:[0] mov temp, eax// invlpg dword ptr ds:[0] 无效化指定页的TLB// mov eax, cr3 切换Cr3来清空TLB// mov cr3, eax mov eax, phyAddr2 mov eax, [eax] mov dword ptr ds:[0xc0000000], eax mov eax, dword ptr ds:[0] mov temp, eax } _asm{ popfd popad retf }}int main(int argc, char* argv[]){ char buffer[] = {0, 0, 0, 0, 0x4B, 0}; _asm call fword ptr buffer printf(\"temp: %x\", temp); getchar(); return 0;} 控制寄存器说完了TLB，来说说控制寄存器。控制寄存器的作用主要是用于控制和确定CPU的操作模式。主要包括Cr0，Cr1，Cr2，Cr3，Cr4，其中Cr1保留。 Cr0寄存器Cr0寄存器，主要包括一些控制操作系统模式以及处理器状态的控制标志位。 这里介绍几个主要的标志位，其余位的描述可以参考Intel白皮书第三卷系统架构综述那章。 PE：Cr0下标为0的位是启用保护（Protection Enable）标志。PE=1保护模式，PE=0实地址模式，这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。 PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。 PG=0且PE=0：处理器工作在实地址模式下 PG=0且PE=1：处理器工作在没有开启分页机制的保护模式下（不存在这样的操作系统） PG=1且PE=0：在PE没有开启的情况下 无法开启PG PG=1且PE=1：处理器工作在开启了分页机制的保护模式下 WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志，当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作。 对于Ring0的特权级程序，如果WP=0，可以读写任意用户级物理页，只要线性地址有效 对于Ring0的特权级程序，如果 WP=1 可以读取任意用户级物理页，但对于只读的物理页，则不能写 Cr2寄存器Cr2寄存器，保存导致缺页异常的线性地址。 之前在中断与异常中，简要概括了缺页异常，当CPU访问某个无效页面，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在Cr2中，以便操作系统处理完缺页异常后，返回到原本执行的位置继续执行。 Cr3寄存器Cr3我们太熟悉了，在10-10-12分页是页目录表基址，在PAE分页下，则是页目录指针表基址 这里有两个属性，PWT和PCD之前在页的部分一直没有讲，在介绍之前，先来了解一个概念，叫做CPU缓存 CPU缓存 CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多，但是交换速度远快于内存。 CPU缓存可以做的很大，从几K，几十K，几百K，甚至上M。 CPU缓存与TLB的区别： TLB：线性地址 物理地址 CPU缓存： 物理地址 内存 有了CPU缓存和TLB的概念后，就可以来讲讲PWT和PCD这俩属性了。 PWT(Page Write Through) PWT = 1时，CPU向cache写入数据时，同时向memory也写一份，使cache和memory的数据保持一致。优点是简单，缺点是每次都要访问memory，速度比较慢，即Write Through。 PWT = 0时，CPU向cache写入数据时，不将数据写入内存中，分为两种情况： Post Write：CPU更新cache数据时，把更新的数据写入到一个更新缓冲器，在合适的时候才对memory进行更新。这样可以提高cache访问速度，但是，在数据连续被更新两次以上的时候，缓冲区将不够使用，被迫同时更新memory。 Write Back：CPU更新cache时，只是把更新的cache区标记一下，并不同步更新memory。只是在cache区要被新进入的数据取代时，才更新memory。这样做的原因是考虑到很多时候cache存入的是中间结果，没有必要同步更新memory。优点是CPU执行的效率提高，缺点是实现起来技术比较复杂。 PCD(Page Cache Disable) PCD = 1时，禁止某个页写入缓存，直接写入内存。例如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。 PCD = 0时，不限制页写入缓存，可以参考上面PWT的情况。 Cr4寄存器Cr2寄存器，保存了一组启用多种架构扩展的标志位 这里简单概括一下PAE位和PSE位： PAE：置1时，是PAE分页；置0时，是10-10-12分页。之前在boot.ini中设置execute/noexecute的作用就是修改PAE位 PSE：控制PDE中PS位的开关，当PSE置1时，PS位才有效。具体如下： 控制寄存器小节除了上述介绍的，还有一个Cr8寄存器，仅仅在64位下才存在，这里就不作介绍了，其余寄存器总览如下： 参考文章1：https://blog.csdn.net/wyzxg/article/details/7254458 参考文章2：https://blog.csdn.net/q1007729991/article/details/53000410 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=33","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"中断与异常","slug":"中断与异常","date":"2020-03-23T14:37:48.000Z","updated":"2020-03-24T12:48:08.406Z","comments":true,"path":"2020/03/23/中断与异常/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/23/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/","excerpt":"","text":"段和页的主要知识，差不多就告一段落了，这篇文章简单介绍一下中断与异常的相关概念，结合之前学习的IDT表，形成一个整体的框架，在后续文章中，会再详细解析中断和异常的处理过程。 中断什么是中断 中断通常是由CPU外部的输入输出设别（硬件）所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫做中断请求（IRQ-Interrupt Request） 中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程（中断处理程序在哪由IDT表决定） 80x86有两条中断请求线： 不可屏蔽中断线，称为NMI（NonMaskable Interrupt） 可屏蔽中断线，称为INTR（Interrupt Require） 不可屏蔽中断 （IDT表）中断号 NMI 说明 0x2 不可屏蔽中断 80x86中固定为0x2 说明： 当不可屏蔽中断产生时，CPU在执行完当前指令后会立即进入2号中断，执行相应中断处理程序 不可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理 可屏蔽中断在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求。为了便于标识各个中断请求，中断控制器通常用IRQ（Interrupt Request）后面加上数字来表示不同的中断。 例如：在Windows中，时钟中断的IRQ编号为0，也就是：IRQ0 （IDT表）中断号 IRQ 说明 0x30 IRQ0 时钟中断 0x31~0x3F IRQ1~IRQ15 其它硬件设备的中断 说明： 如果自己的程序执行时不希望CPU去处理这些中断，可以用CLI指令清空EFLAG寄存器中的IF位。与CLI指令相反，STI指令可以用来设置EFLAG寄存器中的IF位 硬件中断与IDT表中的对应关系并且固定不变的，参见APIC（高级可编程中断控制器） 异常聊完了中断，来看看异常。异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。 与中断的区别 中断来自于外部设备，是中断源（例如键盘）发起的，CPU是被动的。 异常来自于CPU本身，是CPU主动产生的。 INT N虽然被称为“软件中断”，但其本质是异常。因此不受EFLAG的IF位影响。 异常处理无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。 上图为IDT表中常见的中断向量号的相关描述，具体细节可以参考Intel白皮书第三卷（Exception And Interrupt Reference）这章 缺页异常（无时无刻不在发生）缺页异常产生： 当PDE/PTE的P=0时 当PDE/PTE的属性为只读，但程序试图写入时 一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统接管。 这里简单概括上述两种发生缺页异常的情况： 在操作系统中，物理页往往是紧缺的，若当前PTE指向的物理页的内容一段时间没有被访问，则会将这个物理页上的内容存到一个文件里，同时将这个物理页挂给有需要的PTE用，并将原PTE的P位置0。当程序再次访问这段内容时，发现P位为0，则会触发缺页异常，但是此时PTE下标为10,11的位置均为0，其余位置都是有值的，这种情况说明当前PTE指向的内容存到了文件中，并根据下标1~4指定的偏移，在文件中找到内容。这时再重新给这些内容挂上新的物理页，将P位改为1，这时访问便可正常执行。当然，缺页异常对于用户来说是透明的，用户只会觉得自己正常访问了某个内容，但实际上进行了很多操作，通过缺页异常，操作系统可以节省大量物理页。 当PDE/PTE属性为只读时，CPU不会进行处理，而是跳到E号中断交给操作系统来处理，操作系统发现程序正在尝试写一个只读的物理页，会返回一个C0000005错误。 异常小节当异常发生时，CPU会判断异常的种类，根据中断向量号，跳转到相应的异常处理程序，接着由操作系统接管并处理。 总结这篇简要介绍了中断与异常，在后续讲到中断章节时，会更加详细的分析过程原理。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=32","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"2-9-9-12分页","slug":"2-9-9-12分页","date":"2020-03-22T06:53:29.000Z","updated":"2020-03-23T07:36:10.904Z","comments":true,"path":"2020/03/22/2-9-9-12分页/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/22/2-9-9-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"在前面的文章中主要介绍了10-10-12分页方式，在这种分页方式下，物理地址最多可达4GB。随着硬件发展，4GB的物理地址范围已经无法满足要求，于是Intel设计了一种新的分页方式：2-9-9-12分页（又称PAE）分页。下面就来了解一下这种分页方式是如何运作的吧。 PAE分页为什么是2-9-9-12PAE（Physical Address Extension，物理地址扩展）页，一定会涉及到2个结构，就是PDE和PTE。以PTE来说，它可以直接定位到某个物理页上的物理地址，在10-10-12分页下，由于PTE的大小是4字节(32位)，因此PTE能够寻址的范围仅有4GB。设想，若PTE有33位，那便可以寻址8GB；34位就能寻址16GB……以此类推。Intel考虑到对齐的因素，就干脆直接让PTE的长度达到64位了。这样一个PTE的大小就8字节，又因为一个PTT表的大小是4KB(4096字节)，因此原本一个PTT表里能装下1024个4字节的PTE，现在只能装下512个8字节的PTE了。2的9次方等于512，所以PTI的值为9。 同理，PDI的值也为9，这样2-9-9-12中还剩下最前面的2位。 设置PAE分页设置PAE分页比较简单，进入C盘打开boot.ini文件修改启动项，将execute改成noexecute即可，然后重启虚拟机即可进入PAE分页。 PDPTEPDPTE（Paga-Directory-Point-Table Entry）页目录指针表项，顾名思义，这是一个指向PDT表（在10-10-12分页下，Cr3指向PDT表的首地址）的元素，且位于PDPT表（PAE分页下Cr3指向PDPT表首地址）中。由于仅剩2位，所以PDPTE只有4个，同样PDPTE每项占8个字节，来看下这个结构。 Avail：下标9~11，共3位，这是留给操作系统使用的位，CPU本身并不使用 Base Address：下标12~35，寻址时，低12位补0，共36位（达到36位，与PTE保持一致，寻址空间达到64GB），即PDT基址 至于PCD和PWT，留到控制寄存器和TLB部分详解。 PDEPAE分页下，PDE扩展到了64位，其余属性变化不大。 PS = 1：大页，下标35-21是大页的物理地址，低21位填0，大页的大小为2MB（10-10-12的大页为4MB），按照2MB对齐。 PS = 0：下标35~12是页表（PTT）基址，低12位补0，共36位。 Avail：同PDPTE PTE与PDE一样，PAE分页下的PTE，也是扩展到了64位，其余变化不大 PTE中下标35-12是物理页基址，共24位（10-10-12分页下是下标31~12，共20位），低12位补0。 物理页基址+12位的页内偏移指向具体数据。 在了解这些结构后，来看一下PAE分页的大致模型 XD位在Intel新系列的CPU中，在下标63的地方多了一个属性位XD位（AMD中称为NX，即No Execetion） 我们知道段的属性有可读、可写和可执行，但是页的属性只有可读、可写。 当ret执行返回语句时，如果堆栈里的数据指向一个提前准备好的数据（把数据当作代码来执行，漏洞很多都是依赖这点，比如SQL注入），这个位的作用就是在硬件上实现一种保护，防止数据可执行的情况发生。 查找物理页PAE分页下查找对应的物理页和10-10-12差不多，拆分线性地址后，再根据PDPI、PDI、PTI偏移去找，由于每项均是8字节，所以在Windbg中使用dq指令进行查看。来看下面这个例子： 变量a的线性地址为：0x12ff7c。按照2-9-9-12进行拆分后得到0-0-12f-f7c。接着通过Cr3一步步查找，具体如下： 变量a的存的值为0x123，通过拆分线性地址，成功在找到变量a对应的物理地址。 0地址挂物理页在学习10-10-12分页时，通过0地址挂物理页的实验，加深对物理页的理解，这里我们通过这个实验进一步熟悉PAE分页。 先运行程序，发现访问违例，运行失败 查看0地址对应的物理页，发现物理页是空的。 然后查看局部变量a对应的物理页，并将a对应的物理页挂到0的位置（注意，挂物理页时，用两次!ed指令而不是!eq指令） 接着运行程序发现可以正确的打印出0地址上的内容 PAE分页下PDT/PTT的基址新增加的结构，PDPTE，并没有R/W位，US位等属性，真正决定物理页属性的还是PDE和PTE。相比10-10-12分页可以通过PDT/PTT基址修改物理页属性，在PAE分页下同样可以做到，这部分我们来研究下PAE分页下PDT和PTT的基址。 逆向分析MmIsAddressValid在前一篇文章中我们分析了10-10-12分页下的MmIsAddressValid函数，它在找到PDE/PTE后会判断下标为0(P位)和下标为7(PDE对应PS位，PTE对应PAT位)的位置的值，进行一些处理工作。而这个函数找到PDE/PTE的过程就使用了PDT/PTT的基址。这次通过分析PAE分页下的MmIsAddressValid函数，来找到PAE分页下PDT/PTT基址。 先分析查找PDE的部分 Code12345678910111213141580511987 8b4d08 mov ecx,dword ptr [ebp+8] //获取参数8051198a 56 push esi 8051198b 8bc1 mov eax,ecx8051198d c1e812 shr eax,12h //右移18位80511990 bef83f0000 mov esi,3FF8h 80511995 23c6 and eax,esi //进行与运算，余下11位有效位80511997 2d0000a03f sub eax,3FA00000h //相当于add eax, 0xC06000008051199c 8b10 mov edx,dword ptr [eax] //取PDE低四字节8051199e 8b4004 mov eax,dword ptr [eax+4] //取PDE高四字节805119a1 8945fc mov dword ptr [ebp-4],eax //高四字节保存到局部变量805119a4 8bc2 mov eax,edx805119a6 57 push edi //保存edi原本的值805119a7 83e001 and eax,1 //保留P位的值805119aa 33ff xor edi,edi805119ac 0bc7 or eax,edi 右移18位后，进行了一次与运算，保留的位相当于PDPI x 4KB + PDI x 8（看不明白的可以参考这篇） sub eax, 0x3FA00000和add eax, 0xC0600000，因此可以推测，PAE分页下PDT的基址为0xC0600000 接着分析查找PTE的部分 Code123456789101112805119c3 c1e909 shr ecx,9 //右移9位805119c6 81e1f8ff7f00 and ecx,7FFFF8h //进行与运算，余下20位有效位805119cc 8b81040000c0 mov eax,dword ptr [ecx-3FFFFFFCh] //相当于mov eax, [ecx+0xC0000004]805119d2 81e900000040 sub ecx,40000000h //相当于add ecx, 0xC0000000805119d8 8b11 mov edx,dword ptr [ecx] //取PTE低四字节805119da 8945fc mov dword ptr [ebp-4],eax //将PTE高四字节保存至局部变量805119dd 53 push ebx //保存ebx原本的值805119de 8bc2 mov eax,edx 805119e0 33db xor ebx,ebx 805119e2 83e001 and eax,1 //保留P位的值805119e5 0bc3 or eax,ebx805119e7 5b pop ebx 重点还是在与运算这，右移9位后跟0x7FFFF8进行与运算，相当于PDPI x 2MB + PDI x 4KB + PTI x 8 sub ecx，0x40000000相当于add ecx, 0xC0000000，可以推测，PAE分页下PTT的基址仍然为0xC0000000 公式总结根据MmIsAddressValid函数，可以得到PAE分页下PDT和PTT的基址分别为0xC0600000和0xC0000000。 我们可以采纳MmIsAddressValid的方法总结出找到任意一个PDE /PTE的公式： 利用MmIsAddressValid内的手法 c12pPDE = (int*)(0xc0600000 + ((addr >> 18) & 0x3ff8))pPTE = (int*)(0xc0000000 + ((addr >> 9) & 0x7ffff8)) 通过拆分线性地址 c12pPDE = (int*)(0xc0600000 + (PDPTI","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"逆向分析MmIsAddressValid(10-10-12)","slug":"逆向分析MmIsAddressValid","date":"2020-03-21T03:07:40.000Z","updated":"2020-03-21T08:36:14.300Z","comments":true,"path":"2020/03/21/逆向分析MmIsAddressValid/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/21/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid/","excerpt":"","text":"在对页表基址，页目录表基址熟练掌握后，今天来看逆向分析一个函数：MmIsAddressValid。这是一个系统函数，可以在ntoskrnl.exe的导出函数中找到它，也可以在Windbg中输入指令 Code1kd> u MmIsAddressValid 查看。 为什么要分析这个函数呢？因为即使是系统函数，也是无法直接使用物理页的，想要去访问PDE和PTE也就一定要通过基址来访问，而今天要分析的MmIsAddressValid函数，就利用了这么一个原理，相比前一篇的基址小实验，这里对于线性地址拆分的过程更为巧妙，让我们一起来看看吧！ 获取PDE属性 首先观察函数主体部分，发现代码并不长，但是有很多跳转，具体跳转内容就不作分析了，主要是分析函数主体： Code1234567891011121314804e4661 8bff mov edi,edi //hotpatch804e4663 55 push ebp804e4664 8bec mov ebp,esp804e4666 8b4d08 mov ecx,dword ptr [ebp+8] //取第一个参数（线性地址）804e4669 8bc1 mov eax,ecx //赋值到中间变量，方便运算804e466b c1e814 shr eax,14h //逻辑右移20位804e466e bafc0f0000 mov edx,0FFCh 804e4673 23c2 and eax,edx //和操作数进行与运算，同时清空最后2位；相当于做了一个乘4的运算，既左移2位804e4675 2d0000d03f sub eax,3FD00000h //进行减法运算，相当于eax+0xC0300000804e467a 8b00 mov eax,dword ptr [eax] //取PDE的值804e467c a801 test al,1 //判断PDE属性P位是否为1804e467e 0f84d2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e4684 84c0 test al,al //判断下标为7的位(PS位)值是否为1804e4686 7824 js nt!MmIsAddressValid+0x53 (804e46ac) 巧妙的与运算： 首先将线性地址逻辑右移20位，此时还余下12位 将这12位和操作数0xFFC做一个与运算，0xFFC换算成2进制就是1111 1111 1100。因此做完与运算后，刚刚经过第一步操作还剩下12位的数的低2位，置0了。熟悉移位运算的朋友们知道，这个12位的数，相当于1个10位的数逻辑左移2位得到，换句话说就是将这个10位的数乘4。而这个10位，就是PDI，因此这步操作完了以后，相当于我们获得了PDI*4的值。 接下来，与0x3FD00000做减法运算，作用相当于加上0xC0300000，两种方法的结果是一样的。因此，我们得到了0xC0300000 + PDI*4的值，而这个值，恰恰就是我们要找的PDE，接着只需要取出里面的值，就可以获取PDE的属性了 后续跳转再获取PDE的属性后，会遇到两个跳转，简单的概括下： 首先会判断PDE下标为0的位置的值，也就是P位，当P位为0时，说明物理页无效，会跳转到一个相应的处理函数，这里就不再跟进分析 若物理页P位为1，就会来到第二个跳转，这里test al, al指令会修改标志寄存器，当al的最高位，也就是下标为7的位置值为1时，会被认为是负数，此时会修改EFLAG寄存器的SF位。这时，在第二个跳转的位置，js判断的就是SF的值是否为1，若为1，也就是al下标为7的位置值为1，这是对应的PDE属性PS位，说明这是一个4MB的大页，进而会跳转执行相应的处理函数。 获取PTE属性Code123456789101112804e4688 c1e90a shr ecx,0Ah //逻辑右移10位804e468b 81e1fcff3f00 and ecx,3FFFFCh //和操作数进行与运算，同时清空最后2位，相当于PDI左移12位+PTI左移2位804e4691 81e900000040 sub ecx,40000000h //进行减法运算，相当于eax+0xC0000000804e4697 8bc1 mov eax,ecx804e4699 8b08 mov ecx,dword ptr [eax] //获取PTE属性804e469b f6c101 test cl,1 //判断P位的值是否为0804e469e 0f84b2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e46a4 84c9 test cl,cl //判断PAT是值是否为1804e46a6 0f88b6de0300 js nt!MmIsAddressValid+0x3f (80522562)804e46ac b001 mov al,1804e46ae 5d pop ebp804e46af c20400 ret 4 巧妙的与运算Code1and ecx, 3FFFFCh 假设线性地址右移10位后的值为 0000 0000 00aa aaaa aaaa bbbb bbbb bbxx（a, b的值为0或者1，这里只是为了区分PDI和PTI） 然后我们来拆分0x3FFFFC的值：0000 0000 0011 1111 1111 1111 1111 1100 将两者进行与运算后得到结果为 0000 0000 00aa aaaa aaaa bbbb bbbb bb00 我们知道，aa aaaa aaaa应为PDI，而bb bbbb bbbb应为PTI，因此可以把得到的结果看作是这样的一个运算：$$aa aaaa aaaa","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"基址小实验（10-10-12）","slug":"基址小实验","date":"2020-03-20T15:14:53.000Z","updated":"2020-03-22T16:36:37.983Z","comments":true,"path":"2020/03/20/基址小实验/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/20/%E5%9F%BA%E5%9D%80%E5%B0%8F%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"在学习完页目录表基址，页表基址后，我们知道通过C0300000和C0000000这两个地址，可以访问相应的PDE和PTE，今天就来实践一下。 之前在介绍PDE/PTE属性R/W位时有过一个实验，是对位于常量区的内容进行修改，当时通过Windbg修改了所在PDE/PTE的R/W位。这次实验，我们利用页目录表/页表基址来进行修改。 测试原始代码 首先测试原始代码，发现直接修改常量区的字符串，是会失败的 提权进入0环提权这里还是会用到Windbg，根据调用函数的地址，填入段选择子，并通过调用门进行提权（就当复习调用门知识了） 修改R/W位提权进入0环后（为啥要提权呢？因为C0300000/C0000000都属于高2G的线性地址，3环没法直接访问），就到了我们最关键的步骤了，修改R/W位。 c123456temp = *(int*)0xC0300004;temp = temp|0x2;*(int*)0xC0300004 = temp;temp = *(int*)0xC000108C;temp = temp|0x2;*(int*)0xC000108C = temp; 在这之前声明了一个中间变量temp（int类型）。 具体步骤： 打印出字符串所在常量区的地址0x423fb0，进行拆分：10-10-12 -> 0x1-0x23-0xfb0 PDI = 0x1，带入公式：PDE = C0300000 + 0x1 x 4 PTI = 0x23，带入公式：PTE = C0000000 + 0x1 x 1000 + 0x23 x 4 分别取PDE和PTE处的值，并和0x2进行或运算（将R/W位置1） 这样就完成了对R/W位的修改，在接下来再次对常量区的值进行修改操作时，便可以成功。 完整代码c123456789101112131415161718192021222324252627282930313233343536373839#include \"stdafx.h\"int temp;__declspec(naked) void ModifyRW() { __asm { pushad pushfd } temp = *(int*)0xC0300004; temp = temp|0x2; *(int*)0xC0300004 = temp; temp = *(int*)0xC000108C; temp = temp|0x2; *(int*)0xC000108C = temp; __asm { popfd popad retf }}int main(int argc, char* argv[]){ char* str = \"hello\"; char buffer[6] = {0, 0, 0, 0, 0x4B, 0}; printf(\"addr: %x, str: %s\", str, str); getchar(); _asm { call fword ptr buffer } *str = 'a'; printf(\"str: %s\", str); getchar(); return 0;}","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"页目录表、页表基址","slug":"页目录表、页表基址","date":"2020-03-20T07:11:51.000Z","updated":"2020-03-20T14:22:35.004Z","comments":true,"path":"2020/03/20/页目录表、页表基址/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/20/%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E3%80%81%E9%A1%B5%E8%A1%A8%E5%9F%BA%E5%9D%80/","excerpt":"","text":"考虑这样一个问题，我们现在可以通过在Windbg里找到线性地址所在的物理页，通过修改物理页的属性，就可以实现一些原本受限的功能。例如将常量区对应的物理页R/W属性修改为1，便可以修改位于常量区的元素。 但是，以上操作都是基于Windbg在双击调试的环境中实现的，那么一旦脱离了调试器，该如何通过代码来实现对物理页属性的修改呢？这就需要借助于页目录表基址和页表基址了。 页目录表基址结论：C0300000就是页目录表基址，接下来我们来验证这个结论。 C0300000拆分C0300000： 1100 0000 0011 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 11 0000 0000 300 12 0000 0000 0000 0 Cr3这里以记事本(notepad.exe)为例，来验证一下，C0300000就是页目录表基址，首先查看记事本对应的Cr3指向的物理地址。 我们知道，Cr3指向的是PDT的首地址，这里可以看到4个PDE有值。 查看C0300000物理页接下来的步骤就是比较熟悉的，根据拆分后的线性地址，寻找物理页的过程了。但是这一次，要慢点看。 这一步很容易理解，Cr3.base + 300*4，通过Cr3和线性地址的前10位，我们找到了PDE的值：7ea49063 什么？又重复了一遍？实际上不是，由于PDE的值为7ea49063，后12位是属性位，因此，7ea49000是我们要找的PTT的首地址，然后通过PTT.base + 300*4，就得到了PTE的值：7ea49063。 有了PTE的值，加上最后12位的偏移（此处为0），就可以找到物理页。 得到结果后，是不是很惊讶？C0300000这个线性地址对应的物理页上的物理地址，竟然和Cr3指向的物理地址完全一样！也就是说，以后不需要Cr3，只需在当前程序内，通过C0300000这个线性地址就可以得到当前程序PDT的首地址了 如何利用是啊，C0300000这个地址有啥用呢？当然有用，而且非常有用。回到文章开头的问题，我们该如何在不使用Windbg的情况下，修改物理页的属性呢？ 我们知道，想要修改物理页的属性，需要先修改物理页对应的PDE和PTE，那要如何找到PDE和PTE呢，由于在编写代码时，用到的都是线性地址，而C0300000这个线性地址刚好就可以找到PDT的首地址，这样我们拆分想要修改的物理页属性的线性地址，将前10位加上C0300000即可找到对应的PDE。 既然PDE找到了，那不就有了PTT的首地址，这样PTE不也就可以找到了吗？并不是这样，尽管找到了PDE，但是由于PDE里面存着的是物理地址，如果直接访问PDE里面存的那个地址，在代码中会转变为一个线性地址，因此并不能通过PDE获取PTT的首地址，也就不能获取到PTE了，想要找到PTE，还得需要用到另外一个基地址，就是页表基址。 页表基址还是直接上结论，页表基址：C0000000 接下来我们来验证。 C0000000拆分C0000000： 1100 0000 0000 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 00 0000 0000 0 12 0000 0000 0000 0 Cr3这里还是以记事本(notepad.exe)为例： 我们查看Cr3指向的物理地址，当前共有4个PDE的有值的，而PDE的值，就是PTT的首地址，以第一个PDE（36c24067）为例，其中PTT的首地址为36c24000。 查看C0000000物理页步骤和之前一样，就直接看结果好了。 发现，C0000000这个线性地址所对应的物理页，刚好是36c24000，也就是第一个PDE对应的PTT的首地址。由此可以进一步推断，C0001000则是第二个PDE对应的PTT的首地址，以此类推。 再看10-10-12分页现在再来看10-10-12分页时，看法就会有所不一样了。 实际上页表（PTT）被映射到了从0xC0000000到0xC03FFFFF的4M地址空间 在这1024个表中有一张特殊的表：页目录表（PDT） 页目录表（PDT）被映射到了0xC030000开始处的4KB大小的地址空间 总结有了0xC0300000和0xC0000000能做什么？掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。 公式总结： 什么是PDI和PTI？ 将32位线性地址拆分位10(PDI)-10(PTI)-12 访问页目录表(PDT)的公式：0xC0300000 + PDI x 4 访问页表(PTT)的公式：0xC0000000 + PDI x 1000 + PTI x 4（不用*号因为会被转义） 其它关于页的细节 高2G有一些大页，即4MB页 两个进程低2G几乎不同，高2G几乎相同 一个进程低2G的内存空间，前64K与后64K是没有使用的（线性地址0 - 00010000 与 7FFF0000 - 7FFFFFFFF） 谁填充了这些表呢进程本身可以通过0xC0300000和0xC0000000访问修改任意物理页，那么是谁为我们填充0xC0300000和0xC0000000的PDE与PTE呢？ 进程的创建过程：当创建B进程时，先在A进程中将B进程所有信息全部构建好，然后切换Cr3即可。也就是说，最开始的这张表是由A进程填充的。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"PDE_PTE属性（部分）","slug":"PDE-PTE属性","date":"2020-03-19T12:37:33.000Z","updated":"2020-03-19T15:51:12.795Z","comments":true,"path":"2020/03/19/PDE-PTE属性/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/19/PDE-PTE%E5%B1%9E%E6%80%A7/","excerpt":"","text":"上一篇文章中了解了PDE和PTE，这一篇就来了解一下PDE和PTE的属性。 物理页的属性 一上来看这张图，肯定是一脸懵逼的。先从行开始看，第一行是关于CR3寄存器的，这部分留到控制寄存器的章节再分析。接下来三行是不同类型PDE的，最后两行是PTE的。其中PDE和PTE有很多属性是重合的。而物理页的属性，就是有PDE和PTE共同决定的。计算方法是将相同属性位的值进行与运算。 物理页的属性 = PDE属性 & PTE属性 P位 首先来看P（Present）位：存在位。PDE与PTE的P位均位1时，物理页有效；其余情况，物理页不存在。这也解释了为什么PDE的第三行和PTE的第二行可以直接忽略。 在上一篇文章中，有一个关于0地址赋值的实验。0地址之所以不能赋值是因为它的PTE的P位为0，在我们修改了PTE的P位，并给它挂上一个物理页后，0地址遍可以赋值了。 R/W位 R/W = 0 只读 R/W = 1 可读可写 R/W很好理解，控制写的权限呗，这个位有何用呢？来看一个小实验。 c123456789101112131415#include \"stdafx.h\"int main(int argc, char* argv[]){ char* str = \"hello\"; printf(\"%x\", str); getchar(); *str = 'a'; printf(\"%s\", str); getchar(); return 0;} 来看这个代码，很明显，执行会是失败的，因为用char*定义的字符串，是会存储在常量区，而不是堆栈中了，又因为常量区的值是不允许修改的，因此 c1*str = 'a'; 这条语句会执行失败并报错。 那为什么常量区的内容就不可修改呢？其实，说白了，就是常量区挂着的物理页的R/W属性为0，因此只能读，不可写，既然知道了原因，我们只要修改了常量区所在物理页的属性，将R/W位置1即可。 通过printf语句先打印出所在常量区的线性地址，接着拆分跟进PDE和PTE中（具体步骤省略） 可以发现，PTE的R/W位值为0，因此将其修改为1写入，随后运行程序发现，可以成功修改字符串首地址出的字符！ P/S位 P/S（PageSize）位，只对PDE有意义，位于PDE的第7位。 PS = 1 PDE直接指向物理页，无PTE，低22位为页内偏移。线性地址只能拆成两段（10-22）：页的大小为2的22次方，也就是4MB，俗称“大页”，大页比较少，一般出现在高2G中 PS = 0 就是我们比较熟悉的10-10-12分页，页的大小为4KB U/S位 U/S（User/System）位，位于PDE/PTE的第2位。 U/S = 0：特权用户 U/S = 1：普通用户 三环程序是不能读写高2G内存的，原因在于高2G内存对应的物理页U/S位被置0了，也就是说只有特权用户才能读写高2G的内存。所以，当普通用户想要读取高2G内存时，就可以把U/S置1，这样就可以访问高2G内存了。 当然，理论如此，不过除了U/S位外，影响高2G内存读写的还有PCD位和PWT位，这部分内容也要到控制寄存器部分才能讲，所以第二种3环程序读写高2G实验（第一种是通过门提权），就要放到后面实现了，这里只要先记住，U/S位是影响访问读写权限的。 与R/W的区别这里需要注意一下U/S位与R/W位的区别，U/S位的读写控制是根据用户的级别，而R/W位的控制是直接控制读写，不管你是不是特权用户。 A位 A（Accessed）位于PDE/PTE的第5位：表示该物理页是否被访问（读或者写）过，访问过置1，即使只访问一个字节也会导致PDE，PTE置1。 D位 D（Dirty），脏位，是否被写过。0表示没有被写过，1表示被写过 总结以上是关于PDE/PTE部分属性的含义，还有一部分位没有涉及到，例如G位，PWT位，PCD位，这些需要讲到控制寄存器和TLB相关概念时再细讲。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"10-10-12分页","slug":"10-10-12分页","date":"2020-03-18T12:55:20.000Z","updated":"2020-03-19T13:43:58.205Z","comments":true,"path":"2020/03/18/10-10-12分页/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/18/10-10-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"保护模式下内存管理方式分为两种，段与页。前面的篇章中，简要介绍了段的知识，今天就来和大家聊聊页的知识，页是保护模式中更为重要的一环，随着系统进入32-Bit，段的作用明显降低了，取而代之的则是在段的基础上，更为细分的页。 段与页 这是Intel白皮书中介绍关于段与页的概要图，经过段的学习，可以很容易的理解左半部分，这是一个根据所提供的有效地址（图中Offset）以及段寄存器中确定的基址，锁定线性地址空间中的某个线性地址（图中Lin.Addr.）的过程。而右半部分，则是利用了页的功能，通过拆分线性地址，一步步转化成了物理地址。 上述提到了3个概念，有效地址，线性地址以及物理地址，文字叙述会让人混淆，我们来看一条语句： Code1mov dword ptr ds:[0x12345678], 0x123 其中，0x12345678是有效地址 ds.Base + 0x12345678是线性地址 这都非常好理解，那什么是物理地址呢？考虑这样一个问题，掌握3环知识的小伙伴们知道每个进程都有4GB的内存空间，这时如果有一个进程A，给会进行一个操作，给ds.Base + 0x12345678赋值0x123，还有一个进程B，同样会给ds.Base + 0x12345678赋值0x123，那么ds.Base + 0x12345678处的位置到底是哪个值呢？还是两者都不是呢？这就涉及到了物理地址的概念。 PDT与PTT每个进程都有一个CR3的值，这很突兀，CR3是什么？实际之前在TSS切换时也用到了，具体等到了控制寄存器那会详细分析。简单来说，CR3被用来切换和定位当前正在使用的页表，它是一个32位的寄存器，其中高20位指向一个物理页（Windows系统上，一个页的大小是4KB，也就是4096个字节），如下图所示： 这图该怎么看呢？首先CR3会指向一个物理页，这个物理页又叫做页目录表（PDT），页目录表每个元素叫做页目录表项（PDE），页目录表项，每个4字节，所以一共有1024个页目录表项，CR3就好比一本书，PDT就是这本书的目录，PDE就是章节，这是一本有1024个章节的书（哇塞，真厚啊U•ェ•*U），这样就好理解多了。这是第一级。 页目录表项又指向一个第二级的表，叫做页表（PTT），页表的大小也是4KB，页表中的每个元素叫做页表项（PTE）。页表项可以理解为书中章节的每个小节，就好比第一章里面有1024个小节，这个小节就是PTE，这1024个小节加起来，构成一个小节表，就是PTT。 第二级介绍完了，第三级也就好理解了，既然书中每个章节的每个小节理解了，接下来就是页码了，每个小节都会对应书中的某个页码。而这个页码，就是相当于的物理页了。这样就可以理解这张图了，就是一部部找到物理页。 10-10-12分页Windows采用三种分页方式，在32位系统上主要有10-10-12分页和2-9-9-12分页这两种方式，在64位系统上增加了9-9-9-9-12这种分页方式，后面的文章会依次介绍32位下的两种分页方式。首先从10-10-12开始。 首先修改C盘的boot.ini文件，将noexecute改成execute，重启虚拟机，即可使用10-10-12分页方式 10-10-12分页是如何工作的呢？来看一个简单的程序： c123456789#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); return 0;} 这个程序很简单，给a赋值0x123，并查看a的地址 而这个地址0x12ff7c，实际上就是前文提到的线性地址，接下来我们将这个32位的地址按照10-10-12的方式进行拆分： 1.将0x12ff7c拆分成二进制：0000 0000 0001 0010 1111 1111 0111 1100 2.将这32位二进制数，按照10-10-12的方式组合： 每部分位数 二进制 十六进制 10 0000 0000 00 0 10 01 0010 1111 12f 12 1111 0111 1100 f7c 3.根据Cr3找到页目录表（PDT）中的页目录表项（PDE）： 首先在Windbg中执行!process 0 0指令，找到当前程序的Cr3，Cr3的值指向的就是页目录表的首地址。由于第一部分值为0，所以要查找的PDE，需要用Cr3+0*4(乘4是因为每个PDE大小是4字节)，这里注意一下，由于查找的是物理地址，所以使用的是!dd指令。 4.根据PDE找到页表（PTT）中的页表项（PTE）： 上一步已经找到了PDE，PDE的值指向的是某个PTT的首地址，方法和上一步一样，用PDE中的值+12f(拆分完的第二部分)x4，就可以得到PTE，这里要注意一点，将PDE中的值代入时，后12位置0，由于后12位为属性位，在查找的过程中不起作用 5.根据PTE确定物理地址： 确定PTE后，就剩最后一步了。由于一个物理页的大小本身就是4KB，也就是2的12次方，所以当确定了前20位后也就确定了物理页，因此我们要找的内容就在219da000这个物理页上的某个物理地址。这个物理页的范围是219da000~219dafff。现在可以理解，PTE指向的是一个物理页的首地址，根据最后12位的来确定，我们要寻找的值在物理页上的偏移，也就真正的找到了这个物理地址。 根据实验截图，发现我们一开始存在变量a里面的0x123，真正存的地方在0x219daf7c这个物理地址的位置，这就是通过线性地址一步步的找过来的，这些工作都是CPU做的，比如当我们读取a这个地址上的值是，CPU会通过分页机制读取该物理地址的值，然后再显示出来。 有趣的实验读错值了？有了10-10-12分页的知识，来做一个有趣的小实验 c1234567891011#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); printf(\"%x\", *(&a)); getchar(); return 0;} 这个代码非常简单，一般人认为，会先输出a的地址，然后再输出0x123。但有了物理页的知识，我们就可以做一些手脚了。 很奇怪吧？为什么输出不是0x123，而却输出0x456呢？原因就在于，我们偷偷修改了变量的物理地址上的值，将原本的0x123改成了0x456，因此，CPU再次去物理页读取时，值已经发生了变化，读到了修改后的值。 0地址也能存值？c1234567891011121314#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 1; printf(\"%x\", &a); getchar(); *(int*)0 = 0x123; printf(\"address0: %x\", *(int*)0); getchar(); return 0;} 这是个显而易见运行会失败的程序，为什么？因为你给0地址赋值了，有点C/C++开发经验的人都知道，0地址是不能存值的，为什么？因为运行不过去啊！这不扯淡嘛！你看我就运行过去了！ 这又是为什么呢？其实0地址不能存值的原因是，没有给它挂物理页，既然没有物理页，那CPU按照分页去查的时候，就查不到了；那么只要给他挂个物理页，就可以给这个线性地址存值了，具体操作如下。 总结 一张页表能包含的物理页：1024*KB = 4MB 10-10-12分页共有1024张页表：1024*4MB = 4GB 前20位的值如果相同，那么一定在同一个物理页 一个PTE最多可以指向一个物理页；PTE可以没有物理页；多个PTE可以指向同一个物理页 参考资料：《Intel白皮书第三卷第四章》 参考教程：https://www.bilibili.com/video/av68700135?p=24","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务门","slug":"任务门","date":"2020-03-17T01:10:51.000Z","updated":"2020-03-17T03:46:00.956Z","comments":true,"path":"2020/03/17/任务门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/17/%E4%BB%BB%E5%8A%A1%E9%97%A8/","excerpt":"","text":"为何使用任务门之前任务段中提到，进行任何切换时可以还可以使用任务门。那么既然存在TSS段描述符了，为何还需要任务门呢？ 简要概括，任务门有如下优势： 任务门可以放在GDT表中，也可以放在IDT表中，还能放在当前线程的LDT表中，而TSS段描述符只能在GDT表中 任务门可以让低权限的线程进行任何切换，任务门的结构中也有DPL属性，当通过任务门去访问TSS描述符时，一旦通过任务门，TSS段描述符就不再进行检查了，即使你是个CPL=3的程序，而TSS段描述符的DPL=0，只要任务门DPL=3，就可以通过任务门完成任务切换，稍后会做这个实验。 由于任务门可以位于IDT表中，所以当遇到中断或者异常时，可以切换到独立的任务去处理异常 下面为不同表中，任务门进行任务切换的过程： 任务门描述符 任务门描述符的结构非常简单，真正用到的只有24位，属性位里：DPL一般设置为3，方便应用程序访问，Type则是固定的0101，TSS段选择子，顾名思义，就是一个段选择子，指向位于GDT表中TSS段描述符的位置。其余位均为保留位，置0即可。 任务门实现任务切换这一步十分简单，仅仅比使用TSS多了一个步骤而已，这里也不细讲了，直接上步骤。 首先，编译源文件，下断点，确定TSS的地址，根据地址构造TSS段描述符： 第二步，根据GDT表中构造好的TSS段描述符位置，在IDT表中构造任务门： 第三步，在Windbg中使用!process 0 0指令确定CR3的值，并填入自己的TSS中： 执行程序，获取到自己构造的TSS表数据，任务切换成功： 总结任务门总体还是比较简单，由于是通过int 0x20中断进入，因此iretd作为中断返回出来，比起JMP FAR还需要手动修改EFLAGS的NT位和previous task link容易的多。比较遗憾的是，这一部分的小作业，通过任务门进1环，还是失败了。这里稍微说一下我的思路，由于是进入1环（虽然windows没用1环），但我们让他进入1环，就替换1环的寄存器，ESP1和SS1，当然SS1和CS都需要设置CPL值为1，但是原本0环这两个段寄存器控制的都是DPL=0的段，因此我们需要构造一个1环的段描述符，我实验的时候构造了一个1环的非一致代码段描述符和一个1环的数据段描述符，让任务切换后的CS，SS载入段描述符信息用。同时还需要把TSS段描述符的DPL设置为1，其余值保持不变。可惜，几次都死掉了，实验没能成功，群内也没人这个进入1环的实验，以后有人讨论的话会考虑再试试。 任务段任务门这里有些遗憾吧，的确有点复杂，没理解透彻，感觉任务段那讲的也不是很清晰，希望以后我还能看得懂吧，接下来进入页的内容了，保护模式的关键来了，得掌握好。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务段","slug":"任务段","date":"2020-03-16T12:41:30.000Z","updated":"2020-03-16T17:07:35.399Z","comments":true,"path":"2020/03/16/任务段/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/16/%E4%BB%BB%E5%8A%A1%E6%AE%B5/","excerpt":"","text":"要点回顾在调用门、中断门与陷阱门中，一旦发生权限切换，那么就必有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。这时问题来了，我们知道EIP和CS的值都可以通过门描述符获得，那么ESP和SS是哪来的？这就是引出了今天的内容：TSS（Task-state segment），任务状态段。 TSS设计初衷想要学习一类知识，首先要了解它被设计出来的目的，这样就能找到方向，更好的了解它。CPU在运行时会频繁的切换任务，每次切换任务时，还没执行完的任务怎么办？总不能下次重新执行吧，于是需要保存上一个任务的上下文环境，于是，TSS诞生了，TSS是一块大小为104(0x68)个字节的内存，没错，TSS不是什么寄存器，就是一段内存，或者说是一个段，这段内存可以保存32-Bit下所有通用寄存器以及段寄存器的值，这样CPU就可以切换到新任务时，仍然保留上一个任务的环境，方便新任务执行完后，能够完好的回到先前的任务继续执行。 注意，TSS是一个段，有段就有段寄存器和段描述符哟！比如我们熟悉的CS，CS就是段寄存器，它描述的是代码段，同时，它会通过段选择子从GDT表的代码段描述符中载入段的相关信息，通常情况下，代码段的范围是0~FFFFFFFF（大小是4GB）；这样一对比，就可以理解了，TSS也是如此，因为TSS也是一个段（大小是104字节），所以应该存在一个描述TSS的段寄存器从一个段描述符里加载TSS相关信息。这就是今天会依次介绍的TR寄存器和TSS段描述符。 这里补充一点知识，尽管Intel设计TSS的初衷的为了方便任务切换（CPU层面叫做任务切换，操作系统层面叫做线程切换），但是Windows认为这个TSS设计的不好，因此并没有采用这个结构进行线程切换，并且Linux也没有采用TSS进行线程切换，这俩操作系统用的都是堆栈进行线程切换的。那么Windows用到了这个结构没有，当然是用到了，但仅仅用到了ESP0和SS0这两个值。 TSS结构先来看看TSS的结构 大部分都应该比较熟悉，这里介绍几个较为陌生的字段： Previous Task Link：这里保存的是上一个TSS的段选择子，比如任务发生了切换，新任务执行完后，如何才能找到先前未能执行完的任务呢？就得依靠这个值了（前面不是说了Windows不用TSS进行线程切换嘛，是呀，但是这里讲解的这个字段的作用，设计初衷就是为了任务切换） ESP0/SS0：当发生提权时，0环的ESP和SS的值就是从这里取的 CR3：有人会问，我哪知道取哪个TSS的ESP0和SS0呢？就是这个值的作用了，这个值帮我们确定当前位于哪个线程，之后在页的篇章中会学到CR3的相关内容。 LDT：这个值通常都是0，Windows没有用到LDT表，因为LDT表只对当前的线程有用 I/O Map：这个位置涉及到硬件IO了，值一般是固定的 TSS段描述符 TSS段描述符只能存在GDT表中，不能存到LDT或者IDT中，所以它的结构和之前介绍的段描述符是类似的，区别在于个别位的不同 G位：在代码段/数据段描述符中，这个位置通常位1，因为这两个段的范围通常是4GB，而TSS的大小是104字节，单位是字节，因此这个值为0 Type域：这个值为1011或1001，其中B位是Busy位，置1时说明该TSS是否被载入或者嵌套，载入说明CPU正在执行该任务；嵌套则表明该任务处理了一半，切换到了另一个任务中去，但该任务并未执行完。 Base/Limit：Base确定TSS段的起始位置，Limit确定TSS段的大小，Base~Base+Limit就是TSS段的范围。 TR寄存器在一开始的探究段寄存器的文章中提过，CPU共有8个段寄存器，TR就是其中之一。先前提到过，TR寄存器的工作原理和其它段寄存器一样，通过段选择子加载GDT表的TSS段描述符中的信息，方便CPU找到TSS的位置，具体工作原理如下： 这里介绍两个操作TR段寄存器的指令LTR和STR： LTR：这是一个特权指令，只有0环的程序才能调用；作用是将段选择子写入TR寄存器 STR：STR不是特权指令，这个指令3环程序也可以调用，所用是读取TR寄存器的值 需要注意的一点，修改TR寄存器的值，只是会载入新的TSS段描述符信息，并不会对修改前的TSS段造成影响。 实现任务切换虽然说了Windows并没有将TSS用来进行线程切换，但是我们仍然可以手动实现任务的切换。 直接修改TR寄存器是不能做到任务切换的，但是可以通过JMP FAR或者CALL FAR来加载TSS段描述符来实现。下面分别使用两种方法来实现（两种实现方法细节有很多差别） 一般情况下，任务切换发生在下列四种情况之一： 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表中的TSS段描述符 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表或者当前LDT表中的任务门描述符 一个中断或者异常触发了在IDT表中的任务门描述符 当前任务执行IRET指令，且EFLAGS寄存器的NT位为1时 CALL FAR实现本次CALL FAR实现采用第一种任务切换的情况。 设计一个TSS，存储任务切换时必要的信息，其中包括ESP0，SS0，CR3，EIP，ESP，段寄存器，位图控制。 ESP0：也就是任务切换后的堆栈，可以自己创一个空数组，然后写入数组的首地址，就可以作为堆栈使用。 段寄存器及SS0：这些值，在0环通常都一样，可以进入Windbg参考其它TSS的值，这里使用的是SS/SS0 = 0x10，ES/DS = 0x23，CS = 0x8，FS = 0x30，GS = 0x0 EIP：这就是要跳转后执行的地方，可以写一个裸函数来验证是否切换成功，直接取裸函数地址即可，我这里的值为0x401020（每个人机器可能不一样） CR3：这个值，需要在执行前，中断到Windbg寄存器中，通过!process 0 0指令获取。 位图控制：这是一个默认值为0x20AC0000 构造完的TSS如下： c12345678910111213141516171819202122232425262728DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; 然后我们需要根据这个TSS的地址，来构造我们的TSS段描述符 地址为0x12fd70 因此TSS段描述符为：0000e912`fd700068，e->DPL=3：是为了3环的程序可以访问这个段描述符，0x68就是104字节，9说明未被载入。然后让我们填入段描述符 接着运行程序，需要采集Cr3的值，先中断到Windbg，再通过!process 0 0指令获取，取最后的一个值 在程序中填入cr3的值后回车，发现可以成功取到任务切换后ESP，CS，SS，并且均为我们设定的值，实验成功。 完整代码如下： c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include \"stdafx.h\"#include int saveEax, newESP;short newCS, newSS;__declspec(naked) void Get_Value() { __asm { mov saveEax, eax mov newESP, esp mov ax, cs mov newCS, ax mov ax, ss mov newSS, ax mov eax, saveEax iret }}int main(int argc, char* argv[]){ char stack[100] = {0}; char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; int Cr3 = 0; printf(\"Input: \"); scanf(\"%x\", &Cr3); getchar(); DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; _asm { call fword ptr buffer } printf(\"ESP: %x, cs: %x, ss: %x\", newESP, newCS, newSS); getchar(); return 0;} 以上是通过Call Far实现的任务切换。还有另一种方法，是通过JMP FAR来实现，而且JMP FAR实现会更加困难一些。这里简要概括一下，当使用CALL FAR时，CPU会自动帮你用当前任务的段选择子填写你TSS的Previous Task Link字段，同时给你的Eflags的NT位置1，这个NT位有什么用呢，就是关系到iret这个指令的意义，当Elfags的NT为1时，iret表示根据Previous Task Link的值，从当前任务返回到前一个任务中去，当NT为0时，这是一个中断返回指令。而当你使用JMP FAR实现时，你需要手动给Pervious Task Link字段赋上前一个任务的段选择子，此外你需要手动给Eflags的NT位置1，当然这可以通过 Code12345pushfdmov eax, [esp]or eax, 0x4000mov [esp], eaxpopfd 来实现，此外，还需要确保前一个TSS段的段描述符Busy位的值为1，这样才能确保该任务处在嵌入的状态。 总结这是开博客以来，最艰难的一篇了，看视频楞是没看明白，然后又去翻Intel白皮书，看明白了然后开始代码实现，CALL FAR的任务切换实现的还算顺利，但是JMP FAR的问题就比较大了，一下午都没整出来，蛋疼啊~ 不想再弄了，看了群友的代码，感觉自己好像也没写错，就是一直死。明天打算整一整任务门吧，完了就到页的知识了，那边掌握的还算不错，可以轻松一阵子了，坚持呀！ 参考资料：《Intel白皮书卷3-第七章》","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"陷阱门","slug":"陷阱门","date":"2020-03-15T08:31:07.000Z","updated":"2020-03-15T10:56:29.726Z","comments":true,"path":"2020/03/15/陷阱门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/15/%E9%99%B7%E9%98%B1%E9%97%A8/","excerpt":"","text":"这一篇来说陷阱门，陷阱门这东西，就没什么好讲的，应该Windows几乎没怎么用，陷阱门也是位于IDT表里的，列出前48个描述符，就没有陷阱门。。。 陷阱门描述符 看图，陷阱门描述符，和中断门描述符，就1个位不一样，中断门的Type域是1110，陷阱门是1111 代码实现代码实现也和中断门的完全一样，搬过来就行了。 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 与中断门的差别那可能有人要问了，既然陷阱门和中断门完全一样，有什么存在的意义。那还是有一点不同的，来看两次执行的结果： 同样的代码，执行结果不同，可以发现，陷阱门和中断门的区别在于，中断门执行后EFLAG寄存器的值发生了改变，而陷阱门不会改变EFLAG，这就是陷阱门和中断门的差别。 EFLAG寄存器结构 根据EFLAG寄存器的结构可以得知，中断门执行后，将IF位置0了，但陷阱门不会，这就是中断门和陷阱门的唯一区别。 那么这个IF位有什么用呢？为什么陷阱门要将IF位置0呢？ 稍查资料，可以了解到IF标志是用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。IF标志对不可屏蔽中断没有影响。 这里举个简单的例子说明下什么是可屏蔽中断，什么是不可屏蔽中断。打开任务管理器，可以看到有很多进程正在运行，这时候，你想把电脑锁屏，于是按下Win+L，这个时候键盘会向CPU发送一个可屏蔽中断，告诉CPU，用户按下了Win+L键，需要执行锁屏功能，如果此时EFLAG的IF位为1，这是CPU会短暂放下手上的任务，先去处理你的锁屏任务，处理完后，你的电脑锁屏了，CPU会继续运行刚刚处理的进程；如果此时ELFAG的IF位为0，那么CPU就和没听到一样，继续做它自己的事。如果遇到意外状况，电脑的电源线拔了下来，断电了，这时电源会向CPU发送一个不可屏蔽中断，这个中断不受IF位影响，CPU一定会去处理。这时有人会问了，断电后CPU还怎么工作？其实在主板上，是有电容的，可以在断电后让CPU再去做一些清理工作，这就是不可屏蔽中断。 总结中断门和陷阱门的唯一区别：中断门执行时，将IF位清零，但陷阱门不会。 参考教程：https://www.bilibili.com/video/av68700135?p=20","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"中断门","slug":"中断门","date":"2020-03-15T06:26:54.000Z","updated":"2020-03-15T08:13:54.134Z","comments":true,"path":"2020/03/15/中断门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/15/%E4%B8%AD%E6%96%AD%E9%97%A8/","excerpt":"","text":"上一篇提到过，Windows是不使用调用门的，所以在GDT表里没有找到调用门，那么Windows如何实现代码跨段，提权等行为呢？这里用的较多的是中断门，接下来就来介绍一下中断门。 IDT表与GDT的区别首先要提到IDT表（中断描述符表），在上一篇提到的调用门的门描述符，都在GDT表里，而中断门的门描述符在另一张叫做IDT的表里面。同GDT一样，IDT也是由一系列描述符组成的，每个描述符占８个字节。但需要注意的是，IDT表中的第一个元素不是NULL。 在Windbg中查看IDT表的基址和长度： IDT的构成IDT表可以包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 中断门执行流程有了IDT表的概念后，咱们就可以开始讲讲中断门的执行流程，实际上和调用门差别不是很大，可以类比的来看： 执行调用门的指令：CALL CS:EIP，其中CS是段选择子，包含了查找GDT表的是一个索引. 执行中断门的指令：INT N，其中N是IDT表的一个索引 执行流程就只有这个差别，当CPU通过N这个索引在IDT表中找到了中断门描述符后，执行的步骤就和调用门的步骤完全一样了，可以参考调用们的执行流程。这里要注意一点，当找到中断门描述符后，还是会通过描述符里的段选择子，去GDT表中找需要跳转的代码段。所以说中断门的执行会查找两张表，先查找IDT表，再查找GDT表。 中断门描述符简要说完了IDT表（实际上和GDT表没啥差别）来看看中断门描述符的结构： 粗略一看，和调用门描述符没差呀。这不就是无参调用门描述符换了个Type域嘛。没错，的确是这样（这里解释下D位，可以理解为段描述符的DB位，置0时为16位中断门，置1时为32位中断门）。当你发现这点时，说明调用门的结构你理解清楚了。因此结构不再赘述，可以参考调用门 中断返回与调用门使用长返回RETF不同，中断门使用中断返回指令：IRET/IRETD INT N指令： 在没有权限切换时，会向堆栈压入3个值，分别是CS，EFLAG，返回地址 在有权限切换时，会向堆栈压入5个值，分别是SS，ESP，EFLAG，CS，返回地址 这也是与调用门不同的地方，中断门会多压入一个值。于是有小盆友就要问啦，“死肥宅哥哥，为什么中断门会多压入一个参数呢？” 这还不明显吗，你想想人家调用门为什么要压入值进入堆栈啊？肯定是这些值会改变啊，所以要用堆栈保存一下，等长返回的时候，再还原状态；中断门多压入了一个EFLAG说明通过中断门跨段时，EFLAG的值会变啊！ 所以，在中断门中，不能通过RETF返回，而应通过IRET/IRETD返回，其实只要改改堆栈，就可以通过RETF返回中断门，IRETD返回调用门。 代码实现中断门比较简单，这里演示一个实现的范例 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 根据GetValue函数的地址构造中断门描述符，然后填入中断门里即可 执行结果如下： 然后我们用int 3中断到Windbg里验证一下 验证成功。 总结通过调用门与中断门的对比，来总结一下中断门： 调用门通过CALL FAR指令执行，但中断门通过INT指令 调用门查询GDT表，中断门查询IDT表（后续也会再查询GDT表） CALL CS:EIP中的CS是段选择子，由3部分组成，而INT N指令中的N只是索引，中断门不检查RPL，只检查CPL 调用门可以有参数，但中断门没有参数 参考教程：https://www.bilibili.com/video/av68700135?p=19","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"调用门","slug":"调用门","date":"2020-03-14T06:34:21.000Z","updated":"2020-03-15T08:09:52.571Z","comments":true,"path":"2020/03/14/调用门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/14/%E8%B0%83%E7%94%A8%E9%97%A8/","excerpt":"","text":"前一篇中提到CALL FAR指令最终跳转的地址是调用门里，今天就要分析一下调用门。首先从调用门的执行流程开始 调用门执行流程指令格式：CALL CS:EIP(EIP是废弃的) 执行步骤： 根据CS的值查GDT表，找到对应的段描述符，这个描述符是一个调用门。 在调用门描述符中存储另一个代码段的选择子 选择子指向的段的Base+调用门里的Offset，就是真正要执行的地址 光看描述，的确很难懂，结合调用门描述符来分析，会好理解很多 调用门描述符 高4字节8~15位：这是和普通段描述符完全一样的8位，其中第12位是判断该描述符是系统段还是数据段或代码段的位置，调用门描述符是系统段，所以此处值一定是0。接下来的Type域，这个根据段描述符那章中也能找到，32位的调用门描述符，Type域为1100，这也是确定的。 高4字节的高16位+低4字节的低16位：这两块区域加起来刚好是32位，构成一个Offset，也就是调用门执行流程第三步里Base加上的Offset，那么Base哪里拿呢？ 低4字节的高16位：这16位是一个段选择子，有段选择子，就可以拆分，于是RPL，TI，Index都能解析出来，这时候就可以根据Index去GDT表里找到段描述符，而这个段，就是调用门跳转的段，因此要用这个段的Base+Offset便可获得真正要执行的地址。 高4字节的低5位(第5~7位均为0)：这5位的作用是描述调用门传进去的参数，调用门是可以传参的，而参数的个数，决定了这个位置的值 下面，通过代码来验证调用门的执行流程。 无参调用门调用门分为无参和有参（示例默认都提权）两种情况，这里先用无参调用门进行实验： 构造调用门因为Windows是不使用调用门的，所以需要自己构造一个调用门：0040EC00 00081010 为什么要这样构造呢？先看最熟悉的那8位，EC = 11101100，P=1，S=1，调用门=1100，DPL为啥选取3呢。首先，调用门的提权在于通过调用门后，新的段选择子会修改CS达到CPL的提权，但是访问调用门描述符还是需要保证CPL=DPL，因此，DPL需要设置为3。由于无参调用门，也就没参数，因此参数位为0，EC00也就解释清了。 接下来看0008，这个也很好理解，段选择子嘛，拆分一下，RPL=0，Index=1，我们去Windbg里看一下就好了 这下就清晰了，指向00cf9b00 0000ffff这个段描述符，拆分一下，Limit=FFFFFFFF，G=1，Base=00000000，是个非一致代码段。看来想要跳转成功，也得是0环的代码段才行。 由于Base为0，那么跳转到的地方就是0+401010，那这个401010是哪来的呢？这得看代码才能说清。 代码实现c12345678910111213141516171819202122232425262728293031323334353637383940#include \"stdafx.h\"int saveEax = 0;short oldCS = 0;short newCS = 0;short oldSS = 0;short newSS = 0;int oldESP = 0;int newESP = 0;__declspec(naked) void GetValue() { __asm { mov saveEax, eax lea eax, [esp] //new esp mov newESP, eax mov eax, [esp+8] //old esp mov oldESP, eax mov eax, [esp+4] //old cs mov oldCS, ax mov ax, cs mov newCS, ax mov eax, [esp+0xc] //old ss mov oldSS, ax mov ax, ss mov newSS, ax mov eax, saveEax retf }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { call fword ptr [buffer] } printf(\"%x, %x, %x, %x, %x, %x\", oldCS, newCS, oldSS, newSS, oldESP, newESP); getchar(); return 0;} 来看一下代码，从main函数开始看起，我们自己构造一个CS:EIP（EIP已废弃）的6字节char型数组，然后在汇编中执行CALL FAR调用我们构造的CS:EIP，接着打印部分内容。 可以看出执行调用门的语句嵌入了汇编里，根据上方在构造调用门时的分析可以得出，最终调用门跳转的地址会是401010，那么这个401010是怎么来的呢？其实就是GetValue函数的地址，我们知道通过调用门后会跳转到一个地址，但是如何才能检测成功跳转并提权呢？就得有一个函数来收集这些信息并将其打印出来，也就有了GetValue函数（GetValue地址通过VC下断点查看，然后写入构造的调用门描述符中）GetValue要声明成裸函数，这样堆栈只需自己平衡，可以避免元素访问的位置过远。 根据前一篇文章的内容，如果跨段并提权，堆栈内部大致情况如下 因此，这里采用通过全局变量，来依次读取堆栈不同位置的值，并打印查看结果。 由结果看，ESP，CS，SS均发生了切换，且CPL变为0，ESP的值也变为了一个高2G的数 为了验证结果的正确性，我们可以通过中断再看一下0环的堆栈结构，将裸函数中的汇编代码清除，只留下int 3和长返回语句如下： Code1234_asm { int 3 retf} 然后重新执行，会中断到Windbg（为什么会从虚拟机中断到Windbg，这个到后面中断部分会详细讲解）查看栈顶部分内存 注意：这里的栈顶esp的值和刚刚不一样是因为程序重新执行了，进入0环时，ESP和SS是TSS给的，而TSS内的值是当前线程给的，因为代码修改了，所以重新执行程序时，线程不一样了，所以0环的堆栈也就不一样了。但是3环的数据是没有变的（理论上也是会变的，这里没变是因为编译器的优化），对比刚刚手动读取的结果来看，3环的ESP，CS，SS完全一致，说明刚刚调用门的实验成功提权进入0环。 有参调用门无参说完了，接下来是有参调用门，有参调用们和无参的区别在于仅仅是参数位的值会有所变动，栈里多了push进去的参数，其余和无参基本上相同。 构造调用门 这里构造的调用门描述符是：0040EC03 00081020，（地址变成了401020，是因为我重启了下虚拟机所以GetValue函数地址变了，并不影响），需要注意的是参数位设置成了3，因为这次计划传入3个参数进去。 代码实现由于Push了参数进去，所以不确定参数在0环堆栈中位于什么位置，于是先用int 3的方法，在Windbg中查看一下堆栈的情况 图中可以发现，在压入参数的调用门进入0环后，参数位于3环ESP和3环CS中间的位置，堆栈表示大致如下： 这样，就可以来编写代码了，总体和无参的差距不大。 c1234567891011121314151617181920212223242526272829303132#include \"stdafx.h\"int saveEax = 0;int para1, para2, para3;__declspec(naked) void GetValue() { __asm { mov saveEax, eax mov eax, [esp+8] mov para3, eax mov eax, [esp+0xc] mov para2, eax mov eax, [esp+0x10] mov para1, eax mov eax, saveEax retf 0xc }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { push 1 push 2 push 3 call fword ptr [buffer] } printf(\"%x, %x, %x\", para1, para2, para3); getchar(); return 0;} 需要注意一点，这里由于push了3个参数，所以长返回的时候要用RETF 0xc来平衡堆栈，否则直接中断到Windbg，要是不处理的话就蓝屏了。 代码执行效果如下，成功在0环堆栈取到了push进入的参数。 总结 当通过门，权限不变时，只会PUSH两个值：CS和返回地址，新的CS的值由调用门决定 当通过门，权限改变的时候，会PUSH四个值：SS，ESP，CS，返回地址，新的CS由调用门决定，新的SS和ESP由TSS提供 通过门调用时，要执行哪行代码由调用门决定，但使用RETF返回时，由堆栈中压入的值决定，也就是说，进门时，只能按指定路线走，出门时，可以翻墙（只要改变堆栈里面的值就可以想去哪去哪） 可不可以再建个门出去呢？也就是用Call，当然可以。 参考教程：https://www.bilibili.com/video/av68700135?p=17","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"长调用与短调用","slug":"长调用与短调用","date":"2020-03-14T01:29:45.000Z","updated":"2020-03-14T06:15:50.000Z","comments":true,"path":"2020/03/14/长调用与短调用/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/14/%E9%95%BF%E8%B0%83%E7%94%A8%E4%B8%8E%E7%9F%AD%E8%B0%83%E7%94%A8/","excerpt":"","text":"在上一篇章中提过，实现跨段的跳转，可以使用JMP FAR指令，但是想要实现跨段的调用，就需要学习一个新的指令CALL FAR；CALL FAR指令要更为复杂一些，原因是JMP指令是不影响堆栈的，而CALL指令会影响堆栈。 短调用首先来回顾下短调用，短调用其实就是普通的CALL调用，是相对于CALL FAR而言，所以叫做短调用。短调用会影响EIP寄存器和ESP寄存器，因此在返回时需要额外去平衡一下堆栈；短调用属于三环知识，这里不再赘述，具体的调用和返回时的堆栈变化如下图所示： 长调用（跨段不提权）长调用分为提权和不提权两种，这里先讲不提权的情况。 这图看不明白没关系，一个个分析。首先，EIP为什么是废弃的？因为，这个长调用指令，压根不会跳转到你给的EIP的位置，而是会跳转到调用门里提供的地址。那什么是调用门呢?下一篇会具体提到， 这里简单概括调用门就是一种位于GDT表里特殊的描述符。 回到长调用这里，当CALL执行后，与一般的调用指令不同，长调用使得堆栈提升了8个字节，除了返回地址外，还压入了调用者的CS，以便在调用返回至原来程序时，CS也能得到恢复。其中返回地址依然是位于[esp]处，调用者的CS位于[esp+4]处。 长调用返回也与普通调用不同，普通调用使用ret指令即可返回到原来程序的位置，而长调用返回时需要使用长返回指令RETF，长返回指令除了会将返回地址送入EIP寄存器，还会将CS恢复至执行前的状态，同时平衡堆栈。 长调用（跨段并提权）不提权的长调用还稍微好理解一点，提权的长调用，就稍微有些复杂了，由于发生了提权，CS的CPL发生了改变，根据Intel的规定，CS和SS的CPL一定要保持一致，所以此时SS的值也会发生改变，除此之外，因为发生了提权，堆栈从3环的堆栈变为了0环的堆栈，因此ESP也会发生改变。所以提权的长调用会4个寄存器的值发生改变，分别是EIP，CS，ESP，SS，来看一下执行前后的变化 提权后，分别将返回地址，调用者CS，ESP，SS压入了0环的堆栈中，这样在返回3环时，可以确保这些寄存器恢复到原本的状态。 同样，提权后返回用的也是RETF，长返回指令，分别将返回地址，调用者的CS，ESP，SS压入相应的寄存器中，大致如下： 总结长调用相较长跳转更为复杂，这篇只是做个简单的介绍，在后面的篇章中，将通过分析调用门的实现过程来详细讲解长调用，这里对本篇提到的几个特点做些总结。 跨段调用时，一旦有权限切换，就会切换堆栈 CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样 JMP FAR只能跳转到同级非一致代码段或者共享段，但CALL FAR可以通过调用门提权，提升CPL的权限 参考课程 : https://www.bilibili.com/video/av68700135?p=16","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"代码跨段跳转（不提权）","slug":"代码跨段跳转","date":"2020-03-13T02:24:36.000Z","updated":"2020-03-13T15:47:09.308Z","comments":true,"path":"2020/03/13/代码跨段跳转/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/13/%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5%E8%B7%B3%E8%BD%AC/","excerpt":"","text":"之前的篇章中提到过，除了CS段寄存器外，均可使用MOV或LES,LSS,LDS,LFS,LGS指令进行修改；为什么CS不可以直接被修改呢？ CS是代码段的段寄存器，CS的改变意味着EIP的改变，所以无法使用上述指令进行修改 代码跳转指令代码的跳转指令分为2种，一种是同时修改CS和EIP的指令，另一种，只修改EIP指令，具体如下： 同时修改CS和EIP：JMP FAR/ CALL FAR / RETF / INT / IRETD 只修改EIP：JMP / CALL / JCC / RET 本篇用到的是JMP FAR指令。 JMP FAR指令：和普通的JMP指令不同，JMP FAR实际是在JMP指令后写上6个字节，例如 JMP 0x4B: 0x00401456的形式。 其中0x4B是段选择子，0x00401456是跳转地址。 若能成功执行，0x4B会写入CS中，0x00401456会写入EIP中，代码发生跳转。 代码跳转流程JMP 0x20:0x004183D7 CPU如何执行这行代码? 段选择子拆分0x20 对应二进制 0x0000 0000 0010 0000 RPL：00 TI：0 Index：4 查表得到段描述符 TI = 0 所以查GDT表 根据Index = 4 找到对应的段描述符 四种情况可以跳转：代码段、调用门、TSS任务段、任务门（其中调用门，TSS任务段以及任务门，都属于系统段） 之前段描述符的篇章提到过，可以根据段描述符的属性判断属于哪个段，通过看属性的那16位：由于代码段和数据段的S位值为1，所以一般第12-15位为字节9/F，而代码段的Type域的第1位为1，所以代码段的Type域一定大于等于8。因而判断代码段描述符的第8-15位通常在98-9F或者F8-FF这个范围内。 权限检查权限检查分为非一致代码段和一致代码段两种情况，下面我们分别来看 非一致代码段非一致代码段，要求：CPL == DPL 并且 RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（下）","slug":"一次简单的Hook-下","date":"2020-03-12T07:38:30.000Z","updated":"2020-03-12T15:23:43.627Z","comments":true,"path":"2020/03/12/一次简单的Hook-下/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/12/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8B/","excerpt":"","text":"前一篇已经完成了对GetMsgAbstract函数的分析，发现，当执行到GetMsgAbstactByElement这一步时，已经可以根据寄存器用来传递的参数获取聊天内容，这篇来根据分析的内容编写用来Hook的dll。 Inline Hook这里先对Inline Hook做个简要概述，它是一种通过修改指令的方法，转移程序的执行流程，在程序执行某函数前或者某函数后，先执行你定义的Hook函数，拿到需要的参数信息，再根据需要对参数信息进行加工，从而完成Hook。常见的手法如下： Code11. jmp xxxxxxxx (5字节) Code12. push xxxxxxxx/retn (6字节) Code13. mov eax, xxxxxxxx/jmp eax (7字节) Code14. call Hook 根据需求不同，替换掉原本的指令长度不同，从而选择的手段也不同；本篇中采用6字节的方式 构建DLL一般构建一个dll要分别去编写头文件，C/C++源文件以及入口点函数。首先我们先从头文件开始。 头文件 打开Visual Studio，新建一个动态链接库(DLL)项目，VS会自动帮忙生成头文件和源文件，点击头文件stdafx.h开始编写 其实VS已经帮忙生成好了大部分，只需要定义自己需要实现的函数和方便自己使用的宏即可 这里为什么不写成下面这种形式呢？ c1__declspec(dllexport) BOOL WINAPI Msg_Hook(); 因为这个dll的主要作用是hook，并不需要有导出函数，即使有了被我们hook的程序也不会主动去调用（因为它的代码里面根本没有调用我的dll的代码），所以干脆就不写了，没什么影响。 入口点函数VS帮我们生成好的入口点函数如下： 在这里其实只需要把刚刚定义的函数，写在DLL_PROCESS_ATTACH的地方即可，因为在dll加载到进程时，会先调用入口点函数，传入的参数则是DLL_PROCESS_ATTACH，这样就可以调用我们的Hook函数了。 源文件源文件的编写是比较关键的一步，主要功能的实现都在这里。首先，我们需要实现Hook用的函数。 Hook函数 首先编写一个大致的框架，来分析一下都做了些什么，还缺一些什么。 Inline Hook的核心在于修改指令，从而实现程序流程的转移。具体的流程就是，找到需要修改的位置，修改当前位置的指令。 修改指令的大小这里采用的是push xxxxxxxx/retn的手法，所以需要创建一个6个字节的char型数组。 修改的位置修改的位置如何确定？之前在OD分析反汇编程序时，确定在调用GetMsgAbstractByElement之前就可获取到消息内容，发现，调用这个函数的call语句加上之前的push eax，刚好6个字节，这就是Hook点了 这个位置位于KernelUtil.dll中，所以我们可以补充第三条语句改成如下： Code1DWORD modify_addr = (PROC)GetModuleHandle(\"KernelUtil.dll\") + EntryOFFSET; 同时也可以根据基址确定EntryOFFSET并写在开头。 如何修改？这里采用Windows提供的ReadProcessMemory和WriteProcessMemory这两个函数，参数非常好理解，当前进程，需要修改的地址位置，修改的字节，修改字节的长度以及一个可以忽略的参数。在读的时候，指定位置的指定大小的字节会被保存进定义的char型数组里，写的时候就是把修改后的字节写回原来的地址。那我们要如何确定该写什么呢？ 根据push xxxxxxxx/retn指令，可以确定第一个字节和最后一个字节分别为0x68和0xC3。中间的4个字节填什么？就是执行我们做手脚的函数地址了。Hook函数的作用就是转移程序执行的流程，将程序转移到我们自己定义的函数，我们自己的函数就可以对当前的程序做些手脚，比如读取函数接收的参数，并将其传递出来。 目前为止，经过分析，可以进一步完善源程序。 接下来，就来编写自己的函数，将消息内容传递出来。 功能函数功能函数其实就是用汇编写一个裸函数，为啥要用裸函数？这样的话，编译器就不会自动帮我们生成如下这三行指令： Code123push ebpmov ebp, espsub esp, 0x20 而是我们自己平衡堆栈，所以就可以避免很多额外的偏移造成的麻烦，经过上一篇的分析已知，当函数到达GetMsgAbstractByElement的位置处时，可以通过[[ebx+0x28]]+0x18获取消息内容。那就可以采用一下方式： Code123456pushadpushfdmov eax, [ebx+0x28]mov eax, [eax]mov eax, [eax+0x18]mov Msg, eax 这样只要在外部定义一个变量Msg，即可将消息取到，然后可以利用OutputDebugString将消息内容输出到DbgView里观察。 但这还没有结束，因为之前覆盖掉了GetMsgAbstractByElement，所以这次需要重新再调用一遍。所以我们需要获取GetMsgAbstractByElement的地址，先通过当前地址和基址相减算出偏移0xBE0B0，然后通过KernelUtil.base+Offset确定函数的地址。这时只需要在平衡堆栈后的地方，补上之前替换掉的6个字节即可。 最终功能函数实现如下： 实验结果我们使用OD，将编写的dll注入进去 注入后此处代码发生了变化 观察DbgView，发现成功拿到消息内容","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"第一周","slug":"第一周","date":"2020-03-11T12:40:24.000Z","updated":"2020-03-11T12:49:59.321Z","comments":true,"path":"2020/03/11/第一周/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/11/%E7%AC%AC%E4%B8%80%E5%91%A8/","excerpt":"","text":"今天是开博客的第七天，说满意其实也不是很满意，进度还是很慢的，当然计划也是长远的。一个是希望能坚持下来，也很久没坚持做一件事了；另一个是希望能够在4个月左右的时间，将所涉及的三个领域的基础知识，真正的掌握了，希望自己能真正尽力。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://cataloc.gitee.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"段权限检查（数据段）","slug":"段权限检查","date":"2020-03-11T01:55:19.000Z","updated":"2020-03-11T07:54:44.536Z","comments":true,"path":"2020/03/11/段权限检查/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/11/%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5/","excerpt":"","text":"访问违例问题在介绍内容前，先看两个程序 两个程序的差异仅仅在于段选择子的不同，结果则是一个访问成功另一个访问违例了。分别对两个段选择子进行拆分： Code10023 = 0000 0000 00100 0 11 RPL：3 Index : 4 Code1002B = 0000 0000 00101 0 11 RPL：3 Index : 5 可以看出，两个段选择子的差别仅在Index的不同，也就是指向的段描述符不同，再来看看两个段选择子对应的段描述符 注意：由于Index是从0开始算的（和数组一样），所以对应的实际上是表中第五个和第六个段描述符。 根据之前段描述符属性的内容，来查看属性位，分别为： Code1Attr: CFF3 DPL:3 Code1Attr: 008B DPL:0 可以发现，两个段描述符的DPL不同，之前在段选择子的篇章中提到过，在将段选择子指向的段描述符加载到段寄存器时，一定要保证数值上（RPLDPL。那为什么RPL>DPL就会出错呢？下面来逐步解析。 CPU分级先来了解一下CPU分级 CPU共划分了4个等级，Ring0~Ring3，其中Ring3级别最低，Ring0级别最高。这个分级是CPU划分的，并不是操作系统所划分的，操作系统只是使用了这个分级，其中Windows系统只用了Ring3和Ring0两个等级，分别表示应用级和系统级。应用级的程序往往不能访问系统级，所以保护模式不仅仅是防止段的胡乱访问，还保证了程序在相应的级别稳定的运行。 CPLCurrent Privilege Level，当前特权级，之前段选择子篇章中讲过，段选择子的后2位的值为RPL，而CPL指的CS或SS中的段选择子的后2位（CS/SS的后两位一定是相同的，所以无论用哪个作为CPL都一样），也就是说CS或SS的RPL就是当前程序的CPL。 下面来查看两个CPL： 随便拖一个程序进入OD，根据CS/SS可以算出当前程序的CPL为3。因为这些程序都是Ring3的程序。 按Ctrl+Break在Windbg中断下，查看寄存器，可以发现当前CPL为0。因为Windbg在调试系统时执行的都是内核函数，所以处在Ring0。 DPL Descriptor Privilege Level：描述符特权级别。在段描述符属性那一篇中解析DPL时提到过，在段描述符高4字节的第13~14位就是DPL，那么DPL到底有什么用呢？和CPL有什么关系呢？ DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么。 通俗的理解：如果你想访问我，那么你应该具备什么特权。例如： Code1mov ds, ax 如果ax指向的段DPL = 0 但当前程序的CPL = 3 这行指令是不会成功的，因为CPL = 3是应用层，权限较低，是不能访问DPL = 0的系统层的；这也是为什么之前的例子中会出现访问违例。 RPLRequest Privilege Level：请求特权级别 有小盆友可能会问了，既然已经有CPL和DPL，那只要CPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（上）","slug":"一次简单的Hook-上","date":"2020-03-10T01:36:42.000Z","updated":"2020-03-10T09:48:23.338Z","comments":true,"path":"2020/03/10/一次简单的Hook-上/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/10/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8A/","excerpt":"","text":"这一次hook小实验的目标是hook出某社交软件中的实时聊天内容，主要目的是了解hook的原理以及在hook之前对程序的分析流程及其他准备工作，从而对于hook有个完整的认识。 准备工具 OllyDbg调试器：用于单步跟踪，动态调试等。 IDA pro调试器：用于静态分析函数代码结构等。 Mircosoft Visual Studio 201*(版本随意)：用于dll代码编写 DbgView：捕获并查看程序中由OutputDebugString输出的信息。 Hook的分类Hook无非只有两种类型，一种是通过修改数据（通常是引用的函数地址）进行的Hook，这如何理解，简单而言，很多大型程序，都需要通过调用各式各样的函数库来实现一些功能，而这种Hook就是通过修改程序调用的函数地址，改成自己写的函数，从而额外实现一些功能，实现对程序的Hook，例如IAT Hook；另一种是直接修改函数内的指令进行Hook，通过控制函数内的跳转，在函数执行时，实现一些自己的功能，然后再返回到函数使之正常运行，例如Inline Hook。这次Hook实验，采用的就是Inline Hook的手法实现。 基址与偏移在逆向分析中，通过基址和偏移定位一个函数，会非常方便，同时可以对IDA的代码进行基址重定位，从而达到和OD的同步分析。 如何确定基址呢，一个程序需要调用一个外部的库函数，或者加载dll来实现某些功能，当dll被加载进程序时，会根据默认基址0x10000000进行载入dll，但是一个程序往往会加载多个dll，此时dll会根据重定位表来对dll进行重定位，基址也会有所变化。由于dll中的导出函数，距离基址的偏移是固定的，所以只要确定需求函数与dll基址的偏移，就可以轻松定位到这个函数。如图，将程序被OD附加时，通过点击上方的E按钮，进入模块列表，左边第一栏的Base就是dll的基址，例如IM.dll在此次加载时的基址为0x62840000。 右键View name查看IM.dll的导出函数，可以发现此次加载时PostTask_Session这个函数的地址为0x628E6EF9，相减可得偏移为0xA6EF9，以后每次只需确定IM.dll的基址，就可以通过偏移直接确定PostTask_Session的地址，这在hook代码中很有用。 程序分析流程查找需要被Hook函数根据我们需要Hook的功能来看，要截取实时聊天的数据，需要对接收聊天内容的函数做手脚，猜想这个函数的函数名一定与Message有关，例如GetMessage，RecvMessage等。将程序附加进OD，点击E查看Tim加载的主要模块(dll)，找到一个KernelUtil.dll，为啥找这个dll呢？根据之前逆向，发现很多功能都是由这个dll实现的，从dll名也可以看出这是一个实现功能的dll。右键View name，查看dll的导出函数。 查看和Message有关的函数，最终会发现一个名为GetMsgAbstract的导出函数 为什么选这个函数呢？因为看名字猜测这是一个获取消息摘要的函数，也许和收发消息有一定的关联，因此可以拿出来进行试一试。 在函数的开头，下一个断点，然后在Tim内任何发送一条消息。发现程序断了下来，说明这个函数的确和消息有关。 寻找聊天内容尽管确定了，这个函数和聊天消息有关，但是只有真正找到了消息内容，这个函数才能够被利用，否则还得换另一个函数分析。首先按照F8单步执行(不步入函数，为了节省时间并快速定位)，每当一个函数(call语句)执行完后，都要观察堆栈和寄存器的变化，看看是否有重要内容。继续单步，直到发现一个函数GetMsgAbstractByElement，这个函数执行完后，会在堆栈[ebp-8]的位置出现刚刚发送的消息。 这时，我们可以进一步GetMsgAbstractByElement，来寻找发送的消息是如何出现的。 函数入口 右图开始分析，在调用GetMsgAbstactByElement之前，共push了5个参数进去，其中第一个push进去的参数0x548FA04，此时所指向的堆栈中的值为0，第三个push进去的0x548FA01，所指位置，截断了堆栈中部分数据，也无意义。第四个push进去的参数，值为0，同样也用不到。第五个push进去的参数，首先将[ebp-8]处的地址加载到eax，然后再push进去，根据前一次的步入，已知函数执行后，[ebp-8]的位置即是发送的消息，但该参数用于存放取完后的消息，并不是消息的源头。这样就只剩下第二个参数，右键ebx，Follow in dump，进入数据窗口，并没有发现消息内容的存在，因此可以猜测，这是一个包含了消息的结构体，至于如何结构结构体获取消息，还得步入GetMsgAbstactByElement函数作进一步分析。 GetMsgAbstactByElement函数按F7步入函数 可以发现，栈顶足足降低了0x70字节，所以push进来的参数暂时只能靠[ebp+偏移]来访问，关注点仍然放在第二个参数的值上，目前除了ebx仍然为此值，push进入堆栈，目前位于[ebp+0x14]的位置，值也相同，由于[ebp+0x14]是作为参数push进来的，所以ebx的值多半用不到了，接下来只需关注[ebp+0x14]的值。 同一张图，距离函数开始不远，就有一条赋值语句将[ebp+0x14]的值赋给edi，这时edi的值也会成为第二个参数的值，同样需要关注。接着继续单步分析。 单步执行到这里时发现，在一次函数调用前，将edi作为参数push了，此外又将[ebp-0x20]处的位置清零，需要留意关注，然后单步步过该函数观察变化。 该函数执行后发现，[ebp-0x20]处的位置多了个数，右键-Follow in dump，进入数据窗口发现，在0x18偏移的位置，正好是发送的消息。这下就可以确定，是此处的call dword ptr ds:[eax + 0x48]这条语句，将传入的参数结构体进行解构，找到了消息。 解构参数结构体的函数接下来重新运行程序，再发送一条新的消息并断下。单步到call dword ptr ds:[eax + 0x48]处，按F7单步进入该函数。 这个函数并不长，但是实现了很关键的功能 Code1mov ebx,dword ptr ss:[ebp+0x8] 这一步，将[ebp+8]的值给到ebx，而这个值恰好就是外部传进来的需要解构的结构体，接下来需要关注涉及到ebx的指令。 其中接下来一条，将[ebx+0x38]的地址赋给eax，但是eax接下来就被重新赋值了，所以只需向下关注，其中这里方框框住的两行，实际上做了个减法运算，之后eax的值再一次被重置。接下来的一步，ecx也被清零了。 Code1mov eax,dword ptr ds:[ebx+0x28] 这是非常关键的一步，为什么说它关键呢，因为这时候已经脱离了ebx，说明ebx已经将结构体内部的信息传递给了eax上了，接着继续看eax，同时跟进[ebx+0x28]数据窗口查看。 Code1mov eax,dword ptr ds:[eax+ecx*4] => mov eax,dword ptr ds:[eax] 由于ecx的值为0，便可做一个优化。此时再去跟进[eax]数据窗口查看。 发现，刚好有一条发送出去但是还未接收到的消息。至此大功告成，已经确定GetMsgAbstractElement函数的解构过程： 首先将外部传入的第二个参数，赋值给edi寄存器暂存 接着将edi寄存器内的值作为参数，传入到一个解析结构体的函数内 进入函数，先将原先edi寄存器保存的参数，赋值给ebx寄存器 然后将ebx+0x28所在地址的值赋值给eax寄存器 最后eax寄存器将保存的值作为地址，进入后发现，在0x18处偏移，刚好就是保存的消息。 结论验证通过上述分析可以发现，在执行GetMsgAbstractElement，就可以通过其第二个push进去的参数，获取到消息内容了。这时，我们再次运行重新，发送消息，并重新断下。通过之前推论得出的偏移来计算： Code1[[ebx+0x28]]+18 该命令可以达到一个地址，而这个地址就应该存着消息。 验证成功。尽管我们是从GetMsgAbstract进来开始分析的，但是在分析的过程中发现GetMsgAbstractElement在执行前，就可以拿到消息内容，而GetMsgAbstract，执行的过程中总会执行GetMsgAbstractElement，因此可以在GetMsgAbstractElement函数执行前做手脚，注入我们的代码实现对消息内容的Hook。至于Hook代码的编写，限于篇幅，将在下一个部分呈现","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"段描述符属性","slug":"段描述符属性","date":"2020-03-09T09:19:09.000Z","updated":"2020-03-13T13:22:38.361Z","comments":true,"path":"2020/03/09/段描述符属性/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/09/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%9E%E6%80%A7/","excerpt":"","text":"之前介绍了，段描述符是用来填充段寄存器余下位置的，然而段寄存器余下位置有80位，而段描述符仅有64位，那到底是如何填充的呢？这篇就从这个问题开始，逐步探究段描述符的属性。首先，回顾一下段描述符的结构： P位P位，位于段描述符高4字节的第15位，是判断描述符是否有效的位置。 P = 1: 该描述符有效 P = 0：该描述符无效 G位在解析G位前，先来回顾下之前的问题，64位的段描述符到底是如何分配给段寄存器余下80位的。 首先回顾一下段寄存器的结构： c123456struct SegMent { WORD selector; WORD attribute; DWORD base; DWORD limit;} 段选择子： 由mov/les/lds/lss/lfs/lgs指令直接写入16位。 属性：段描述符中高4字节的第8-23位，刚好16位，作为属性写入段寄存器。 基址：将段描述符高4字节中第24-31位，与第0-7位拼接成作为高16位，低四字节的第16-31位作为低16位，拼接成32位，作为Base，写入到段寄存器里。 (这里没用~号是因为会转义成删除线) 限长：这里就要用到G位了。首先观察段描述符结构，可以发现，在高4字节的第16-19位，与低4字节的第0-15位，都是段限长，将他们拼接起来，也就是20位，那这20位是如何扩展成32位呢？这里就要用到这部分的关键G位了，当G的值为0时，表示以字节为单位，这时，假设Limit的值加起来为FFFFF(20位)，则取0x000FFFFF作为Limit写入段寄存器；当G的值为1时，表示以4KB为单位，这样去理解，如果一个段的大小为1KB，也就是1024B或0x400B，这时，实际上能取的范围是0-1023或0-0x3FF，所以此时的Limit应该为3FF。这样当以单位为4KB来计算一个段的Limit时，若Limit的值为1，说明可以取0和1两个值，也真正的大小实际上是2，所以用2*4KB=8192B=0x2000B，但是真是可以取到的值为0-1FFF，所以此时写入段寄存器Limit的值为1FFF。同理，若段描述符Limit的值为FFFFF，真正写入段寄存器的值为FFFFFFFF(32位)。 具体的公式如下： Code12345G = 0: = LimitG = 1: (Limit + 1)*4KB - 1 = Limit*4KB + 4KB - 1 = (Limit","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"段描述符与段选择子","slug":"段描述符与段选择子","date":"2020-03-08T11:31:33.000Z","updated":"2020-03-13T13:22:59.224Z","comments":true,"path":"2020/03/08/段描述符与段选择子/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/08/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90/","excerpt":"","text":"在探究段寄存器属性时，注意到，段寄存器在读的时候，只读了16位，但是写的时候会写入96位。那么，段寄存器是如何做到写入96位的呢？今天就要研究两个新的概念：段描述符与段选择子 基础知识Windbg指令Windbg是在调试Windows系统内核时常用的一个调试器，之后也会多次用到；通过Windbg可以实现主机对虚拟机上的Windows系统进行双击调试。搭建双击调试环境可以参考此贴：https://blog.csdn.net/q1007729991/article/details/52710390 这里，简单介绍一下，在研究段描述符和段选择子所需用到的几个Windbg指令： 命令 含义 r 查看和修改寄存器 dd 以4字节分隔，显示指定内存区域的数据内容 dq 以8字节分隔，显示指定内存区域的数据内容 第二个d和q分别是dword和qword的意思，第一个d是一个查看内存的指令，以后会详细说明。 汇编基础这里补充一点汇编基础，如何在确保，给一个拥有6个元素的char型数组赋值时，确保元素所在高位或者低位呢？ 通过观察反汇编可以看出，0x78处在 [ebp-8]的位置上，距离ebp相对较远；0x12处在[ebp-5]的位置上，距离ebp相对较近，两者差了4个字节，我们可以假象在地址空间中的位置如下表： 地址 值 0x12ff40(随便取个值) 0x78 0x12ff41 0x56 0x12ff42 0x34 0x12ff43 0x12 0x12ff44 0x23 0x12ff45 0x00 而Windows操作系统是小端模式，也就是高字节保存在高地址中；例如0x12在0x12345678这个数里属于高字节，0x12所在的地址位0x12ff43相当于0x78位于高地址，所以在赋值时，需要把0x12放到高地址中，根据小端模式在内存中的排列可知，若想确定一个实际值为0x12345678的数，在内存的排列大概是”78563412“这种形势，因此在赋值时按照如下方式： 这里还有一个坑是，赋值时不要加’ ‘，因为一个字节的数不止一个字符，不能放到单引号里。 GDT，LDTGDT和LDT分别指全局描述符表和局部描述符表。由于Windows系统没有使用LDT表，所以可以忽略这个表。而GDT表，表里存储的就是段描述符。 了解GDT表，需要先知道这个表有多大，存在哪里。这时需要借助一个寄存器gdtr，这是个48位的寄存器，其中32位存的是GDT表的位置，16位存的是GDT表的大小；可以通过以下指令进行查询。 由图可知，当前虚拟机中的操作系统，gdt表位于0x8003f000的位置，大小是0x03ff，也就是说从0x8003f000~0x8003f3ff这段内存中，存放着gdt表。 段描述符当执行以下语句时： Code1mov ds, ax CPU会去查表，根据ax的值决定查看GDT表还是LDT表，以及查找表的什么位置，查出哪些数据 首先查看一下GDT表，由于段描述符大小是8字节/64位，所以采用dq指令进行查看。 这里查看了GDT表0x80个字节大小的内存，一个段描述符的大小是8字节，所以显示了16个段描述符。 接下来看一下段描述符表的结构 可以发现，在段描述符中，有着Base，Limit，还有各种Attribute，这些就是从段描述符中查找的数据，并写入段寄存器剩下的80位里。那么有了GDT表和段描述符，那么究竟该选择哪一个段描述符的数据写入段寄存器呢？这就涉及到另一个结构：段选择子 段选择子“段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符”。 这句话怎么理解，怎么又是16位的段描述符，又是GDT表的段描述符？首先，段的Base，Limit以及Attribute都是由GDT表的段描述符来决定的，那么到底是由哪个段描述符来决定的？为了确定这个段描述符，引入了段选择子这个结构，段选择子，指向了GDT表中某一个段描述符，这样就可以把该段描述符的数据写入到段寄存器内了。所以说，段选择子，是一个段描述符的描述符。下面是段选择子的结构。 由图，结构非常简单，各个位的含义也比较好理解。这里有个小g巧，段选择子一共16位，由于Windows没有使用LDT表，所以TI位永远是0。请求特权级别一般也只有0和3，所以段选择子最后4位的值只有4种组合：0000, 0011, 1000, 1011 加载段描述符至段寄存器除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器。 CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，以后的文章会说到。 Code1les ecx,fword ptr ds:[buffer] //取buffer高2个字节给es，低4个字节给ecx 这里的buffer是一个地址，存了6个字节的数，例如定义buffer为一个6个元素的char型数组。这里的fword指的是三字，也就是6个字节 注意：在数值上需要要求RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"浅谈对称加密传输","slug":"浅谈对称加密传输","date":"2020-03-07T09:19:26.000Z","updated":"2020-03-09T13:59:14.424Z","comments":true,"path":"2020/03/07/浅谈对称加密传输/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/07/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/","excerpt":"","text":"看到crownless一篇关于Tor原理解析的文章，涉及到了加密传输的部分，以前没仔细理解，现在用通俗的语言记录下来。 基础概要对称加密所谓对称加密，就是通信双方，在发送和接收数据时，使用同一个密钥key对数据进行加密与解密。发送方和接收方必须在数据传送前商定好秘钥。 优点：加密速度快、效率高。 缺点：一旦密钥泄露，加密信息不再安全 25519曲线Curve25519椭圆曲线，是基于蒙哥马利曲线的密钥协商算法，具体如下 蒙哥马利曲线算法，可以做到”Time-constant”，也就是说不论他们进行运算的数值是多少，他们所花的时间是相同的，可以规避“ 时间旁路 ”攻击。（crownless文中有提到这是一种很神奇的可以在不安全的信道上建立共享的对称密钥的方法） 传输过程密钥获取Bob为了访问Alice，先访问Tor的目录服务器，获取一部分Tor节点的IP地址，并从中随机选择三个节点的IP地址A、B、C。然后，Bob会先和A节点通过Curve25519椭圆曲线算法以及协商所需的参数，协商一个对称密钥keyA；这时A节点会将Bob协商密钥所需参数发送给Bob。Bob通过算法计算出对称密钥keyA。之后，Bob和节点A之间就会用这把对称密钥keyA进行加密通信。 然后，Bob把B的IP地址和与B协商密钥所需的参数用对称密钥keyA加密后发送给A。A用keyA解密后，将Bob与B协商密钥所需的参数发送到B的IP地址。B收到参数后产生了对称密钥keyB，并将与Bob协商密钥所需的参数发还给A。A将参数通过keyA加密后发还给Bob。Bob用keyA解密后通过算法计算出对称密钥keyB。Bob通过相同的方法和C协商出keyC。至此，Bob有了三把钥匙keyA、keyB、keyC。 需要注意的是，当把协商密钥所需的参数，发给相应的节点时，若一方还没收到协商的参数并生成密钥，另一方就不会对协商参数进行加密。在B收到参数生成密钥keyB后，将与Bob协商密钥所需的参数发还给A，此时不会对协商参数用keyB进行加密，以保证另一方可以拿到参数生成密钥。但已经进行加密通信的双方，则会使用密钥加密通信数据。 加密传输Bob往Alice发送数据包时，先将数据Data用keyC加密，再用keyB加密，再用keyA加密，就好像层层包裹一样，然后发往节点A。节点A解开一层加密，发往节点B。节点B解开一层加密，发往节点C。节点C解开一层加密，得到Bob发往Alice的明文，发送给Alice。 参考文章： https://bbs.pediy.com/thread-248850.htm https://www.jianshu.com/p/5dba044f67b1","categories":[],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"http://cataloc.gitee.io/blog/tags/NetWork/"}]},{"title":"探究段寄存器","slug":"探究段寄存器","date":"2020-03-06T15:00:07.000Z","updated":"2020-03-08T10:35:10.662Z","comments":true,"path":"2020/03/06/探究段寄存器/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/06/%E6%8E%A2%E7%A9%B6%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"被忽视的ds1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域","text":"被忽视的dsCode1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域 这些是OllyDbg调试器显示出当前程序运行时段寄存器的各部分属性的值。接下来分析这些值的来源和含义。 段寄存器的读写在后面的部分会经常用到段寄存器的读写，这里先说明一下： 读： Code1mov ax, fs 写： Code1mov ds, ax 段寄存器在读的时候，只读了16位，但是写的时候会写入96位。 注意：ldtr和tr段寄存器不能用mov指令进行读写 段寄存器结构Code123456struct SegmentReg { WORD selector; WORD attribute; DWORD base; DWORD limit;} 由段寄存器的结构可知，段寄存器共96位，由16位的段选择子，16位的段属性，32位的base和32位的limit组成。 打印ds寄存器的值，发现只能显示0x0023，也就是段选择子那16位。不是说好的共96位吗？实际上，剩下来80位是不可见的部分，只不过OD也展示出来了，接下来证明每个属性的存在。 段基址Code1mov eax, dword ptr ds:[0] 理论上，上面这条语句是无法执行成功的，因为零地址是不允许访问的（因为没有给零地址挂物理页） 但是上述程序可以成功执行（这里不使用ds，原因是vc6作者对ds做过优化，写成ds将编译不过去），说明了这里访问的不是零地址，而是其它地址，也就是说，段寄存器修改了写入数据的地址，证明了段基址的存在。 这里真正的将数据写入eax的地址是： Code1gs.base + 0x0 以下是常见段的基址 段寄存器 Base ES 0 CS 0 SS 0 DS 0 FS 0x7FFDE000 GS - 由于将fs段的值赋给了gs段，因此写入eax寄存器的是0x7FFDE000地址上的值。 段属性 上面两段程序的差别仅仅在于插入的汇编的第一条指令，mov ax, cs 和 mov ax, ss。造成结果不同的原因是，ss段寄存器是可读、可写的，而cs段寄存器是可读、可执行，但是不可写；因此在试图向cs段寄存器所指向的基址+偏移（既[ ]内的值）是会发生访问违例的，这也说明了，不同的段寄存器，属性是不同的，证明了段属性的存在。 段限长 又出现了访问违例的情况，此处var的值为0x1000，超过了fs段寄存器的Limit：0xFFF，所以此时已经不能通过fs段来访问fs.base+0x1000这个地址了，这说明段寄存器也有一定的管辖范围，超出这个范围，就没有权限访问了 总结这次的笔记主要探究了段寄存器的属性和结构，大致整理如下 段寄存器 段选择子 属性 基址 限长 ES 0x0023 RW 0 0xFFFFFFFF CS 0x001B RX 0 0xFFFFFFFF SS 0x0023 RW 0 0xFFFFFFFF DS 0x0023 RW 0 0xFFFFFFFF FS 0x003B RW 0x7FFDE000 0xFFF GS - - - - 参考文章：https://blog.csdn.net/q1007729991/article/details/52537943 参考教程：https://www.bilibili.com/video/av68700135?p=7","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"初见保护模式","slug":"初见保护模式","date":"2020-03-05T09:19:09.000Z","updated":"2020-03-09T13:58:29.632Z","comments":true,"path":"2020/03/05/初见保护模式/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/05/%E5%88%9D%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","excerpt":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。","text":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。 保护模式的引入提供了段间的保护机制，防止程序间胡乱访问地址带来的问题，同时也扩大了访问的内存空间（没整明白8086实模式的寻址方式，看结果，保护模式的确扩大了寻址空间）。 段、页机制段，页机制均是CPU所提供的，操作系统利用CPU提供的段，页机制，实现对虚拟地址空间的管理，使得操作系统在保护模式上有序，”安全”的工作。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]}]}