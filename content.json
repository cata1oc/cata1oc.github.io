{"meta":{"title":"cataLoc's Blog","subtitle":"","description":"","author":"cataLoc","url":"http://yoursite.com","root":"/blog/"},"pages":[{"title":"categories","date":"2020-03-07T03:27:53.000Z","updated":"2020-03-07T03:27:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"messageboard","date":"2020-03-07T03:28:09.000Z","updated":"2020-03-07T03:28:12.000Z","comments":true,"path":"messageboard/index.html","permalink":"http://yoursite.com/messageboard/index.html","excerpt":"","text":""},{"title":"link","date":"2020-03-07T03:28:51.000Z","updated":"2020-03-07T03:28:52.000Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":""},{"title":"movies","date":"2020-03-07T03:28:28.000Z","updated":"2020-03-07T03:28:30.000Z","comments":true,"path":"movies/index.html","permalink":"http://yoursite.com/movies/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-03-07T03:28:40.000Z","updated":"2020-03-07T03:28:42.000Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""},{"title":"music","date":"2020-03-07T03:28:22.000Z","updated":"2020-03-07T03:28:24.000Z","comments":true,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-07T03:27:42.000Z","updated":"2020-03-07T03:27:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"初见保护模式","slug":"初见保护模式","date":"2020-03-07T11:07:39.846Z","updated":"2020-03-07T09:24:50.000Z","comments":true,"path":"2020/03/07/初见保护模式/","link":"","permalink":"http://yoursite.com/2020/03/07/%E5%88%9D%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","excerpt":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。","text":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。 保护模式的引入提供了段间的保护机制，防止程序间胡乱访问地址带来的问题，同时也扩大了访问的内存空间（没整明白8086实模式的寻址方式，看结果，保护模式的确扩大了寻址空间）。 段、页机制段，页机制均是CPU所提供的，操作系统利用CPU提供的段，页机制，实现对虚拟地址空间的管理，使得操作系统在保护模式上有序，”安全”的工作。","categories":[],"tags":[]},{"title":"浅谈对称加密传输","slug":"浅谈对称加密传输","date":"2020-03-07T09:19:26.000Z","updated":"2020-03-07T13:23:16.237Z","comments":true,"path":"2020/03/07/浅谈对称加密传输/","link":"","permalink":"http://yoursite.com/2020/03/07/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/","excerpt":"","text":"看到crownless一篇关于Tor原理解析的文章，涉及到了加密传输的部分，以前没仔细理解，现在用通俗的语言记录下来。 基础概要对称加密所谓对称加密，就是通信双方，在发送和接收数据时，使用同一个密钥key对数据进行加密与解密。发送方和接收方必须在数据传送前商定好秘钥。 优点：加密速度快、效率高。 缺点：一旦密钥泄露，加密信息不再安全 25519曲线Curve25519椭圆曲线，是基于蒙哥马利曲线的密钥协商算法，具体如下 蒙哥马利曲线算法，可以做到”Time-constant”，也就是说不论他们进行运算的数值是多少，他们所花的时间是相同的，可以规避“ 时间旁路 ”攻击。（crownless文中有提到这是一种很神奇的可以在不安全的信道上建立共享的对称密钥的方法） 传输过程密钥获取Bob为了访问Alice，先访问Tor的目录服务器，获取一部分Tor节点的IP地址，并从中随机选择三个节点的IP地址A、B、C。然后，Bob会先和A节点通过Curve25519椭圆曲线算法以及协商所需的参数，协商一个对称密钥keyA；这时A节点会将Bob协商密钥所需参数发送给Bob。Bob通过算法计算出对称密钥keyA。之后，Bob和节点A之间就会用这把对称密钥keyA进行加密通信。 然后，Bob把B的IP地址和与B协商密钥所需的参数用对称密钥keyA加密后发送给A。A用keyA解密后，将Bob与B协商密钥所需的参数发送到B的IP地址。B收到参数后产生了对称密钥keyB，并将与Bob协商密钥所需的参数发还给A。A将参数通过keyA加密后发还给Bob。Bob用keyA解密后通过算法计算出对称密钥keyB。Bob通过相同的方法和C协商出keyC。至此，Bob有了三把钥匙keyA、keyB、keyC。 需要注意的是，当把协商密钥所需的参数，发给相应的节点时，若一方还没收到协商的参数并生成密钥，另一方就不会对协商参数进行加密。在B收到参数生成密钥keyB后，将与Bob协商密钥所需的参数发还给A，此时不会对协商参数用keyB进行加密，以保证另一方可以拿到参数生成密钥。但已经进行加密通信的双方，则会使用密钥加密通信数据。 加密传输Bob往Alice发送数据包时，先将数据Data用keyC加密，再用keyB加密，再用keyA加密，就好像层层包裹一样，然后发往节点A。节点A解开一层加密，发往节点B。节点B解开一层加密，发往节点C。节点C解开一层加密，得到Bob发往Alice的明文，发送给Alice。 参考文章： https://bbs.pediy.com/thread-248850.htm https://www.jianshu.com/p/5dba044f67b1","categories":[],"tags":[]},{"title":"探究段寄存器","slug":"探究段寄存器","date":"2020-03-06T15:00:07.000Z","updated":"2020-03-07T09:24:10.000Z","comments":true,"path":"2020/03/06/探究段寄存器/","link":"","permalink":"http://yoursite.com/2020/03/06/%E6%8E%A2%E7%A9%B6%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"被忽视的ds1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 等。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域","text":"被忽视的dsCode1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 等。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域 这些是OllyDbg调试器显示出当前程序运行时段寄存器的各部分属性的值。接下来分析这些值的来源和含义。 段寄存器的读写在后面的部分会经常用到段寄存器的读写，这里先说明一下： 读： Code1mov ax, fs 写： Code1mov ds, ax 段寄存器在读的时候，只读了16位，但是写的时候会写入96位。下面将逐步证明为何写入了96位。 段寄存器结构Code123456struct SegmentReg { WORD selector; WORD attribute; DWORD base; DWORD limit;} 由段寄存器的结构可知，段寄存器共96位，由16位的段选择子，16位的段属性，32位的base和32位的limit组成。 打印ds寄存器的值，发现只能显示0x0023，也就是段选择子那16位。不是说好的共96位吗？实际上，剩下来80位是不可见的部分，只不过OD也展示出来了，接下来证明每个属性的存在。 段基址Code1mov eax, dword ptr ds:[0] 理论上，上面这条语句是无法执行成功的，因为零地址是不允许访问的（因为没有给零地址挂物理页） 但是上述程序可以成功执行（这里不使用ds，原因是vc6作者对ds做过优化，写成ds将编译不过去），说明了这里访问的不是零地址，而是其它地址，也就是说，段寄存器修改了写入数据的地址，证明了段基址的存在。 这里真正的将数据写入eax的地址是： Code1gs.base + 0x0 以下是常见段的基址 段寄存器 Base ES 0 CS 0 SS 0 DS 0 FS 0x7FFDE000 GS - 由于将fs段的值赋给了gs段，因此写入eax寄存器的是0x7FFDE000地址上的值。 段属性 上面两段程序的差别仅仅在于插入的汇编的第一条指令，mov ax, cs 和 mov ax, ss。造成结果不同的原因是，ss段寄存器是可读、可写的，而cs段寄存器是可读、可执行，但是不可写；因此在试图向cs段寄存器所指向的基址+偏移（既[ ]内的值）是会发生访问违例的，这也说明了，不同的段寄存器，属性是不同的，证明了段属性的存在。 段限长 又出现了访问违例的情况，此处var的值为0x1000，超过了fs段寄存器的Limit：0xFFF，所以此时已经不能通过fs段来访问fs.base+0x1000这个地址了，这说明段寄存器也有一定的管辖范围，超出这个范围，就没有权限访问了 总结这次的笔记主要探究了段寄存器的属性和结构，大致整理如下 段寄存器 段选择子 属性 基址 限长 ES 0x0023 RW 0 0xFFFFFFFF CS 0x001B RX 0 0xFFFFFFFF SS 0x0023 RW 0 0xFFFFFFFF DS 0x0023 RW 0 0xFFFFFFFF FS 0x003B RW 0x7FFDE000 0xFFF GS - - - - 参考文章：https://blog.csdn.net/q1007729991/article/details/52537943 参考教程：https://www.bilibili.com/video/av68700135?p=7","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://yoursite.com/tags/Windows%E5%86%85%E6%A0%B8/"}]}]}