{"meta":{"title":"cataLoc's Blog","subtitle":"","description":"","author":"cataLoc","url":"http://cataloc.gitee.io/blog","root":"/blog/"},"pages":[{"title":"link","date":"2020-03-07T03:28:51.000Z","updated":"2020-03-07T03:28:52.000Z","comments":true,"path":"link/index.html","permalink":"http://cataloc.gitee.io/blog/link/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-07T03:27:53.000Z","updated":"2020-03-07T03:27:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://cataloc.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"movies","date":"2020-03-07T03:28:28.000Z","updated":"2020-03-07T03:28:30.000Z","comments":true,"path":"movies/index.html","permalink":"http://cataloc.gitee.io/blog/movies/index.html","excerpt":"","text":""},{"title":"messageboard","date":"2020-03-07T03:28:09.000Z","updated":"2020-03-07T03:28:12.000Z","comments":true,"path":"messageboard/index.html","permalink":"http://cataloc.gitee.io/blog/messageboard/index.html","excerpt":"","text":""},{"title":"music","date":"2020-03-07T03:28:22.000Z","updated":"2020-03-07T03:28:24.000Z","comments":true,"path":"music/index.html","permalink":"http://cataloc.gitee.io/blog/music/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-03-07T03:28:40.000Z","updated":"2020-03-07T03:28:42.000Z","comments":true,"path":"photos/index.html","permalink":"http://cataloc.gitee.io/blog/photos/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-07T03:27:42.000Z","updated":"2020-03-07T03:27:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://cataloc.gitee.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"API函数的调用过程（系统服务表）","slug":"API函数的调用过程（系统服务表）","date":"2020-03-27T15:49:50.000Z","updated":"2020-03-27T15:50:16.020Z","comments":true,"path":"2020/03/27/API函数的调用过程（系统服务表）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/","excerpt":"","text":"s","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（保存现场）","slug":"API函数的调用过程（保存现场）","date":"2020-03-26T01:30:03.000Z","updated":"2020-03-27T13:45:22.749Z","comments":true,"path":"2020/03/26/API函数的调用过程（保存现场）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/26/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA%EF%BC%89/","excerpt":"","text":"现在我们知道如何进入0环了，有两种方式，通过中断门或者快速调用。上一篇中最后留下了几个问题，其中一个就是关于如何保存那些3环寄存器原先的值（俗称保存现场），从而能够在执行完0环实现的功能后，顺利的返回到3环，今天我们就来探究一下这个问题，首先我们来认识几个结构：Trap_Frame，ETHREAD/KTHREAD，KPCR _Trap_Frame在Windbg中通过dt _KTrap_Frame进行查看 （0x7c~0x88）在保护模式下没有被使用，只在虚拟8086模式中用得到 （0x68~0x78）中断门进0环时，用于存储3环的CS，SS，ESP，EIP，EFLAGS （0x48~0x64）保存现场 （0x00~0x44）调式及其它作用 简要介绍完了Trap_Frame结构，了解了这是保存现场用到的结构，后面在分析KiSystemService时，会介绍保存现场的主要过程。 ETHREAD&KTHREADETHREAD（执行体线程块）是执行体层上的线程对象的数据结构。在Windows内核中，每个进程的每一个线程都对应着一个ETHREAD数据结构。 在Windbg中通过dt _ETHREAD进行查看 ETHREAD结构内嵌了一个KTHREAD对象作为第一个数据成员，因此一个指向ETHREAD对象的指针同时也是一个指向KTHREAD对象的指针。 在Windbg中通过dt _KTHREAD进行查看 大致先解下这些结构即可，后续在介绍到线程与进程处时，会慢慢分析各个字段。 KPCR描述： 全称为CPU控制区（Processor Control Region） 每一个CPU都有一个CPU控制区，跟TLB一样，一核一个KPCR 指令： dt _KPCR：查看KPCR结构 dd KeNumberProcessors：查看KPCR数量 dd KiProcessorBlock：查看KPCR位置 由于当前虚拟机只分配了一个核，所以数量是1 同理，因为单核，这里只显示了一个值，这个地址显示的是ffdff120，也就是KPCR偏移0x120的位置。KPCR偏移0x120的位置是 _KPRCB，可以理解为扩展的KPCR KiSystemService了解完上面介绍的结构，下面我们就可以分析一下0环函数KiSystemService，到底是如何保存现场的。 函数主体并不长，按照填充的结构不同我们来逐步分析。 0x1Code123456804df631 6a00 push 0 //ErrorCode804df633 55 push ebp804df634 53 push ebx804df635 56 push esi804df636 57 push edi804df637 0fa0 push fs 首先来看这一段，为什么要push 0起手呢？ 这里先回顾一下Trap_Frame结构。 这是一个结构，换句话说，就是进入0环后的堆栈将会像这种形式组织起来，在刚进0环是，esp是位于 (0x78) 的位置，我们知道，通过中断门进0环时，会将3环的寄存器压栈，包括CS，SS，EIP，ESP和EFLAGS。因此在进入0环后，ESP的位置是位于 (0x68) 处。虽然2E号中断只会压入5个值，但是有些情况会压入6个值，而第6个值，就是ErrCode，为了对齐，保持堆栈平衡，操作系统这里会自己补一个0，这也就解释了为什么第一步是push 0。 接下来，就是保存ebp，ebx，esi，esi，fs依次压栈，保存到Trap_Frame结构中描述的位置。 0x2Code1234567804df639 bb30000000 mov ebx,30h804df63e 8ee3 mov fs,bx //写入fs段寄存器804df640 ff3500f0dfff push dword ptr ds:[0FFDFF000h] //保存旧的异常链表(ExceptionList)804df646 c70500f0dfffffffffff mov dword ptr ds:[0FFDFF000h],0FFFFFFFFh //将新的异常链表赋值为-1804df650 8b3524f1dfff mov esi,dword ptr ds:[0FFDFF124h] //获取当前线程KTHREAD804df656 ffb640010000 push dword ptr [esi+140h] //将先前模式(PreviousMode)压栈804df65c 83ec48 sub esp,48h //提升堆栈（栈顶执行Trap_Frame头） 我们来看这部分做了什么事 首先是将段选择子0x30写入fs段寄存器 根据段选择子确定段描述符，然后可以发现fs指向的地方(0xffdff000)刚好是KPCR这个结构。 然后压栈了KPCR首地址位置的值 可以发现，KPCR首地址位置存的是异常链表(ExceptionList)，这里压栈了旧的异常链表，并将异常链表的值置为-1。至于异常链表的结构，留到后面再讲。 接着获取到KPCR + 0x124位置的值，并存入esi，然后将esi+0x140处的值压栈 可以发现KPCR+0x124处（赋给esi）的值，存的是当前线程（CurrentThread）的KTHREAD，我们再找到(esi)KTHREAD+0x140偏移，发现压栈的字段叫做先前模式（PerviousMode） 最后提升堆栈0x48个字节 经过这一部分的操作后，堆栈栈顶刚好指向_Trap_Frame的首地址，并完成了异常链表和先前模式的压栈操作。 0x3Code12345678804df65f 8b5c246c mov ebx,dword ptr [esp+6Ch] //取进入中断门压栈的CS804df663 83e301 and ebx,1 //计算出调用中断门前的权限804df666 889e40010000 mov byte ptr [esi+140h],bl //重新填写KTHREAD中的先前模式 804df66c 8bec mov ebp,esp //让ebp指向_Trap_Frame首地址804df66e 8b9e34010000 mov ebx,dword ptr [esi+134h] 804df674 895d3c mov dword ptr [ebp+3Ch],ebx //将旧的_Trap_Frame保存到edx中804df677 89ae34010000 mov dword ptr [esi+134h],ebp //更新_Trap_Frame804df67d fc cld 继续分析这一部分 我们来看前3行，它做了什么事呢，先取出_Trap_Frame 0x6C偏移处的值，即进入中断门前，程序CS的值，然后和1进行了与运算，并将bl的值，填入上面提到的先前模式 为什么和1进行与运算就可以算出先前模式呢？难道不直接填3吗？首先我们知道，Windows只用了0环和3环，其次，即使执行中断门，执行前的程序也可以是0环程序，所以保守起见，这里和CPL的最低位进行与运算；若结果为1，说明是3环程序执行了中断门，若为0，说明是0环程序执行的中断门。从而算出先前模式，并填入到当前线程KTHREAD的先前模式字段中。 上面3行更新了先前模式，接下来4行的作用就是更新了_Trap_Frame，我们知道栈顶指向Trap_Frame的首地址，现在让栈底也指向Trap_Frame的首地址，便于寻址。 由0x2的分析可知esi指向KTHREAD，KTHREAD+0x134则指向Trap_Frame，这里的Trap_Frame是旧的地址（这里则是Null），因此将它保存至堆栈，再将现在的Trap_Frame的地址写入，也就完成了更新。 cld指令修改了EFLAGS寄存器的DF位 0x4Code12345678910804df67e 8b5d60 mov ebx,dword ptr [ebp+60h] //取3环的ebp给ebx804df681 8b7d68 mov edi,dword ptr [ebp+68h] //取3环的eip给edi804df684 89550c mov dword ptr [ebp+0Ch],edx //edx存的是3环第一个参数的地址，赋到_Trap_Frame的DbgArgPointer的位置804df687 c74508000ddbba mov dword ptr [ebp+8],0BADB0D00h //将操作系统用的标志赋给DbgArgMark804df68e 895d00 mov dword ptr [ebp],ebx //将3环的ebp赋值到DbgEbp804df691 897d04 mov dword ptr [ebp+4],edi //将3环的eip赋值到DbgEip804df694 f6462cff test byte ptr [esi+2Ch],0FFh //判断DebugActive处的值是否为-1804df698 0f858efeffff jne nt!Dr_kss_a (804df52c) //跳转至调试寄存器保存函数804df69e fb sti804df69f e9dd000000 jmp nt!KiFastCallEntry+0x8d (804df781) 来看最后一部分 前6行，很好理解，主要是对_Trap_Frame调试部分的填充，一张图就可以概括 接下来的两行，会比较esi+0x2C的位置是否为-1 这个地方值如果不是-1，说明处于调试状态，紧接着会跳转到Dr_kss_a这个例程里，这个例程作用是将Dr0~Dr7这些调试寄存器的值保存到_Trap_Frame中，用于调试。同样的，了解了这个字段后，我们可以写一个程序，不断的修改这个值，将DebugActive这个值置为-1，这样程序就不会保存调试寄存器，也就无法调试，这是一种反调试的手段。 最后，程序会跳转到KiFastCallEntry+0x8D这个位置继续执行，而这个位置，也是KiFastCallEntry执行完后跳转的地方。之所以分了两种方式，是因为中断门进0环时，压栈了5个值（ESP，EIP，CS，SS，EFLAGS）而快速调用没有，导致它们在填写_Trap_Frame结构的方式不同，但是在填完后，保存现场以后，后面执行的函数就一样了。 KiFastCallEntryKiFastCallEntry保存现场的方式略微发杂，因为没有通过中断门对3环的5个寄存器进行压栈。由于分析的代码较多，这部分就不贴图了，可以参照KiSystemService的方法，在Windbg中找到对应结构进行分析。 KiFastCallEntry要分为两个部分来看，第一个部分，是和KiSystemService所做的一样，对_Trap_Frame结构的填充，进行保存现场。完了之后，第二个部分，从KiFastCallEntry+0x8D开始，这是KiSystemService执行完后跳转的地方，也是KiFastCallEntry顺序执行的地方，是双方都要执行的代码，这也意味着，从这个地方开始，两种进0环的方式就统一了。 本篇只介绍第一部分，看看KiFastCallEntry在填充_Trap_Frame时与KiSystemService有何不同吧。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849kd> u KiFastCallEntry L55nt!KiFastCallEntry:804df6f0 b923000000 mov ecx,23h804df6f5 6a30 push 30h804df6f7 0fa1 pop fs //令fs寄存器指向KPCR首地址804df6f9 8ed9 mov ds,cx //令ds=0x23804df6fb 8ec1 mov es,cx //令es=0x23804df6fd 8b0d40f0dfff mov ecx,dword ptr ds:[0FFDFF040h] //另ecx指向TSS 804df703 8b6104 mov esp,dword ptr [ecx+4] //取TSS中的esp0赋值给当前esp804df706 6a23 push 23h //将3环ss压栈(_Trap_Frame+0x78)804df708 52 push edx //将3环栈顶esp3压栈(+0x74)804df709 9c pushfd //将eflags寄存器压栈(+0x70)804df70a 6a02 push 2 804df70c 83c208 add edx,8 //获取外部第一个参数的位置(ReadProcessMemory共Call804df70c //了两次才到sysenter，因此压栈了2个返回地址，需要+8)804df70f 9d popfd //将2写入eflags寄存器804df710 804c240102 or byte ptr [esp+1],2 //没看懂有啥用804df715 6a1b push 1Bh //将3环cs压栈(+0x6c)804df717 ff350403dfff push dword ptr ds:[0FFDF0304h] //将3环eip压栈(+0x68)804df71d 6a00 push 0 //将Errcode压栈(+0x64)804df71f 55 push ebp //将3环ebp压栈(+0x60)804df720 53 push ebx //将3环ebx压栈(0x5c)804df721 56 push esi //将3环esi压栈(+0x58)804df722 57 push edi //将3环edi压栈(+0x54)804df723 8b1d1cf0dfff mov ebx,dword ptr ds:[0FFDFF01Ch] //将指向KPCR自己的指针存到ebx里804df729 6a3b push 3Bh //将3环fs压栈(+0x50)804df72b 8bb324010000 mov esi,dword ptr [ebx+124h] //将当前线程的KTHREAD存到esi804df731 ff33 push dword ptr [ebx] //将异常链表(ExceptionList)压栈(+0x4c)804df733 c703ffffffff mov dword ptr [ebx],0FFFFFFFFh //更新异常链表的值为-1804df739 8b6e18 mov ebp,dword ptr [esi+18h] //通过KTHREAD的InitialStack更新0环栈底804df73c 6a01 push 1 //将旧的先前模式(PreviousMode)压栈(+0x48)804df73e 83ec48 sub esp,48h //令esp指向_Trap_Frame首地址804df741 81ed9c020000 sub ebp,29Ch //这部分没看懂，舒默的分析是计算初试stack的Trap_Frame基址804df741 //这个0x29c的值等于：NPX_FRAME_LENGTH + TRAP_FRAME_LENGTH804df741 //其中NPX_FRAME_LENGTH = 0x210, TRAP_FRAME_LENGTH = 0x8c804df747 c6864001000001 mov byte ptr [esi+140h],1 //更新先前模式为1804df74e 3bec cmp ebp,esp //比较两个Trap_Frame基址，若不同则跳转去处理804df750 0f8572ffffff jne nt!KiFastCallEntry2+0x24 (804df6c8)804df756 83652c00 and dword ptr [ebp+2Ch],0 //将Dr7的值置0(+0x2c)804df75a f6462cff test byte ptr [esi+2Ch],0FFh //判断当前线程的DebugActive是否为-1804df75e 89ae34010000 mov dword ptr [esi+134h],ebp //更新当前线程的_Trap_Frame基址804df764 0f8546feffff jne nt!Dr_FastCallDrSave (804df5b0)//若DebugActive不为-1则跳转804df76a 8b5d60 mov ebx,dword ptr [ebp+60h] //将3环的Ebp赋值给当前ebx804df76d 8b7d68 mov edi,dword ptr [ebp+68h] //将3环的Eip赋值给当前edi804df770 89550c mov dword ptr [ebp+0Ch],edx //将第一个参数的地址存到DbgArgPointer804df773 c74508000ddbba mov dword ptr [ebp+8],0BADB0D00h //将0x0BADB0D00存到DbgArgMark804df77a 895d00 mov dword ptr [ebp],ebx //将3环ebp存到DbgEbp804df77d 897d04 mov dword ptr [ebp+4],edi //将3环eip存到DbgEip804df780 fb sti //设置EFLAGS的IF位，允许中断发生 这里就先分析到这，至于从KiFastCallEntry+0x8D开始的第二部分，由于是KiSystemService和KiFastCallEntry的公共代码，两种进0环的方式都会执行，就不再本篇中分析了，留到下一篇介绍系统服务表和SSDT时再介绍。 总结这一篇通过学习_Trap_Frame，KTHREAD，KPCR这些结构，分析KiSystemService&KiFastCallEntry了解了在进入0环后，保存现场的方式。尽管采用了两种不同的手段，但是思路总体来说是一样的，就是通过填充Trap_Frame结构完成3环寄存器的保存。在下一篇中，我们将继续探究，在保存完现场后，程序是如何找到想要执行的函数的。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=40 参考文章：https://blog.csdn.net/qq_41988448/article/details/102886413 ​ https://blog.csdn.net/qq_38474570/article/details/103652993","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（3环进0环）","slug":"API函数的调用过程（3环进0环）","date":"2020-03-25T12:40:57.000Z","updated":"2020-03-25T16:44:04.591Z","comments":true,"path":"2020/03/25/API函数的调用过程（3环进0环）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/25/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E8%BF%9B0%E7%8E%AF%EF%BC%89/","excerpt":"","text":"上一篇中分析了ReadProcessMemory函数的3环部分，它实际上没有做太多工作，只是提供了一个调用0环函数的接口，今天我们接着向下分析，看看函数是如何进入0环的。 _KUSER_SHARED_DATA_KUSER_SHARED_DATA结构 上一篇讲到了NtReadVirtualMemory这部分，调用了一个函数地址0x7FFE0300。那这个地址有什么用呢？这就要介绍一个新的结构_KUSER_SHARED_DATA： 在User层和Kernel层分别定义了一个_KUSER_SHARED_DATA结构区域，用于User层和Kernel层共享某些数据 它们使用固定的地址值映射，_KUSER_SHARED_DATA结构区域在User和Kernel层地址分别为： User层地址为：0x7FFE0000 Kernel层地址为：0xFFDF0000 虽然指向的是同一个物理页，但在User层是只读的，在Kernel层是可写的 SystemCall现在我们知道，0x7FFE0000处是_KUSER_SHARED_DATA结构，使用dt指令查看结构，查找0x300偏移处，也就是0x7FFE0300的位置，这个字段是SystemCall 那这个SystemCall有什么用呢？ SystemCall的作用是选择以什么方式进入0环。这要看CPU是否支持sysenter/sysexit 支持：ntdll.dll!KiFastSystemCall() 不支持：ntdll.dll!KiFastSystemCall() 那如何看CPU是否支持sysenter/sysexit指令呢？ （OD打开任一程序）将eax置1（参数） 将ecx，edx置0（方便查看） 执行指令cpuid 查看edx的SEP位（下标11的位置），若值为1，说明支持sysenter/sysexit FBFF -> 1111 1011 1111 1111 说明本机支持sysenter/sysexit KiIntSystemCall进0环在学过调用门，中断门后，我们知道，凡是提权（例如进0环），都伴随着寄存器中的值发生改变，包括CS，SS，EIP，ESP。所以我们分别分析一下两种进0环方式，看看他们是如何修改寄存器的值的，先从KiIntSystemCall开始。 获取提权后寄存器的值 KiIntSystemCall进0环的方式非常简单，就是我们最熟悉中断门。（这里第一条指令的作用是获取参数的首地址） 中断门就很熟悉了，进入IDT表看下0x2E对应的门描述符 根据中断门描述符，可以很快得到： CS = 0x8 EIP = 8053e481 至于SS，和ESP，会在程序提权时，由tr寄存器指向的TSS中的ESP0和SS0提供。 KiSystemService根据EIP的值，0x8053e481我们可以定位到一个内核函数KiSystemService 这样就说明进入0环了，所以KiIntSystemCall进0环非常好理解，就是中断门的知识，进入0环后，就跳转到KiSystemService继续执行，至于如何找到想要执行的函数，会在后面的文章中介绍。接下来我们来看支持sysenter/sysexit的KiFastSystemCall是如何进入0环的。 KiFastSystemCall进0环事实上，基本上现在的CPU都支持sysenter/sysexit，默认也是通过KiFastSystemCall进0环，为什么呢？顾名思义，因为快啊。因为KiFastSystemCall不需要像中断门进0环时，去查IDT表找CS，EIP，查TSS找ESP和SS，而是直接从寄存器里读取这些数据。 获取提权后寄存器的值 来看KiFastSystemCall，只有两行指令。sysenter指令，又称作快速调用，当CPU支持sysenter指令时，操作系统会提前将CS，SS，ESP，EIP写入到MSR寄存器中，当sysenter指令执行时，CPU直接从MSR中将这些值写入相应寄存器中，没有读取内存的过程，所以叫做快速调用。 MSR寄存器由于MSR寄存器非常大，这里不细讲，只列出用到的值 可以通过RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器） 这里读取ESP，EIP，CS的值（SS的值可以通过CS+8计算而得） 这样，在进入0环时，便能通过MSR寄存器切换4个寄存器的值了 KiFastCallEntry前面讲了KiIntSystemCall进入0环后执行KiSystemService，KiFastSystemCall当然也有，执行的是另一个函数，通过MSR得到的EIP我们可以找到函数KiFastCallEntry，同样是内核函数。 这样便成功进入0环了。 总结进0环的过程非常好理解，一种是咱们熟悉的中断门，另一种快速调用，也仅仅是利用了寄存器实现，不是很困难。但是有没有考虑一个问题，我们虽然成功的从3环进入到0环了，那该怎么出来呢？3环程序调用API实现功能，总该返回继续执行程序吧。既然要从0环返回3环，那就得恢复原来的寄存器的值，那么这些值又保存到了哪里呢？除此之外，现在进入了0环了，但又如何找到所要执行的函数呢？带着这些问题，我们继续学习下面的知识。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=39 参考文章：https://blog.csdn.net/qq_41988448/article/details/102825241","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（3环部分）","slug":"API函数的调用过程（3环部分）","date":"2020-03-25T07:09:24.000Z","updated":"2020-03-25T10:15:51.746Z","comments":true,"path":"2020/03/25/API函数的调用过程（3环部分）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/25/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E9%83%A8%E5%88%86%EF%BC%89/","excerpt":"","text":"保护模式暂时告一段落了，接下来开始API函数调用的学习，来一步步分析Windows在调用API的过程中到底做了些什么事，函数到底是如何实现的。 Windows API Application Programming Interface，简称API函数 Windows有多少个API？ 上万个，主要存放在 C:\\WINDOWS\\system32 下面所有的dll中 几个重要的DLL Kernel32.dll：最核心的功能模块， 比如管理内存、进程和线程相关的函数等。 User32.dll：是Windows用户界面相关应用程序接口，如创建窗口和发送消息等。 GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。例如，要显示一个程序窗口，就调用了其中的函数来画这个窗口。 Ntdll.dll：大多数API都会通过这个DLL进入内核（0环）。 分析ReadProcessMemory为了能够直观的了解API的调用过程，我们来分析一个Windows API函数，ReadProcessMemory，这个API函数位于Kernel32.dll，功能是读取指定进程的内存，打开IDA我们来看看它都做了些什么。 ReadProcessMemory在Kernel32.dll中选择导出函数，按下Ctrl+F，然后搜索ReadProcessMemory 找到后进入函数主体 我们可以看到，ReadProcessMemory函数总体分为3个部分，首先是参数的压栈，其次调用了一个函数NtReadVirtualMemory，接着就开始处理函数的返回值了，可以发现，真正读取内存的功能并不是在ReadProcessMemory中实现的，所以我们需要进一步去查看NtReadVirtualMemory。 把鼠标放在NtReadVirtualMemory上，发现该函数是外部函数，不属于Kernel32.dll，所以我们得去Kernel32.dll的导入函数中找一下这个函数属于哪个dll。 可以见得，NtReadVirtualMemory属于Ntdll.dll，接下来进入NtReadVirtualMemory继续分析。 NtReadVirtualMemory找到函数主体的步骤和上面一样，不再赘述。 NtReadVirtualMemory的函数主体部分只有4行，其中最关键的是前两行： mov eax, 0BAh：这一步给eax赋值了一个编号，这个编号的作用是在进入0环后，找到真正需要调用的函数。记住，这个编号存在eax中。 mov edx, 7FFE03000h：这一步同样关键，这是一个函数地址。它决定了进入0环的方式（具体在下一篇中会详细分析），同样，也要记住edx存了这个值。 经过简单的分析，可以发现，在3环层面上， 并没有真正实现函数的功能，API函数的实现，大部分都在0环（只有少部分函数是在3环实现）。拿ReadProcessMemory来说，只是相对于0环给上层提供的一个接口，通过这个接口，我们可以实现读取指定地址的内存 重写API函数现在我们知道，API函数的真正实现实际上是在底层（0环），3环上的API函数实际上只是起到一个接口的作用。那么我们可以自己重写3环的API，自己去调用0环函数，这样做的好处是，可以避免3环恶意挂钩（例如有黑客Hook了OpenFile函数，每次我们调用OpenFile时，黑客就知道我们打开了什么文件，如果重写API函数，黑客就无法通过Hook OpenFile函数来获取我们打开的文件内容，除非黑客在0环动手脚） 实现功能 实现的功能大致如此，读取变量a所在地址的内容，将内容改写后，再写入该地址，先用Windows API提供的ReadProcessMemory和WriteProcessMemory实现一遍。可以看到，原本变量a的值为0x123，随后被修改成了0x567 重写ReadProcessMemory这里以ReadProcessMemory为例，在先前的分析中， 我们知道ReadProcessMemory仅仅做了参数压栈的工作，而NtReadVirutalMemory先给eax赋值了一个编号，接着给edx赋了一个函数地址，并调用此函数，然后平衡堆栈。所以我们只需要将这些功能组合一下即可： c1234567891011121314151617181920212223void _stdcall MyReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead){ _asm { //ReadProcessMemory lea eax, [ebp+0x14] push eax //lpNumberOfBytesRead push [ebp+0x14] //nSize push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtReadVirtualMemory mov eax, 0xBA mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x14 }} 当然，仅仅这样做还不够，这样虽然编译能过，但是执行会报错。因为在ReadProcessMemory中调用NtReadVirutalMemory用了call语句，call语句的使用会导致返回地址压栈，也因此，我们重写的API函数在执行 Code1call dword ptr [edx] 这条语句时，esp处的值为hProcess，而Windows在执行这条语句时，[esp+4]处的值才是hProcess！如果这里不做修改，后面函数返回时，堆栈会不平衡，因此我们需要手动修改一下堆栈： 增加了这两行后，我们自己重写的ReadProcessMemory就算完成了。同理，WriteProcessMemory也是如此。 实验结果 可以看到，我们使用了自己重写的API函数，但是实现了同样的功能。同理，别的函数也可以通过重写，从而防止3环的恶意挂钩。 完整代码c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include \"stdafx.h\"#include void _stdcall MyReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead){ _asm { //ReadProcessMemory lea eax, [ebp+0x14] push eax //lpNumberOfBytesRead push [ebp+0x14] //nSize push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtReadVirtualMemory sub esp, 0x4 //Call NtReadVirtualMemory mov eax, 0xBA mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x18 }}void _stdcall MyWriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesWritten){ _asm { //WriteProcessMemory lea eax, [ebp+0x8] //hProcess push eax //lpNumberOfBytesRead push [ebp+0x14] //NumberOfBytesToWrite push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtWriteVirtualMemory sub esp, 0x4 //Call NtWriteirtualMemory mov eax, 0x115 mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x18 }}int main(int argc, char* argv[]){ int a = 0x123; int buffer = 0; printf(\"Before: a=%x\", a); MyReadProcessMemory(GetCurrentProcess(), &a, &buffer, 4, NULL);// printf(\"%x\", buffer); buffer = 0x567; getchar(); MyWriteProcessMemory(GetCurrentProcess(), &a, &buffer, 4, NULL); printf(\"After: a=%x\\n\", a); getchar(); return 0;} 总结对于API函数的调用过程，我们对三环的部分有了一定的了解，发现，大部分API的实现都是在0环，接下来的文章中，我们就跟进去，找找API函数在0环中的实现在哪。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=37 参考文章：https://blog.csdn.net/qq_41988448/article/details/102786700 参考资料：Joney的笔记，张嘉杰的笔记，XIAOYSHIJI的代码","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"TLB，控制寄存器","slug":"TLB，控制寄存器","date":"2020-03-24T01:14:36.000Z","updated":"2020-03-24T09:53:26.650Z","comments":true,"path":"2020/03/24/TLB，控制寄存器/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/24/TLB%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"","text":"保护模式的内容接近尾声，这一篇文章补充一下琐碎的知识点，下面先从TLB开始 TLB设计原因 假设我们通过一个线性地址访问一个物理页，想要去读取物理页上某个字节。但是实际过程中，并非只读了1个字节，我们需要先读取PDE，再读取PTE，最后再读取存放1个字节的物理页，读取的内容远远超过1个字节了。 在2-9-9-12分页下，会多读24个字节，如果读取的内容跨页了（存在两个不同的物理页上），那多读的字节会更多 为了提高效率，只能通过做记录来进行弥补。 因此CPU内部设计了一个表，用来做记录；由于位于CPU内部，速度和寄存器一样快，当然，表也不能做的过大。这个表叫做TLB（Translation Lookaside Buffer），用于地址解析 TLB结构 LA（线性地址） PA（物理地址） ATTR（属性） LRU（统计） xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 说明： ATTR（属性)：PAE分页，用PDPE&PDE&PTE。10-10-12分页则PDE&PTE 不同CPU的TLB表大小不一样 只要Cr3改变了（说明进程切换了），先前的TLB则会失效，换一套新的TLB，一核一套TLB 由于操作系统中的高2G映射基本不变，如果Cr3改了，直接刷新TLB，对于重建高2G以上的对应关系很浪费，所PDE和PTE中有个标志位G位，刷新TLB时将不会刷新PDE/PTE的G位为1的页。若TLB满了，则CPU会根据统计信息将不常用的地址废弃，保留最近最常用的 注意：只有当PDE的PS位为1时（即当前物理页为大页），G位才有效。 TLB种类TLB在x86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在x86的CPU里，一般都设有如下4组TLB： 缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB） 缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB） 缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB） 缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Instruction-TLB） TLB验证呵呵，这个破实验花了我一下午，我真是太菜了，一个原因是0地址挂物理页，踩了好几次坑，第二个是VC6很多强转不支持，耽误了很多时间。给0地址挂物理页的步骤就不赘述了，这里采用的10-10-12分页，只是采用了代码挂物理页的方式，具体可以参考基址小实验这一篇，这里就讲讲验证的过程。 我们先给0地址挂上第一个地址（0x425000，这是我随便选的，选错了可能蓝屏）的物理页，然后取0地址的处的置，发现值为0。 这时，我们注释掉给0地址挂第一个地址（0x425000）的物理页的代码，并给0地址挂第二个地址（0x426000）的物理页。这时再取0地址处的值，发现值为0x43，可以发现，这两个线性地址所对应的物理页上的值是不同的。 这时我们把上面的注释拿掉，先给0地址挂第一个地址的物理页，然后再给0地址挂第二个地址的物理页，按照道理，这时我们取到的值应该是第二个地址对应物理页上的值，我们来查看结果： 神奇的事情发生了，我们取到的仍然是第一个地址对应物理页上的值，这其实就是TLB的作用。 这时，我们增加一条语句 Code1invlpg dword ptr ds:[0] 再次运行程序发现，仅仅多了这一条语句，读取0地址的值，就变成了第二个地址对应物理页上的值，Invlpg是让指定页TLB无效化的指令，因此再次访问时，原先的TLB已经被废弃，就需要重新去物理页读取，此时0地址对应的物理页已经是第二个地址的物理页了。当然，除了使用Invlpg指令，修改Cr3也可以做到让TLB无效化。 下面附上完整代码 c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include \"stdafx.h\"#include DWORD phyAddr, phyAddr2, temp;__declspec(naked) Test() { _asm { pushad pushfd } phyAddr = (DWORD)(0xc0000000 + ((0x425000 >> 0xa) & 0x3ffffc)); phyAddr2 = (DWORD)(0xc0000000 + ((0x426000 >> 0xa) & 0x3ffffc)); _asm{ mov eax, phyAddr mov eax, [eax] mov dword ptr ds:[0xc0000000], eax mov eax, dword ptr ds:[0] mov temp, eax// invlpg dword ptr ds:[0] 无效化指定页的TLB// mov eax, cr3 切换Cr3来清空TLB// mov cr3, eax mov eax, phyAddr2 mov eax, [eax] mov dword ptr ds:[0xc0000000], eax mov eax, dword ptr ds:[0] mov temp, eax } _asm{ popfd popad retf }}int main(int argc, char* argv[]){ char buffer[] = {0, 0, 0, 0, 0x4B, 0}; _asm call fword ptr buffer printf(\"temp: %x\", temp); getchar(); return 0;} 控制寄存器说完了TLB，来说说控制寄存器。控制寄存器的作用主要是用于控制和确定CPU的操作模式。主要包括Cr0，Cr1，Cr2，Cr3，Cr4，其中Cr1保留。 Cr0寄存器Cr0寄存器，主要包括一些控制操作系统模式以及处理器状态的控制标志位。 这里介绍几个主要的标志位，其余位的描述可以参考Intel白皮书第三卷系统架构综述那章。 PE：Cr0下标为0的位是启用保护（Protection Enable）标志。PE=1保护模式，PE=0实地址模式，这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。 PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。 PG=0且PE=0：处理器工作在实地址模式下 PG=0且PE=1：处理器工作在没有开启分页机制的保护模式下（不存在这样的操作系统） PG=1且PE=0：在PE没有开启的情况下 无法开启PG PG=1且PE=1：处理器工作在开启了分页机制的保护模式下 WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志，当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作。 对于Ring0的特权级程序，如果WP=0，可以读写任意用户级物理页，只要线性地址有效 对于Ring0的特权级程序，如果 WP=1 可以读取任意用户级物理页，但对于只读的物理页，则不能写 Cr2寄存器Cr2寄存器，保存导致缺页异常的线性地址。 之前在中断与异常中，简要概括了缺页异常，当CPU访问某个无效页面，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在Cr2中，以便操作系统处理完缺页异常后，返回到原本执行的位置继续执行。 Cr3寄存器Cr3我们太熟悉了，在10-10-12分页是页目录表基址，在PAE分页下，则是页目录指针表基址 这里有两个属性，PWT和PCD之前在页的部分一直没有讲，在介绍之前，先来了解一个概念，叫做CPU缓存 CPU缓存 CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多，但是交换速度远快于内存。 CPU缓存可以做的很大，从几K，几十K，几百K，甚至上M。 CPU缓存与TLB的区别： TLB：线性地址 物理地址 CPU缓存： 物理地址 内存 有了CPU缓存和TLB的概念后，就可以来讲讲PWT和PCD这俩属性了。 PWT(Page Write Through) PWT = 1时，CPU向cache写入数据时，同时向memory也写一份，使cache和memory的数据保持一致。优点是简单，缺点是每次都要访问memory，速度比较慢，即Write Through。 PWT = 0时，CPU向cache写入数据时，不将数据写入内存中，分为两种情况： Post Write：CPU更新cache数据时，把更新的数据写入到一个更新缓冲器，在合适的时候才对memory进行更新。这样可以提高cache访问速度，但是，在数据连续被更新两次以上的时候，缓冲区将不够使用，被迫同时更新memory。 Write Back：CPU更新cache时，只是把更新的cache区标记一下，并不同步更新memory。只是在cache区要被新进入的数据取代时，才更新memory。这样做的原因是考虑到很多时候cache存入的是中间结果，没有必要同步更新memory。优点是CPU执行的效率提高，缺点是实现起来技术比较复杂。 PCD(Page Cache Disable) PCD = 1时，禁止某个页写入缓存，直接写入内存。例如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。 PCD = 0时，不限制页写入缓存，可以参考上面PWT的情况。 Cr4寄存器Cr2寄存器，保存了一组启用多种架构扩展的标志位 这里简单概括一下PAE位和PSE位： PAE：置1时，是PAE分页；置0时，是10-10-12分页。之前在boot.ini中设置execute/noexecute的作用就是修改PAE位 PSE：控制PDE中PS位的开关，当PSE置1时，PS位才有效。具体如下： 控制寄存器小节除了上述介绍的，还有一个Cr8寄存器，仅仅在64位下才存在，这里就不作介绍了，其余寄存器总览如下： 参考文章1：https://blog.csdn.net/wyzxg/article/details/7254458 参考文章2：https://blog.csdn.net/q1007729991/article/details/53000410 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=33","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"中断与异常","slug":"中断与异常","date":"2020-03-23T14:37:48.000Z","updated":"2020-03-24T12:48:08.406Z","comments":true,"path":"2020/03/23/中断与异常/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/23/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/","excerpt":"","text":"段和页的主要知识，差不多就告一段落了，这篇文章简单介绍一下中断与异常的相关概念，结合之前学习的IDT表，形成一个整体的框架，在后续文章中，会再详细解析中断和异常的处理过程。 中断什么是中断 中断通常是由CPU外部的输入输出设别（硬件）所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫做中断请求（IRQ-Interrupt Request） 中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程（中断处理程序在哪由IDT表决定） 80x86有两条中断请求线： 不可屏蔽中断线，称为NMI（NonMaskable Interrupt） 可屏蔽中断线，称为INTR（Interrupt Require） 不可屏蔽中断 （IDT表）中断号 NMI 说明 0x2 不可屏蔽中断 80x86中固定为0x2 说明： 当不可屏蔽中断产生时，CPU在执行完当前指令后会立即进入2号中断，执行相应中断处理程序 不可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理 可屏蔽中断在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求。为了便于标识各个中断请求，中断控制器通常用IRQ（Interrupt Request）后面加上数字来表示不同的中断。 例如：在Windows中，时钟中断的IRQ编号为0，也就是：IRQ0 （IDT表）中断号 IRQ 说明 0x30 IRQ0 时钟中断 0x31~0x3F IRQ1~IRQ15 其它硬件设备的中断 说明： 如果自己的程序执行时不希望CPU去处理这些中断，可以用CLI指令清空EFLAG寄存器中的IF位。与CLI指令相反，STI指令可以用来设置EFLAG寄存器中的IF位 硬件中断与IDT表中的对应关系并且固定不变的，参见APIC（高级可编程中断控制器） 异常聊完了中断，来看看异常。异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。 与中断的区别 中断来自于外部设备，是中断源（例如键盘）发起的，CPU是被动的。 异常来自于CPU本身，是CPU主动产生的。 INT N虽然被称为“软件中断”，但其本质是异常。因此不受EFLAG的IF位影响。 异常处理无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。 上图为IDT表中常见的中断向量号的相关描述，具体细节可以参考Intel白皮书第三卷（Exception And Interrupt Reference）这章 缺页异常（无时无刻不在发生）缺页异常产生： 当PDE/PTE的P=0时 当PDE/PTE的属性为只读，但程序试图写入时 一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统接管。 这里简单概括上述两种发生缺页异常的情况： 在操作系统中，物理页往往是紧缺的，若当前PTE指向的物理页的内容一段时间没有被访问，则会将这个物理页上的内容存到一个文件里，同时将这个物理页挂给有需要的PTE用，并将原PTE的P位置0。当程序再次访问这段内容时，发现P位为0，则会触发缺页异常，但是此时PTE下标为10,11的位置均为0，其余位置都是有值的，这种情况说明当前PTE指向的内容存到了文件中，并根据下标1~4指定的偏移，在文件中找到内容。这时再重新给这些内容挂上新的物理页，将P位改为1，这时访问便可正常执行。当然，缺页异常对于用户来说是透明的，用户只会觉得自己正常访问了某个内容，但实际上进行了很多操作，通过缺页异常，操作系统可以节省大量物理页。 当PDE/PTE属性为只读时，CPU不会进行处理，而是跳到E号中断交给操作系统来处理，操作系统发现程序正在尝试写一个只读的物理页，会返回一个C0000005错误。 异常小节当异常发生时，CPU会判断异常的种类，根据中断向量号，跳转到相应的异常处理程序，接着由操作系统接管并处理。 总结这篇简要介绍了中断与异常，在后续讲到中断章节时，会更加详细的分析过程原理。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=32","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"2-9-9-12分页","slug":"2-9-9-12分页","date":"2020-03-22T06:53:29.000Z","updated":"2020-03-23T07:36:10.904Z","comments":true,"path":"2020/03/22/2-9-9-12分页/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/22/2-9-9-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"在前面的文章中主要介绍了10-10-12分页方式，在这种分页方式下，物理地址最多可达4GB。随着硬件发展，4GB的物理地址范围已经无法满足要求，于是Intel设计了一种新的分页方式：2-9-9-12分页（又称PAE）分页。下面就来了解一下这种分页方式是如何运作的吧。 PAE分页为什么是2-9-9-12PAE（Physical Address Extension，物理地址扩展）页，一定会涉及到2个结构，就是PDE和PTE。以PTE来说，它可以直接定位到某个物理页上的物理地址，在10-10-12分页下，由于PTE的大小是4字节(32位)，因此PTE能够寻址的范围仅有4GB。设想，若PTE有33位，那便可以寻址8GB；34位就能寻址16GB……以此类推。Intel考虑到对齐的因素，就干脆直接让PTE的长度达到64位了。这样一个PTE的大小就8字节，又因为一个PTT表的大小是4KB(4096字节)，因此原本一个PTT表里能装下1024个4字节的PTE，现在只能装下512个8字节的PTE了。2的9次方等于512，所以PTI的值为9。 同理，PDI的值也为9，这样2-9-9-12中还剩下最前面的2位。 设置PAE分页设置PAE分页比较简单，进入C盘打开boot.ini文件修改启动项，将execute改成noexecute即可，然后重启虚拟机即可进入PAE分页。 PDPTEPDPTE（Paga-Directory-Point-Table Entry）页目录指针表项，顾名思义，这是一个指向PDT表（在10-10-12分页下，Cr3指向PDT表的首地址）的元素，且位于PDPT表（PAE分页下Cr3指向PDPT表首地址）中。由于仅剩2位，所以PDPTE只有4个，同样PDPTE每项占8个字节，来看下这个结构。 Avail：下标9~11，共3位，这是留给操作系统使用的位，CPU本身并不使用 Base Address：下标12~35，寻址时，低12位补0，共36位（达到36位，与PTE保持一致，寻址空间达到64GB），即PDT基址 至于PCD和PWT，留到控制寄存器和TLB部分详解。 PDEPAE分页下，PDE扩展到了64位，其余属性变化不大。 PS = 1：大页，下标35-21是大页的物理地址，低21位填0，大页的大小为2MB（10-10-12的大页为4MB），按照2MB对齐。 PS = 0：下标35~12是页表（PTT）基址，低12位补0，共36位。 Avail：同PDPTE PTE与PDE一样，PAE分页下的PTE，也是扩展到了64位，其余变化不大 PTE中下标35-12是物理页基址，共24位（10-10-12分页下是下标31~12，共20位），低12位补0。 物理页基址+12位的页内偏移指向具体数据。 在了解这些结构后，来看一下PAE分页的大致模型 XD位在Intel新系列的CPU中，在下标63的地方多了一个属性位XD位（AMD中称为NX，即No Execetion） 我们知道段的属性有可读、可写和可执行，但是页的属性只有可读、可写。 当ret执行返回语句时，如果堆栈里的数据指向一个提前准备好的数据（把数据当作代码来执行，漏洞很多都是依赖这点，比如SQL注入），这个位的作用就是在硬件上实现一种保护，防止数据可执行的情况发生。 查找物理页PAE分页下查找对应的物理页和10-10-12差不多，拆分线性地址后，再根据PDPI、PDI、PTI偏移去找，由于每项均是8字节，所以在Windbg中使用dq指令进行查看。来看下面这个例子： 变量a的线性地址为：0x12ff7c。按照2-9-9-12进行拆分后得到0-0-12f-f7c。接着通过Cr3一步步查找，具体如下： 变量a的存的值为0x123，通过拆分线性地址，成功在找到变量a对应的物理地址。 0地址挂物理页在学习10-10-12分页时，通过0地址挂物理页的实验，加深对物理页的理解，这里我们通过这个实验进一步熟悉PAE分页。 先运行程序，发现访问违例，运行失败 查看0地址对应的物理页，发现物理页是空的。 然后查看局部变量a对应的物理页，并将a对应的物理页挂到0的位置（注意，挂物理页时，用两次!ed指令而不是!eq指令） 接着运行程序发现可以正确的打印出0地址上的内容 PAE分页下PDT/PTT的基址新增加的结构，PDPTE，并没有R/W位，US位等属性，真正决定物理页属性的还是PDE和PTE。相比10-10-12分页可以通过PDT/PTT基址修改物理页属性，在PAE分页下同样可以做到，这部分我们来研究下PAE分页下PDT和PTT的基址。 逆向分析MmIsAddressValid在前一篇文章中我们分析了10-10-12分页下的MmIsAddressValid函数，它在找到PDE/PTE后会判断下标为0(P位)和下标为7(PDE对应PS位，PTE对应PAT位)的位置的值，进行一些处理工作。而这个函数找到PDE/PTE的过程就使用了PDT/PTT的基址。这次通过分析PAE分页下的MmIsAddressValid函数，来找到PAE分页下PDT/PTT基址。 先分析查找PDE的部分 Code12345678910111213141580511987 8b4d08 mov ecx,dword ptr [ebp+8] //获取参数8051198a 56 push esi 8051198b 8bc1 mov eax,ecx8051198d c1e812 shr eax,12h //右移18位80511990 bef83f0000 mov esi,3FF8h 80511995 23c6 and eax,esi //进行与运算，余下11位有效位80511997 2d0000a03f sub eax,3FA00000h //相当于add eax, 0xC06000008051199c 8b10 mov edx,dword ptr [eax] //取PDE低四字节8051199e 8b4004 mov eax,dword ptr [eax+4] //取PDE高四字节805119a1 8945fc mov dword ptr [ebp-4],eax //高四字节保存到局部变量805119a4 8bc2 mov eax,edx805119a6 57 push edi //保存edi原本的值805119a7 83e001 and eax,1 //保留P位的值805119aa 33ff xor edi,edi805119ac 0bc7 or eax,edi 右移18位后，进行了一次与运算，保留的位相当于PDPI x 4KB + PDI x 8（看不明白的可以参考这篇） sub eax, 0x3FA00000和add eax, 0xC0600000，因此可以推测，PAE分页下PDT的基址为0xC0600000 接着分析查找PTE的部分 Code123456789101112805119c3 c1e909 shr ecx,9 //右移9位805119c6 81e1f8ff7f00 and ecx,7FFFF8h //进行与运算，余下20位有效位805119cc 8b81040000c0 mov eax,dword ptr [ecx-3FFFFFFCh] //相当于mov eax, [ecx+0xC0000004]805119d2 81e900000040 sub ecx,40000000h //相当于add ecx, 0xC0000000805119d8 8b11 mov edx,dword ptr [ecx] //取PTE低四字节805119da 8945fc mov dword ptr [ebp-4],eax //将PTE高四字节保存至局部变量805119dd 53 push ebx //保存ebx原本的值805119de 8bc2 mov eax,edx 805119e0 33db xor ebx,ebx 805119e2 83e001 and eax,1 //保留P位的值805119e5 0bc3 or eax,ebx805119e7 5b pop ebx 重点还是在与运算这，右移9位后跟0x7FFFF8进行与运算，相当于PDPI x 2MB + PDI x 4KB + PTI x 8 sub ecx，0x40000000相当于add ecx, 0xC0000000，可以推测，PAE分页下PTT的基址仍然为0xC0000000 公式总结根据MmIsAddressValid函数，可以得到PAE分页下PDT和PTT的基址分别为0xC0600000和0xC0000000。 我们可以采纳MmIsAddressValid的方法总结出找到任意一个PDE /PTE的公式： 利用MmIsAddressValid内的手法 c12pPDE = (int*)(0xc0600000 + ((addr >> 18) & 0x3ff8))pPTE = (int*)(0xc0000000 + ((addr >> 9) & 0x7ffff8)) 通过拆分线性地址 c12pPDE = (int*)(0xc0600000 + (PDPTI","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"逆向分析MmIsAddressValid(10-10-12)","slug":"逆向分析MmIsAddressValid","date":"2020-03-21T03:07:40.000Z","updated":"2020-03-21T08:36:14.300Z","comments":true,"path":"2020/03/21/逆向分析MmIsAddressValid/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/21/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid/","excerpt":"","text":"在对页表基址，页目录表基址熟练掌握后，今天来看逆向分析一个函数：MmIsAddressValid。这是一个系统函数，可以在ntoskrnl.exe的导出函数中找到它，也可以在Windbg中输入指令 Code1kd> u MmIsAddressValid 查看。 为什么要分析这个函数呢？因为即使是系统函数，也是无法直接使用物理页的，想要去访问PDE和PTE也就一定要通过基址来访问，而今天要分析的MmIsAddressValid函数，就利用了这么一个原理，相比前一篇的基址小实验，这里对于线性地址拆分的过程更为巧妙，让我们一起来看看吧！ 获取PDE属性 首先观察函数主体部分，发现代码并不长，但是有很多跳转，具体跳转内容就不作分析了，主要是分析函数主体： Code1234567891011121314804e4661 8bff mov edi,edi //hotpatch804e4663 55 push ebp804e4664 8bec mov ebp,esp804e4666 8b4d08 mov ecx,dword ptr [ebp+8] //取第一个参数（线性地址）804e4669 8bc1 mov eax,ecx //赋值到中间变量，方便运算804e466b c1e814 shr eax,14h //逻辑右移20位804e466e bafc0f0000 mov edx,0FFCh 804e4673 23c2 and eax,edx //和操作数进行与运算，同时清空最后2位；相当于做了一个乘4的运算，既左移2位804e4675 2d0000d03f sub eax,3FD00000h //进行减法运算，相当于eax+0xC0300000804e467a 8b00 mov eax,dword ptr [eax] //取PDE的值804e467c a801 test al,1 //判断PDE属性P位是否为1804e467e 0f84d2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e4684 84c0 test al,al //判断下标为7的位(PS位)值是否为1804e4686 7824 js nt!MmIsAddressValid+0x53 (804e46ac) 巧妙的与运算： 首先将线性地址逻辑右移20位，此时还余下12位 将这12位和操作数0xFFC做一个与运算，0xFFC换算成2进制就是1111 1111 1100。因此做完与运算后，刚刚经过第一步操作还剩下12位的数的低2位，置0了。熟悉移位运算的朋友们知道，这个12位的数，相当于1个10位的数逻辑左移2位得到，换句话说就是将这个10位的数乘4。而这个10位，就是PDI，因此这步操作完了以后，相当于我们获得了PDI*4的值。 接下来，与0x3FD00000做减法运算，作用相当于加上0xC0300000，两种方法的结果是一样的。因此，我们得到了0xC0300000 + PDI*4的值，而这个值，恰恰就是我们要找的PDE，接着只需要取出里面的值，就可以获取PDE的属性了 后续跳转再获取PDE的属性后，会遇到两个跳转，简单的概括下： 首先会判断PDE下标为0的位置的值，也就是P位，当P位为0时，说明物理页无效，会跳转到一个相应的处理函数，这里就不再跟进分析 若物理页P位为1，就会来到第二个跳转，这里test al, al指令会修改标志寄存器，当al的最高位，也就是下标为7的位置值为1时，会被认为是负数，此时会修改EFLAG寄存器的SF位。这时，在第二个跳转的位置，js判断的就是SF的值是否为1，若为1，也就是al下标为7的位置值为1，这是对应的PDE属性PS位，说明这是一个4MB的大页，进而会跳转执行相应的处理函数。 获取PTE属性Code123456789101112804e4688 c1e90a shr ecx,0Ah //逻辑右移10位804e468b 81e1fcff3f00 and ecx,3FFFFCh //和操作数进行与运算，同时清空最后2位，相当于PDI左移12位+PTI左移2位804e4691 81e900000040 sub ecx,40000000h //进行减法运算，相当于eax+0xC0000000804e4697 8bc1 mov eax,ecx804e4699 8b08 mov ecx,dword ptr [eax] //获取PTE属性804e469b f6c101 test cl,1 //判断P位的值是否为0804e469e 0f84b2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e46a4 84c9 test cl,cl //判断PAT是值是否为1804e46a6 0f88b6de0300 js nt!MmIsAddressValid+0x3f (80522562)804e46ac b001 mov al,1804e46ae 5d pop ebp804e46af c20400 ret 4 巧妙的与运算Code1and ecx, 3FFFFCh 假设线性地址右移10位后的值为 0000 0000 00aa aaaa aaaa bbbb bbbb bbxx（a, b的值为0或者1，这里只是为了区分PDI和PTI） 然后我们来拆分0x3FFFFC的值：0000 0000 0011 1111 1111 1111 1111 1100 将两者进行与运算后得到结果为 0000 0000 00aa aaaa aaaa bbbb bbbb bb00 我们知道，aa aaaa aaaa应为PDI，而bb bbbb bbbb应为PTI，因此可以把得到的结果看作是这样的一个运算：$$aa aaaa aaaa","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"基址小实验（10-10-12）","slug":"基址小实验","date":"2020-03-20T15:14:53.000Z","updated":"2020-03-22T16:36:37.983Z","comments":true,"path":"2020/03/20/基址小实验/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/20/%E5%9F%BA%E5%9D%80%E5%B0%8F%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"在学习完页目录表基址，页表基址后，我们知道通过C0300000和C0000000这两个地址，可以访问相应的PDE和PTE，今天就来实践一下。 之前在介绍PDE/PTE属性R/W位时有过一个实验，是对位于常量区的内容进行修改，当时通过Windbg修改了所在PDE/PTE的R/W位。这次实验，我们利用页目录表/页表基址来进行修改。 测试原始代码 首先测试原始代码，发现直接修改常量区的字符串，是会失败的 提权进入0环提权这里还是会用到Windbg，根据调用函数的地址，填入段选择子，并通过调用门进行提权（就当复习调用门知识了） 修改R/W位提权进入0环后（为啥要提权呢？因为C0300000/C0000000都属于高2G的线性地址，3环没法直接访问），就到了我们最关键的步骤了，修改R/W位。 c123456temp = *(int*)0xC0300004;temp = temp|0x2;*(int*)0xC0300004 = temp;temp = *(int*)0xC000108C;temp = temp|0x2;*(int*)0xC000108C = temp; 在这之前声明了一个中间变量temp（int类型）。 具体步骤： 打印出字符串所在常量区的地址0x423fb0，进行拆分：10-10-12 -> 0x1-0x23-0xfb0 PDI = 0x1，带入公式：PDE = C0300000 + 0x1 x 4 PTI = 0x23，带入公式：PTE = C0000000 + 0x1 x 1000 + 0x23 x 4 分别取PDE和PTE处的值，并和0x2进行或运算（将R/W位置1） 这样就完成了对R/W位的修改，在接下来再次对常量区的值进行修改操作时，便可以成功。 完整代码c123456789101112131415161718192021222324252627282930313233343536373839#include \"stdafx.h\"int temp;__declspec(naked) void ModifyRW() { __asm { pushad pushfd } temp = *(int*)0xC0300004; temp = temp|0x2; *(int*)0xC0300004 = temp; temp = *(int*)0xC000108C; temp = temp|0x2; *(int*)0xC000108C = temp; __asm { popfd popad retf }}int main(int argc, char* argv[]){ char* str = \"hello\"; char buffer[6] = {0, 0, 0, 0, 0x4B, 0}; printf(\"addr: %x, str: %s\", str, str); getchar(); _asm { call fword ptr buffer } *str = 'a'; printf(\"str: %s\", str); getchar(); return 0;}","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"页目录表、页表基址","slug":"页目录表、页表基址","date":"2020-03-20T07:11:51.000Z","updated":"2020-03-20T14:22:35.004Z","comments":true,"path":"2020/03/20/页目录表、页表基址/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/20/%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E3%80%81%E9%A1%B5%E8%A1%A8%E5%9F%BA%E5%9D%80/","excerpt":"","text":"考虑这样一个问题，我们现在可以通过在Windbg里找到线性地址所在的物理页，通过修改物理页的属性，就可以实现一些原本受限的功能。例如将常量区对应的物理页R/W属性修改为1，便可以修改位于常量区的元素。 但是，以上操作都是基于Windbg在双击调试的环境中实现的，那么一旦脱离了调试器，该如何通过代码来实现对物理页属性的修改呢？这就需要借助于页目录表基址和页表基址了。 页目录表基址结论：C0300000就是页目录表基址，接下来我们来验证这个结论。 C0300000拆分C0300000： 1100 0000 0011 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 11 0000 0000 300 12 0000 0000 0000 0 Cr3这里以记事本(notepad.exe)为例，来验证一下，C0300000就是页目录表基址，首先查看记事本对应的Cr3指向的物理地址。 我们知道，Cr3指向的是PDT的首地址，这里可以看到4个PDE有值。 查看C0300000物理页接下来的步骤就是比较熟悉的，根据拆分后的线性地址，寻找物理页的过程了。但是这一次，要慢点看。 这一步很容易理解，Cr3.base + 300*4，通过Cr3和线性地址的前10位，我们找到了PDE的值：7ea49063 什么？又重复了一遍？实际上不是，由于PDE的值为7ea49063，后12位是属性位，因此，7ea49000是我们要找的PTT的首地址，然后通过PTT.base + 300*4，就得到了PTE的值：7ea49063。 有了PTE的值，加上最后12位的偏移（此处为0），就可以找到物理页。 得到结果后，是不是很惊讶？C0300000这个线性地址对应的物理页上的物理地址，竟然和Cr3指向的物理地址完全一样！也就是说，以后不需要Cr3，只需在当前程序内，通过C0300000这个线性地址就可以得到当前程序PDT的首地址了 如何利用是啊，C0300000这个地址有啥用呢？当然有用，而且非常有用。回到文章开头的问题，我们该如何在不使用Windbg的情况下，修改物理页的属性呢？ 我们知道，想要修改物理页的属性，需要先修改物理页对应的PDE和PTE，那要如何找到PDE和PTE呢，由于在编写代码时，用到的都是线性地址，而C0300000这个线性地址刚好就可以找到PDT的首地址，这样我们拆分想要修改的物理页属性的线性地址，将前10位加上C0300000即可找到对应的PDE。 既然PDE找到了，那不就有了PTT的首地址，这样PTE不也就可以找到了吗？并不是这样，尽管找到了PDE，但是由于PDE里面存着的是物理地址，如果直接访问PDE里面存的那个地址，在代码中会转变为一个线性地址，因此并不能通过PDE获取PTT的首地址，也就不能获取到PTE了，想要找到PTE，还得需要用到另外一个基地址，就是页表基址。 页表基址还是直接上结论，页表基址：C0000000 接下来我们来验证。 C0000000拆分C0000000： 1100 0000 0000 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 00 0000 0000 0 12 0000 0000 0000 0 Cr3这里还是以记事本(notepad.exe)为例： 我们查看Cr3指向的物理地址，当前共有4个PDE的有值的，而PDE的值，就是PTT的首地址，以第一个PDE（36c24067）为例，其中PTT的首地址为36c24000。 查看C0000000物理页步骤和之前一样，就直接看结果好了。 发现，C0000000这个线性地址所对应的物理页，刚好是36c24000，也就是第一个PDE对应的PTT的首地址。由此可以进一步推断，C0001000则是第二个PDE对应的PTT的首地址，以此类推。 再看10-10-12分页现在再来看10-10-12分页时，看法就会有所不一样了。 实际上页表（PTT）被映射到了从0xC0000000到0xC03FFFFF的4M地址空间 在这1024个表中有一张特殊的表：页目录表（PDT） 页目录表（PDT）被映射到了0xC030000开始处的4KB大小的地址空间 总结有了0xC0300000和0xC0000000能做什么？掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。 公式总结： 什么是PDI和PTI？ 将32位线性地址拆分位10(PDI)-10(PTI)-12 访问页目录表(PDT)的公式：0xC0300000 + PDI x 4 访问页表(PTT)的公式：0xC0000000 + PDI x 1000 + PTI x 4（不用*号因为会被转义） 其它关于页的细节 高2G有一些大页，即4MB页 两个进程低2G几乎不同，高2G几乎相同 一个进程低2G的内存空间，前64K与后64K是没有使用的（线性地址0 - 00010000 与 7FFF0000 - 7FFFFFFFF） 谁填充了这些表呢进程本身可以通过0xC0300000和0xC0000000访问修改任意物理页，那么是谁为我们填充0xC0300000和0xC0000000的PDE与PTE呢？ 进程的创建过程：当创建B进程时，先在A进程中将B进程所有信息全部构建好，然后切换Cr3即可。也就是说，最开始的这张表是由A进程填充的。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"PDE_PTE属性（部分）","slug":"PDE-PTE属性","date":"2020-03-19T12:37:33.000Z","updated":"2020-03-19T15:51:12.795Z","comments":true,"path":"2020/03/19/PDE-PTE属性/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/19/PDE-PTE%E5%B1%9E%E6%80%A7/","excerpt":"","text":"上一篇文章中了解了PDE和PTE，这一篇就来了解一下PDE和PTE的属性。 物理页的属性 一上来看这张图，肯定是一脸懵逼的。先从行开始看，第一行是关于CR3寄存器的，这部分留到控制寄存器的章节再分析。接下来三行是不同类型PDE的，最后两行是PTE的。其中PDE和PTE有很多属性是重合的。而物理页的属性，就是有PDE和PTE共同决定的。计算方法是将相同属性位的值进行与运算。 物理页的属性 = PDE属性 & PTE属性 P位 首先来看P（Present）位：存在位。PDE与PTE的P位均位1时，物理页有效；其余情况，物理页不存在。这也解释了为什么PDE的第三行和PTE的第二行可以直接忽略。 在上一篇文章中，有一个关于0地址赋值的实验。0地址之所以不能赋值是因为它的PTE的P位为0，在我们修改了PTE的P位，并给它挂上一个物理页后，0地址遍可以赋值了。 R/W位 R/W = 0 只读 R/W = 1 可读可写 R/W很好理解，控制写的权限呗，这个位有何用呢？来看一个小实验。 c123456789101112131415#include \"stdafx.h\"int main(int argc, char* argv[]){ char* str = \"hello\"; printf(\"%x\", str); getchar(); *str = 'a'; printf(\"%s\", str); getchar(); return 0;} 来看这个代码，很明显，执行会是失败的，因为用char*定义的字符串，是会存储在常量区，而不是堆栈中了，又因为常量区的值是不允许修改的，因此 c1*str = 'a'; 这条语句会执行失败并报错。 那为什么常量区的内容就不可修改呢？其实，说白了，就是常量区挂着的物理页的R/W属性为0，因此只能读，不可写，既然知道了原因，我们只要修改了常量区所在物理页的属性，将R/W位置1即可。 通过printf语句先打印出所在常量区的线性地址，接着拆分跟进PDE和PTE中（具体步骤省略） 可以发现，PTE的R/W位值为0，因此将其修改为1写入，随后运行程序发现，可以成功修改字符串首地址出的字符！ P/S位 P/S（PageSize）位，只对PDE有意义，位于PDE的第7位。 PS = 1 PDE直接指向物理页，无PTE，低22位为页内偏移。线性地址只能拆成两段（10-22）：页的大小为2的22次方，也就是4MB，俗称“大页”，大页比较少，一般出现在高2G中 PS = 0 就是我们比较熟悉的10-10-12分页，页的大小为4KB U/S位 U/S（User/System）位，位于PDE/PTE的第2位。 U/S = 0：特权用户 U/S = 1：普通用户 三环程序是不能读写高2G内存的，原因在于高2G内存对应的物理页U/S位被置0了，也就是说只有特权用户才能读写高2G的内存。所以，当普通用户想要读取高2G内存时，就可以把U/S置1，这样就可以访问高2G内存了。 当然，理论如此，不过除了U/S位外，影响高2G内存读写的还有PCD位和PWT位，这部分内容也要到控制寄存器部分才能讲，所以第二种3环程序读写高2G实验（第一种是通过门提权），就要放到后面实现了，这里只要先记住，U/S位是影响访问读写权限的。 与R/W的区别这里需要注意一下U/S位与R/W位的区别，U/S位的读写控制是根据用户的级别，而R/W位的控制是直接控制读写，不管你是不是特权用户。 A位 A（Accessed）位于PDE/PTE的第5位：表示该物理页是否被访问（读或者写）过，访问过置1，即使只访问一个字节也会导致PDE，PTE置1。 D位 D（Dirty），脏位，是否被写过。0表示没有被写过，1表示被写过 总结以上是关于PDE/PTE部分属性的含义，还有一部分位没有涉及到，例如G位，PWT位，PCD位，这些需要讲到控制寄存器和TLB相关概念时再细讲。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"10-10-12分页","slug":"10-10-12分页","date":"2020-03-18T12:55:20.000Z","updated":"2020-03-19T13:43:58.205Z","comments":true,"path":"2020/03/18/10-10-12分页/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/18/10-10-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"保护模式下内存管理方式分为两种，段与页。前面的篇章中，简要介绍了段的知识，今天就来和大家聊聊页的知识，页是保护模式中更为重要的一环，随着系统进入32-Bit，段的作用明显降低了，取而代之的则是在段的基础上，更为细分的页。 段与页 这是Intel白皮书中介绍关于段与页的概要图，经过段的学习，可以很容易的理解左半部分，这是一个根据所提供的有效地址（图中Offset）以及段寄存器中确定的基址，锁定线性地址空间中的某个线性地址（图中Lin.Addr.）的过程。而右半部分，则是利用了页的功能，通过拆分线性地址，一步步转化成了物理地址。 上述提到了3个概念，有效地址，线性地址以及物理地址，文字叙述会让人混淆，我们来看一条语句： Code1mov dword ptr ds:[0x12345678], 0x123 其中，0x12345678是有效地址 ds.Base + 0x12345678是线性地址 这都非常好理解，那什么是物理地址呢？考虑这样一个问题，掌握3环知识的小伙伴们知道每个进程都有4GB的内存空间，这时如果有一个进程A，给会进行一个操作，给ds.Base + 0x12345678赋值0x123，还有一个进程B，同样会给ds.Base + 0x12345678赋值0x123，那么ds.Base + 0x12345678处的位置到底是哪个值呢？还是两者都不是呢？这就涉及到了物理地址的概念。 PDT与PTT每个进程都有一个CR3的值，这很突兀，CR3是什么？实际之前在TSS切换时也用到了，具体等到了控制寄存器那会详细分析。简单来说，CR3被用来切换和定位当前正在使用的页表，它是一个32位的寄存器，其中高20位指向一个物理页（Windows系统上，一个页的大小是4KB，也就是4096个字节），如下图所示： 这图该怎么看呢？首先CR3会指向一个物理页，这个物理页又叫做页目录表（PDT），页目录表每个元素叫做页目录表项（PDE），页目录表项，每个4字节，所以一共有1024个页目录表项，CR3就好比一本书，PDT就是这本书的目录，PDE就是章节，这是一本有1024个章节的书（哇塞，真厚啊U•ェ•*U），这样就好理解多了。这是第一级。 页目录表项又指向一个第二级的表，叫做页表（PTT），页表的大小也是4KB，页表中的每个元素叫做页表项（PTE）。页表项可以理解为书中章节的每个小节，就好比第一章里面有1024个小节，这个小节就是PTE，这1024个小节加起来，构成一个小节表，就是PTT。 第二级介绍完了，第三级也就好理解了，既然书中每个章节的每个小节理解了，接下来就是页码了，每个小节都会对应书中的某个页码。而这个页码，就是相当于的物理页了。这样就可以理解这张图了，就是一部部找到物理页。 10-10-12分页Windows采用三种分页方式，在32位系统上主要有10-10-12分页和2-9-9-12分页这两种方式，在64位系统上增加了9-9-9-9-12这种分页方式，后面的文章会依次介绍32位下的两种分页方式。首先从10-10-12开始。 首先修改C盘的boot.ini文件，将noexecute改成execute，重启虚拟机，即可使用10-10-12分页方式 10-10-12分页是如何工作的呢？来看一个简单的程序： c123456789#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); return 0;} 这个程序很简单，给a赋值0x123，并查看a的地址 而这个地址0x12ff7c，实际上就是前文提到的线性地址，接下来我们将这个32位的地址按照10-10-12的方式进行拆分： 1.将0x12ff7c拆分成二进制：0000 0000 0001 0010 1111 1111 0111 1100 2.将这32位二进制数，按照10-10-12的方式组合： 每部分位数 二进制 十六进制 10 0000 0000 00 0 10 01 0010 1111 12f 12 1111 0111 1100 f7c 3.根据Cr3找到页目录表（PDT）中的页目录表项（PDE）： 首先在Windbg中执行!process 0 0指令，找到当前程序的Cr3，Cr3的值指向的就是页目录表的首地址。由于第一部分值为0，所以要查找的PDE，需要用Cr3+0*4(乘4是因为每个PDE大小是4字节)，这里注意一下，由于查找的是物理地址，所以使用的是!dd指令。 4.根据PDE找到页表（PTT）中的页表项（PTE）： 上一步已经找到了PDE，PDE的值指向的是某个PTT的首地址，方法和上一步一样，用PDE中的值+12f(拆分完的第二部分)x4，就可以得到PTE，这里要注意一点，将PDE中的值代入时，后12位置0，由于后12位为属性位，在查找的过程中不起作用 5.根据PTE确定物理地址： 确定PTE后，就剩最后一步了。由于一个物理页的大小本身就是4KB，也就是2的12次方，所以当确定了前20位后也就确定了物理页，因此我们要找的内容就在219da000这个物理页上的某个物理地址。这个物理页的范围是219da000~219dafff。现在可以理解，PTE指向的是一个物理页的首地址，根据最后12位的来确定，我们要寻找的值在物理页上的偏移，也就真正的找到了这个物理地址。 根据实验截图，发现我们一开始存在变量a里面的0x123，真正存的地方在0x219daf7c这个物理地址的位置，这就是通过线性地址一步步的找过来的，这些工作都是CPU做的，比如当我们读取a这个地址上的值是，CPU会通过分页机制读取该物理地址的值，然后再显示出来。 有趣的实验读错值了？有了10-10-12分页的知识，来做一个有趣的小实验 c1234567891011#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); printf(\"%x\", *(&a)); getchar(); return 0;} 这个代码非常简单，一般人认为，会先输出a的地址，然后再输出0x123。但有了物理页的知识，我们就可以做一些手脚了。 很奇怪吧？为什么输出不是0x123，而却输出0x456呢？原因就在于，我们偷偷修改了变量的物理地址上的值，将原本的0x123改成了0x456，因此，CPU再次去物理页读取时，值已经发生了变化，读到了修改后的值。 0地址也能存值？c1234567891011121314#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 1; printf(\"%x\", &a); getchar(); *(int*)0 = 0x123; printf(\"address0: %x\", *(int*)0); getchar(); return 0;} 这是个显而易见运行会失败的程序，为什么？因为你给0地址赋值了，有点C/C++开发经验的人都知道，0地址是不能存值的，为什么？因为运行不过去啊！这不扯淡嘛！你看我就运行过去了！ 这又是为什么呢？其实0地址不能存值的原因是，没有给它挂物理页，既然没有物理页，那CPU按照分页去查的时候，就查不到了；那么只要给他挂个物理页，就可以给这个线性地址存值了，具体操作如下。 总结 一张页表能包含的物理页：1024*KB = 4MB 10-10-12分页共有1024张页表：1024*4MB = 4GB 前20位的值如果相同，那么一定在同一个物理页 一个PTE最多可以指向一个物理页；PTE可以没有物理页；多个PTE可以指向同一个物理页 参考资料：《Intel白皮书第三卷第四章》 参考教程：https://www.bilibili.com/video/av68700135?p=24","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务门","slug":"任务门","date":"2020-03-17T01:10:51.000Z","updated":"2020-03-17T03:46:00.956Z","comments":true,"path":"2020/03/17/任务门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/17/%E4%BB%BB%E5%8A%A1%E9%97%A8/","excerpt":"","text":"为何使用任务门之前任务段中提到，进行任何切换时可以还可以使用任务门。那么既然存在TSS段描述符了，为何还需要任务门呢？ 简要概括，任务门有如下优势： 任务门可以放在GDT表中，也可以放在IDT表中，还能放在当前线程的LDT表中，而TSS段描述符只能在GDT表中 任务门可以让低权限的线程进行任何切换，任务门的结构中也有DPL属性，当通过任务门去访问TSS描述符时，一旦通过任务门，TSS段描述符就不再进行检查了，即使你是个CPL=3的程序，而TSS段描述符的DPL=0，只要任务门DPL=3，就可以通过任务门完成任务切换，稍后会做这个实验。 由于任务门可以位于IDT表中，所以当遇到中断或者异常时，可以切换到独立的任务去处理异常 下面为不同表中，任务门进行任务切换的过程： 任务门描述符 任务门描述符的结构非常简单，真正用到的只有24位，属性位里：DPL一般设置为3，方便应用程序访问，Type则是固定的0101，TSS段选择子，顾名思义，就是一个段选择子，指向位于GDT表中TSS段描述符的位置。其余位均为保留位，置0即可。 任务门实现任务切换这一步十分简单，仅仅比使用TSS多了一个步骤而已，这里也不细讲了，直接上步骤。 首先，编译源文件，下断点，确定TSS的地址，根据地址构造TSS段描述符： 第二步，根据GDT表中构造好的TSS段描述符位置，在IDT表中构造任务门： 第三步，在Windbg中使用!process 0 0指令确定CR3的值，并填入自己的TSS中： 执行程序，获取到自己构造的TSS表数据，任务切换成功： 总结任务门总体还是比较简单，由于是通过int 0x20中断进入，因此iretd作为中断返回出来，比起JMP FAR还需要手动修改EFLAGS的NT位和previous task link容易的多。比较遗憾的是，这一部分的小作业，通过任务门进1环，还是失败了。这里稍微说一下我的思路，由于是进入1环（虽然windows没用1环），但我们让他进入1环，就替换1环的寄存器，ESP1和SS1，当然SS1和CS都需要设置CPL值为1，但是原本0环这两个段寄存器控制的都是DPL=0的段，因此我们需要构造一个1环的段描述符，我实验的时候构造了一个1环的非一致代码段描述符和一个1环的数据段描述符，让任务切换后的CS，SS载入段描述符信息用。同时还需要把TSS段描述符的DPL设置为1，其余值保持不变。可惜，几次都死掉了，实验没能成功，群内也没人这个进入1环的实验，以后有人讨论的话会考虑再试试。 任务段任务门这里有些遗憾吧，的确有点复杂，没理解透彻，感觉任务段那讲的也不是很清晰，希望以后我还能看得懂吧，接下来进入页的内容了，保护模式的关键来了，得掌握好。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务段","slug":"任务段","date":"2020-03-16T12:41:30.000Z","updated":"2020-03-16T17:07:35.399Z","comments":true,"path":"2020/03/16/任务段/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/16/%E4%BB%BB%E5%8A%A1%E6%AE%B5/","excerpt":"","text":"要点回顾在调用门、中断门与陷阱门中，一旦发生权限切换，那么就必有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。这时问题来了，我们知道EIP和CS的值都可以通过门描述符获得，那么ESP和SS是哪来的？这就是引出了今天的内容：TSS（Task-state segment），任务状态段。 TSS设计初衷想要学习一类知识，首先要了解它被设计出来的目的，这样就能找到方向，更好的了解它。CPU在运行时会频繁的切换任务，每次切换任务时，还没执行完的任务怎么办？总不能下次重新执行吧，于是需要保存上一个任务的上下文环境，于是，TSS诞生了，TSS是一块大小为104(0x68)个字节的内存，没错，TSS不是什么寄存器，就是一段内存，或者说是一个段，这段内存可以保存32-Bit下所有通用寄存器以及段寄存器的值，这样CPU就可以切换到新任务时，仍然保留上一个任务的环境，方便新任务执行完后，能够完好的回到先前的任务继续执行。 注意，TSS是一个段，有段就有段寄存器和段描述符哟！比如我们熟悉的CS，CS就是段寄存器，它描述的是代码段，同时，它会通过段选择子从GDT表的代码段描述符中载入段的相关信息，通常情况下，代码段的范围是0~FFFFFFFF（大小是4GB）；这样一对比，就可以理解了，TSS也是如此，因为TSS也是一个段（大小是104字节），所以应该存在一个描述TSS的段寄存器从一个段描述符里加载TSS相关信息。这就是今天会依次介绍的TR寄存器和TSS段描述符。 这里补充一点知识，尽管Intel设计TSS的初衷的为了方便任务切换（CPU层面叫做任务切换，操作系统层面叫做线程切换），但是Windows认为这个TSS设计的不好，因此并没有采用这个结构进行线程切换，并且Linux也没有采用TSS进行线程切换，这俩操作系统用的都是堆栈进行线程切换的。那么Windows用到了这个结构没有，当然是用到了，但仅仅用到了ESP0和SS0这两个值。 TSS结构先来看看TSS的结构 大部分都应该比较熟悉，这里介绍几个较为陌生的字段： Previous Task Link：这里保存的是上一个TSS的段选择子，比如任务发生了切换，新任务执行完后，如何才能找到先前未能执行完的任务呢？就得依靠这个值了（前面不是说了Windows不用TSS进行线程切换嘛，是呀，但是这里讲解的这个字段的作用，设计初衷就是为了任务切换） ESP0/SS0：当发生提权时，0环的ESP和SS的值就是从这里取的 CR3：有人会问，我哪知道取哪个TSS的ESP0和SS0呢？就是这个值的作用了，这个值帮我们确定当前位于哪个线程，之后在页的篇章中会学到CR3的相关内容。 LDT：这个值通常都是0，Windows没有用到LDT表，因为LDT表只对当前的线程有用 I/O Map：这个位置涉及到硬件IO了，值一般是固定的 TSS段描述符 TSS段描述符只能存在GDT表中，不能存到LDT或者IDT中，所以它的结构和之前介绍的段描述符是类似的，区别在于个别位的不同 G位：在代码段/数据段描述符中，这个位置通常位1，因为这两个段的范围通常是4GB，而TSS的大小是104字节，单位是字节，因此这个值为0 Type域：这个值为1011或1001，其中B位是Busy位，置1时说明该TSS是否被载入或者嵌套，载入说明CPU正在执行该任务；嵌套则表明该任务处理了一半，切换到了另一个任务中去，但该任务并未执行完。 Base/Limit：Base确定TSS段的起始位置，Limit确定TSS段的大小，Base~Base+Limit就是TSS段的范围。 TR寄存器在一开始的探究段寄存器的文章中提过，CPU共有8个段寄存器，TR就是其中之一。先前提到过，TR寄存器的工作原理和其它段寄存器一样，通过段选择子加载GDT表的TSS段描述符中的信息，方便CPU找到TSS的位置，具体工作原理如下： 这里介绍两个操作TR段寄存器的指令LTR和STR： LTR：这是一个特权指令，只有0环的程序才能调用；作用是将段选择子写入TR寄存器 STR：STR不是特权指令，这个指令3环程序也可以调用，所用是读取TR寄存器的值 需要注意的一点，修改TR寄存器的值，只是会载入新的TSS段描述符信息，并不会对修改前的TSS段造成影响。 实现任务切换虽然说了Windows并没有将TSS用来进行线程切换，但是我们仍然可以手动实现任务的切换。 直接修改TR寄存器是不能做到任务切换的，但是可以通过JMP FAR或者CALL FAR来加载TSS段描述符来实现。下面分别使用两种方法来实现（两种实现方法细节有很多差别） 一般情况下，任务切换发生在下列四种情况之一： 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表中的TSS段描述符 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表或者当前LDT表中的任务门描述符 一个中断或者异常触发了在IDT表中的任务门描述符 当前任务执行IRET指令，且EFLAGS寄存器的NT位为1时 CALL FAR实现本次CALL FAR实现采用第一种任务切换的情况。 设计一个TSS，存储任务切换时必要的信息，其中包括ESP0，SS0，CR3，EIP，ESP，段寄存器，位图控制。 ESP0：也就是任务切换后的堆栈，可以自己创一个空数组，然后写入数组的首地址，就可以作为堆栈使用。 段寄存器及SS0：这些值，在0环通常都一样，可以进入Windbg参考其它TSS的值，这里使用的是SS/SS0 = 0x10，ES/DS = 0x23，CS = 0x8，FS = 0x30，GS = 0x0 EIP：这就是要跳转后执行的地方，可以写一个裸函数来验证是否切换成功，直接取裸函数地址即可，我这里的值为0x401020（每个人机器可能不一样） CR3：这个值，需要在执行前，中断到Windbg寄存器中，通过!process 0 0指令获取。 位图控制：这是一个默认值为0x20AC0000 构造完的TSS如下： c12345678910111213141516171819202122232425262728DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; 然后我们需要根据这个TSS的地址，来构造我们的TSS段描述符 地址为0x12fd70 因此TSS段描述符为：0000e912`fd700068，e->DPL=3：是为了3环的程序可以访问这个段描述符，0x68就是104字节，9说明未被载入。然后让我们填入段描述符 接着运行程序，需要采集Cr3的值，先中断到Windbg，再通过!process 0 0指令获取，取最后的一个值 在程序中填入cr3的值后回车，发现可以成功取到任务切换后ESP，CS，SS，并且均为我们设定的值，实验成功。 完整代码如下： c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include \"stdafx.h\"#include int saveEax, newESP;short newCS, newSS;__declspec(naked) void Get_Value() { __asm { mov saveEax, eax mov newESP, esp mov ax, cs mov newCS, ax mov ax, ss mov newSS, ax mov eax, saveEax iret }}int main(int argc, char* argv[]){ char stack[100] = {0}; char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; int Cr3 = 0; printf(\"Input: \"); scanf(\"%x\", &Cr3); getchar(); DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; _asm { call fword ptr buffer } printf(\"ESP: %x, cs: %x, ss: %x\", newESP, newCS, newSS); getchar(); return 0;} 以上是通过Call Far实现的任务切换。还有另一种方法，是通过JMP FAR来实现，而且JMP FAR实现会更加困难一些。这里简要概括一下，当使用CALL FAR时，CPU会自动帮你用当前任务的段选择子填写你TSS的Previous Task Link字段，同时给你的Eflags的NT位置1，这个NT位有什么用呢，就是关系到iret这个指令的意义，当Elfags的NT为1时，iret表示根据Previous Task Link的值，从当前任务返回到前一个任务中去，当NT为0时，这是一个中断返回指令。而当你使用JMP FAR实现时，你需要手动给Pervious Task Link字段赋上前一个任务的段选择子，此外你需要手动给Eflags的NT位置1，当然这可以通过 Code12345pushfdmov eax, [esp]or eax, 0x4000mov [esp], eaxpopfd 来实现，此外，还需要确保前一个TSS段的段描述符Busy位的值为1，这样才能确保该任务处在嵌入的状态。 总结这是开博客以来，最艰难的一篇了，看视频楞是没看明白，然后又去翻Intel白皮书，看明白了然后开始代码实现，CALL FAR的任务切换实现的还算顺利，但是JMP FAR的问题就比较大了，一下午都没整出来，蛋疼啊~ 不想再弄了，看了群友的代码，感觉自己好像也没写错，就是一直死。明天打算整一整任务门吧，完了就到页的知识了，那边掌握的还算不错，可以轻松一阵子了，坚持呀！ 参考资料：《Intel白皮书卷3-第七章》","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"陷阱门","slug":"陷阱门","date":"2020-03-15T08:31:07.000Z","updated":"2020-03-15T10:56:29.726Z","comments":true,"path":"2020/03/15/陷阱门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/15/%E9%99%B7%E9%98%B1%E9%97%A8/","excerpt":"","text":"这一篇来说陷阱门，陷阱门这东西，就没什么好讲的，应该Windows几乎没怎么用，陷阱门也是位于IDT表里的，列出前48个描述符，就没有陷阱门。。。 陷阱门描述符 看图，陷阱门描述符，和中断门描述符，就1个位不一样，中断门的Type域是1110，陷阱门是1111 代码实现代码实现也和中断门的完全一样，搬过来就行了。 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 与中断门的差别那可能有人要问了，既然陷阱门和中断门完全一样，有什么存在的意义。那还是有一点不同的，来看两次执行的结果： 同样的代码，执行结果不同，可以发现，陷阱门和中断门的区别在于，中断门执行后EFLAG寄存器的值发生了改变，而陷阱门不会改变EFLAG，这就是陷阱门和中断门的差别。 EFLAG寄存器结构 根据EFLAG寄存器的结构可以得知，中断门执行后，将IF位置0了，但陷阱门不会，这就是中断门和陷阱门的唯一区别。 那么这个IF位有什么用呢？为什么陷阱门要将IF位置0呢？ 稍查资料，可以了解到IF标志是用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。IF标志对不可屏蔽中断没有影响。 这里举个简单的例子说明下什么是可屏蔽中断，什么是不可屏蔽中断。打开任务管理器，可以看到有很多进程正在运行，这时候，你想把电脑锁屏，于是按下Win+L，这个时候键盘会向CPU发送一个可屏蔽中断，告诉CPU，用户按下了Win+L键，需要执行锁屏功能，如果此时EFLAG的IF位为1，这是CPU会短暂放下手上的任务，先去处理你的锁屏任务，处理完后，你的电脑锁屏了，CPU会继续运行刚刚处理的进程；如果此时ELFAG的IF位为0，那么CPU就和没听到一样，继续做它自己的事。如果遇到意外状况，电脑的电源线拔了下来，断电了，这时电源会向CPU发送一个不可屏蔽中断，这个中断不受IF位影响，CPU一定会去处理。这时有人会问了，断电后CPU还怎么工作？其实在主板上，是有电容的，可以在断电后让CPU再去做一些清理工作，这就是不可屏蔽中断。 总结中断门和陷阱门的唯一区别：中断门执行时，将IF位清零，但陷阱门不会。 参考教程：https://www.bilibili.com/video/av68700135?p=20","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"中断门","slug":"中断门","date":"2020-03-15T06:26:54.000Z","updated":"2020-03-15T08:13:54.134Z","comments":true,"path":"2020/03/15/中断门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/15/%E4%B8%AD%E6%96%AD%E9%97%A8/","excerpt":"","text":"上一篇提到过，Windows是不使用调用门的，所以在GDT表里没有找到调用门，那么Windows如何实现代码跨段，提权等行为呢？这里用的较多的是中断门，接下来就来介绍一下中断门。 IDT表与GDT的区别首先要提到IDT表（中断描述符表），在上一篇提到的调用门的门描述符，都在GDT表里，而中断门的门描述符在另一张叫做IDT的表里面。同GDT一样，IDT也是由一系列描述符组成的，每个描述符占８个字节。但需要注意的是，IDT表中的第一个元素不是NULL。 在Windbg中查看IDT表的基址和长度： IDT的构成IDT表可以包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 中断门执行流程有了IDT表的概念后，咱们就可以开始讲讲中断门的执行流程，实际上和调用门差别不是很大，可以类比的来看： 执行调用门的指令：CALL CS:EIP，其中CS是段选择子，包含了查找GDT表的是一个索引. 执行中断门的指令：INT N，其中N是IDT表的一个索引 执行流程就只有这个差别，当CPU通过N这个索引在IDT表中找到了中断门描述符后，执行的步骤就和调用门的步骤完全一样了，可以参考调用们的执行流程。这里要注意一点，当找到中断门描述符后，还是会通过描述符里的段选择子，去GDT表中找需要跳转的代码段。所以说中断门的执行会查找两张表，先查找IDT表，再查找GDT表。 中断门描述符简要说完了IDT表（实际上和GDT表没啥差别）来看看中断门描述符的结构： 粗略一看，和调用门描述符没差呀。这不就是无参调用门描述符换了个Type域嘛。没错，的确是这样（这里解释下D位，可以理解为段描述符的DB位，置0时为16位中断门，置1时为32位中断门）。当你发现这点时，说明调用门的结构你理解清楚了。因此结构不再赘述，可以参考调用门 中断返回与调用门使用长返回RETF不同，中断门使用中断返回指令：IRET/IRETD INT N指令： 在没有权限切换时，会向堆栈压入3个值，分别是CS，EFLAG，返回地址 在有权限切换时，会向堆栈压入5个值，分别是SS，ESP，EFLAG，CS，返回地址 这也是与调用门不同的地方，中断门会多压入一个值。于是有小盆友就要问啦，“死肥宅哥哥，为什么中断门会多压入一个参数呢？” 这还不明显吗，你想想人家调用门为什么要压入值进入堆栈啊？肯定是这些值会改变啊，所以要用堆栈保存一下，等长返回的时候，再还原状态；中断门多压入了一个EFLAG说明通过中断门跨段时，EFLAG的值会变啊！ 所以，在中断门中，不能通过RETF返回，而应通过IRET/IRETD返回，其实只要改改堆栈，就可以通过RETF返回中断门，IRETD返回调用门。 代码实现中断门比较简单，这里演示一个实现的范例 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 根据GetValue函数的地址构造中断门描述符，然后填入中断门里即可 执行结果如下： 然后我们用int 3中断到Windbg里验证一下 验证成功。 总结通过调用门与中断门的对比，来总结一下中断门： 调用门通过CALL FAR指令执行，但中断门通过INT指令 调用门查询GDT表，中断门查询IDT表（后续也会再查询GDT表） CALL CS:EIP中的CS是段选择子，由3部分组成，而INT N指令中的N只是索引，中断门不检查RPL，只检查CPL 调用门可以有参数，但中断门没有参数 参考教程：https://www.bilibili.com/video/av68700135?p=19","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"调用门","slug":"调用门","date":"2020-03-14T06:34:21.000Z","updated":"2020-03-15T08:09:52.571Z","comments":true,"path":"2020/03/14/调用门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/14/%E8%B0%83%E7%94%A8%E9%97%A8/","excerpt":"","text":"前一篇中提到CALL FAR指令最终跳转的地址是调用门里，今天就要分析一下调用门。首先从调用门的执行流程开始 调用门执行流程指令格式：CALL CS:EIP(EIP是废弃的) 执行步骤： 根据CS的值查GDT表，找到对应的段描述符，这个描述符是一个调用门。 在调用门描述符中存储另一个代码段的选择子 选择子指向的段的Base+调用门里的Offset，就是真正要执行的地址 光看描述，的确很难懂，结合调用门描述符来分析，会好理解很多 调用门描述符 高4字节8~15位：这是和普通段描述符完全一样的8位，其中第12位是判断该描述符是系统段还是数据段或代码段的位置，调用门描述符是系统段，所以此处值一定是0。接下来的Type域，这个根据段描述符那章中也能找到，32位的调用门描述符，Type域为1100，这也是确定的。 高4字节的高16位+低4字节的低16位：这两块区域加起来刚好是32位，构成一个Offset，也就是调用门执行流程第三步里Base加上的Offset，那么Base哪里拿呢？ 低4字节的高16位：这16位是一个段选择子，有段选择子，就可以拆分，于是RPL，TI，Index都能解析出来，这时候就可以根据Index去GDT表里找到段描述符，而这个段，就是调用门跳转的段，因此要用这个段的Base+Offset便可获得真正要执行的地址。 高4字节的低5位(第5~7位均为0)：这5位的作用是描述调用门传进去的参数，调用门是可以传参的，而参数的个数，决定了这个位置的值 下面，通过代码来验证调用门的执行流程。 无参调用门调用门分为无参和有参（示例默认都提权）两种情况，这里先用无参调用门进行实验： 构造调用门因为Windows是不使用调用门的，所以需要自己构造一个调用门：0040EC00 00081010 为什么要这样构造呢？先看最熟悉的那8位，EC = 11101100，P=1，S=1，调用门=1100，DPL为啥选取3呢。首先，调用门的提权在于通过调用门后，新的段选择子会修改CS达到CPL的提权，但是访问调用门描述符还是需要保证CPL=DPL，因此，DPL需要设置为3。由于无参调用门，也就没参数，因此参数位为0，EC00也就解释清了。 接下来看0008，这个也很好理解，段选择子嘛，拆分一下，RPL=0，Index=1，我们去Windbg里看一下就好了 这下就清晰了，指向00cf9b00 0000ffff这个段描述符，拆分一下，Limit=FFFFFFFF，G=1，Base=00000000，是个非一致代码段。看来想要跳转成功，也得是0环的代码段才行。 由于Base为0，那么跳转到的地方就是0+401010，那这个401010是哪来的呢？这得看代码才能说清。 代码实现c12345678910111213141516171819202122232425262728293031323334353637383940#include \"stdafx.h\"int saveEax = 0;short oldCS = 0;short newCS = 0;short oldSS = 0;short newSS = 0;int oldESP = 0;int newESP = 0;__declspec(naked) void GetValue() { __asm { mov saveEax, eax lea eax, [esp] //new esp mov newESP, eax mov eax, [esp+8] //old esp mov oldESP, eax mov eax, [esp+4] //old cs mov oldCS, ax mov ax, cs mov newCS, ax mov eax, [esp+0xc] //old ss mov oldSS, ax mov ax, ss mov newSS, ax mov eax, saveEax retf }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { call fword ptr [buffer] } printf(\"%x, %x, %x, %x, %x, %x\", oldCS, newCS, oldSS, newSS, oldESP, newESP); getchar(); return 0;} 来看一下代码，从main函数开始看起，我们自己构造一个CS:EIP（EIP已废弃）的6字节char型数组，然后在汇编中执行CALL FAR调用我们构造的CS:EIP，接着打印部分内容。 可以看出执行调用门的语句嵌入了汇编里，根据上方在构造调用门时的分析可以得出，最终调用门跳转的地址会是401010，那么这个401010是怎么来的呢？其实就是GetValue函数的地址，我们知道通过调用门后会跳转到一个地址，但是如何才能检测成功跳转并提权呢？就得有一个函数来收集这些信息并将其打印出来，也就有了GetValue函数（GetValue地址通过VC下断点查看，然后写入构造的调用门描述符中）GetValue要声明成裸函数，这样堆栈只需自己平衡，可以避免元素访问的位置过远。 根据前一篇文章的内容，如果跨段并提权，堆栈内部大致情况如下 因此，这里采用通过全局变量，来依次读取堆栈不同位置的值，并打印查看结果。 由结果看，ESP，CS，SS均发生了切换，且CPL变为0，ESP的值也变为了一个高2G的数 为了验证结果的正确性，我们可以通过中断再看一下0环的堆栈结构，将裸函数中的汇编代码清除，只留下int 3和长返回语句如下： Code1234_asm { int 3 retf} 然后重新执行，会中断到Windbg（为什么会从虚拟机中断到Windbg，这个到后面中断部分会详细讲解）查看栈顶部分内存 注意：这里的栈顶esp的值和刚刚不一样是因为程序重新执行了，进入0环时，ESP和SS是TSS给的，而TSS内的值是当前线程给的，因为代码修改了，所以重新执行程序时，线程不一样了，所以0环的堆栈也就不一样了。但是3环的数据是没有变的（理论上也是会变的，这里没变是因为编译器的优化），对比刚刚手动读取的结果来看，3环的ESP，CS，SS完全一致，说明刚刚调用门的实验成功提权进入0环。 有参调用门无参说完了，接下来是有参调用门，有参调用们和无参的区别在于仅仅是参数位的值会有所变动，栈里多了push进去的参数，其余和无参基本上相同。 构造调用门 这里构造的调用门描述符是：0040EC03 00081020，（地址变成了401020，是因为我重启了下虚拟机所以GetValue函数地址变了，并不影响），需要注意的是参数位设置成了3，因为这次计划传入3个参数进去。 代码实现由于Push了参数进去，所以不确定参数在0环堆栈中位于什么位置，于是先用int 3的方法，在Windbg中查看一下堆栈的情况 图中可以发现，在压入参数的调用门进入0环后，参数位于3环ESP和3环CS中间的位置，堆栈表示大致如下： 这样，就可以来编写代码了，总体和无参的差距不大。 c1234567891011121314151617181920212223242526272829303132#include \"stdafx.h\"int saveEax = 0;int para1, para2, para3;__declspec(naked) void GetValue() { __asm { mov saveEax, eax mov eax, [esp+8] mov para3, eax mov eax, [esp+0xc] mov para2, eax mov eax, [esp+0x10] mov para1, eax mov eax, saveEax retf 0xc }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { push 1 push 2 push 3 call fword ptr [buffer] } printf(\"%x, %x, %x\", para1, para2, para3); getchar(); return 0;} 需要注意一点，这里由于push了3个参数，所以长返回的时候要用RETF 0xc来平衡堆栈，否则直接中断到Windbg，要是不处理的话就蓝屏了。 代码执行效果如下，成功在0环堆栈取到了push进入的参数。 总结 当通过门，权限不变时，只会PUSH两个值：CS和返回地址，新的CS的值由调用门决定 当通过门，权限改变的时候，会PUSH四个值：SS，ESP，CS，返回地址，新的CS由调用门决定，新的SS和ESP由TSS提供 通过门调用时，要执行哪行代码由调用门决定，但使用RETF返回时，由堆栈中压入的值决定，也就是说，进门时，只能按指定路线走，出门时，可以翻墙（只要改变堆栈里面的值就可以想去哪去哪） 可不可以再建个门出去呢？也就是用Call，当然可以。 参考教程：https://www.bilibili.com/video/av68700135?p=17","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"长调用与短调用","slug":"长调用与短调用","date":"2020-03-14T01:29:45.000Z","updated":"2020-03-14T06:15:50.000Z","comments":true,"path":"2020/03/14/长调用与短调用/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/14/%E9%95%BF%E8%B0%83%E7%94%A8%E4%B8%8E%E7%9F%AD%E8%B0%83%E7%94%A8/","excerpt":"","text":"在上一篇章中提过，实现跨段的跳转，可以使用JMP FAR指令，但是想要实现跨段的调用，就需要学习一个新的指令CALL FAR；CALL FAR指令要更为复杂一些，原因是JMP指令是不影响堆栈的，而CALL指令会影响堆栈。 短调用首先来回顾下短调用，短调用其实就是普通的CALL调用，是相对于CALL FAR而言，所以叫做短调用。短调用会影响EIP寄存器和ESP寄存器，因此在返回时需要额外去平衡一下堆栈；短调用属于三环知识，这里不再赘述，具体的调用和返回时的堆栈变化如下图所示： 长调用（跨段不提权）长调用分为提权和不提权两种，这里先讲不提权的情况。 这图看不明白没关系，一个个分析。首先，EIP为什么是废弃的？因为，这个长调用指令，压根不会跳转到你给的EIP的位置，而是会跳转到调用门里提供的地址。那什么是调用门呢?下一篇会具体提到， 这里简单概括调用门就是一种位于GDT表里特殊的描述符。 回到长调用这里，当CALL执行后，与一般的调用指令不同，长调用使得堆栈提升了8个字节，除了返回地址外，还压入了调用者的CS，以便在调用返回至原来程序时，CS也能得到恢复。其中返回地址依然是位于[esp]处，调用者的CS位于[esp+4]处。 长调用返回也与普通调用不同，普通调用使用ret指令即可返回到原来程序的位置，而长调用返回时需要使用长返回指令RETF，长返回指令除了会将返回地址送入EIP寄存器，还会将CS恢复至执行前的状态，同时平衡堆栈。 长调用（跨段并提权）不提权的长调用还稍微好理解一点，提权的长调用，就稍微有些复杂了，由于发生了提权，CS的CPL发生了改变，根据Intel的规定，CS和SS的CPL一定要保持一致，所以此时SS的值也会发生改变，除此之外，因为发生了提权，堆栈从3环的堆栈变为了0环的堆栈，因此ESP也会发生改变。所以提权的长调用会4个寄存器的值发生改变，分别是EIP，CS，ESP，SS，来看一下执行前后的变化 提权后，分别将返回地址，调用者CS，ESP，SS压入了0环的堆栈中，这样在返回3环时，可以确保这些寄存器恢复到原本的状态。 同样，提权后返回用的也是RETF，长返回指令，分别将返回地址，调用者的CS，ESP，SS压入相应的寄存器中，大致如下： 总结长调用相较长跳转更为复杂，这篇只是做个简单的介绍，在后面的篇章中，将通过分析调用门的实现过程来详细讲解长调用，这里对本篇提到的几个特点做些总结。 跨段调用时，一旦有权限切换，就会切换堆栈 CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样 JMP FAR只能跳转到同级非一致代码段或者共享段，但CALL FAR可以通过调用门提权，提升CPL的权限 参考课程 : https://www.bilibili.com/video/av68700135?p=16","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"代码跨段跳转（不提权）","slug":"代码跨段跳转","date":"2020-03-13T02:24:36.000Z","updated":"2020-03-13T15:47:09.308Z","comments":true,"path":"2020/03/13/代码跨段跳转/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/13/%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5%E8%B7%B3%E8%BD%AC/","excerpt":"","text":"之前的篇章中提到过，除了CS段寄存器外，均可使用MOV或LES,LSS,LDS,LFS,LGS指令进行修改；为什么CS不可以直接被修改呢？ CS是代码段的段寄存器，CS的改变意味着EIP的改变，所以无法使用上述指令进行修改 代码跳转指令代码的跳转指令分为2种，一种是同时修改CS和EIP的指令，另一种，只修改EIP指令，具体如下： 同时修改CS和EIP：JMP FAR/ CALL FAR / RETF / INT / IRETD 只修改EIP：JMP / CALL / JCC / RET 本篇用到的是JMP FAR指令。 JMP FAR指令：和普通的JMP指令不同，JMP FAR实际是在JMP指令后写上6个字节，例如 JMP 0x4B: 0x00401456的形式。 其中0x4B是段选择子，0x00401456是跳转地址。 若能成功执行，0x4B会写入CS中，0x00401456会写入EIP中，代码发生跳转。 代码跳转流程JMP 0x20:0x004183D7 CPU如何执行这行代码? 段选择子拆分0x20 对应二进制 0x0000 0000 0010 0000 RPL：00 TI：0 Index：4 查表得到段描述符 TI = 0 所以查GDT表 根据Index = 4 找到对应的段描述符 四种情况可以跳转：代码段、调用门、TSS任务段、任务门（其中调用门，TSS任务段以及任务门，都属于系统段） 之前段描述符的篇章提到过，可以根据段描述符的属性判断属于哪个段，通过看属性的那16位：由于代码段和数据段的S位值为1，所以一般第12-15位为字节9/F，而代码段的Type域的第1位为1，所以代码段的Type域一定大于等于8。因而判断代码段描述符的第8-15位通常在98-9F或者F8-FF这个范围内。 权限检查权限检查分为非一致代码段和一致代码段两种情况，下面我们分别来看 非一致代码段非一致代码段，要求：CPL == DPL 并且 RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（下）","slug":"一次简单的Hook-下","date":"2020-03-12T07:38:30.000Z","updated":"2020-03-12T15:23:43.627Z","comments":true,"path":"2020/03/12/一次简单的Hook-下/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/12/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8B/","excerpt":"","text":"前一篇已经完成了对GetMsgAbstract函数的分析，发现，当执行到GetMsgAbstactByElement这一步时，已经可以根据寄存器用来传递的参数获取聊天内容，这篇来根据分析的内容编写用来Hook的dll。 Inline Hook这里先对Inline Hook做个简要概述，它是一种通过修改指令的方法，转移程序的执行流程，在程序执行某函数前或者某函数后，先执行你定义的Hook函数，拿到需要的参数信息，再根据需要对参数信息进行加工，从而完成Hook。常见的手法如下： Code11. jmp xxxxxxxx (5字节) Code12. push xxxxxxxx/retn (6字节) Code13. mov eax, xxxxxxxx/jmp eax (7字节) Code14. call Hook 根据需求不同，替换掉原本的指令长度不同，从而选择的手段也不同；本篇中采用6字节的方式 构建DLL一般构建一个dll要分别去编写头文件，C/C++源文件以及入口点函数。首先我们先从头文件开始。 头文件 打开Visual Studio，新建一个动态链接库(DLL)项目，VS会自动帮忙生成头文件和源文件，点击头文件stdafx.h开始编写 其实VS已经帮忙生成好了大部分，只需要定义自己需要实现的函数和方便自己使用的宏即可 这里为什么不写成下面这种形式呢？ c1__declspec(dllexport) BOOL WINAPI Msg_Hook(); 因为这个dll的主要作用是hook，并不需要有导出函数，即使有了被我们hook的程序也不会主动去调用（因为它的代码里面根本没有调用我的dll的代码），所以干脆就不写了，没什么影响。 入口点函数VS帮我们生成好的入口点函数如下： 在这里其实只需要把刚刚定义的函数，写在DLL_PROCESS_ATTACH的地方即可，因为在dll加载到进程时，会先调用入口点函数，传入的参数则是DLL_PROCESS_ATTACH，这样就可以调用我们的Hook函数了。 源文件源文件的编写是比较关键的一步，主要功能的实现都在这里。首先，我们需要实现Hook用的函数。 Hook函数 首先编写一个大致的框架，来分析一下都做了些什么，还缺一些什么。 Inline Hook的核心在于修改指令，从而实现程序流程的转移。具体的流程就是，找到需要修改的位置，修改当前位置的指令。 修改指令的大小这里采用的是push xxxxxxxx/retn的手法，所以需要创建一个6个字节的char型数组。 修改的位置修改的位置如何确定？之前在OD分析反汇编程序时，确定在调用GetMsgAbstractByElement之前就可获取到消息内容，发现，调用这个函数的call语句加上之前的push eax，刚好6个字节，这就是Hook点了 这个位置位于KernelUtil.dll中，所以我们可以补充第三条语句改成如下： Code1DWORD modify_addr = (PROC)GetModuleHandle(\"KernelUtil.dll\") + EntryOFFSET; 同时也可以根据基址确定EntryOFFSET并写在开头。 如何修改？这里采用Windows提供的ReadProcessMemory和WriteProcessMemory这两个函数，参数非常好理解，当前进程，需要修改的地址位置，修改的字节，修改字节的长度以及一个可以忽略的参数。在读的时候，指定位置的指定大小的字节会被保存进定义的char型数组里，写的时候就是把修改后的字节写回原来的地址。那我们要如何确定该写什么呢？ 根据push xxxxxxxx/retn指令，可以确定第一个字节和最后一个字节分别为0x68和0xC3。中间的4个字节填什么？就是执行我们做手脚的函数地址了。Hook函数的作用就是转移程序执行的流程，将程序转移到我们自己定义的函数，我们自己的函数就可以对当前的程序做些手脚，比如读取函数接收的参数，并将其传递出来。 目前为止，经过分析，可以进一步完善源程序。 接下来，就来编写自己的函数，将消息内容传递出来。 功能函数功能函数其实就是用汇编写一个裸函数，为啥要用裸函数？这样的话，编译器就不会自动帮我们生成如下这三行指令： Code123push ebpmov ebp, espsub esp, 0x20 而是我们自己平衡堆栈，所以就可以避免很多额外的偏移造成的麻烦，经过上一篇的分析已知，当函数到达GetMsgAbstractByElement的位置处时，可以通过[[ebx+0x28]]+0x18获取消息内容。那就可以采用一下方式： Code123456pushadpushfdmov eax, [ebx+0x28]mov eax, [eax]mov eax, [eax+0x18]mov Msg, eax 这样只要在外部定义一个变量Msg，即可将消息取到，然后可以利用OutputDebugString将消息内容输出到DbgView里观察。 但这还没有结束，因为之前覆盖掉了GetMsgAbstractByElement，所以这次需要重新再调用一遍。所以我们需要获取GetMsgAbstractByElement的地址，先通过当前地址和基址相减算出偏移0xBE0B0，然后通过KernelUtil.base+Offset确定函数的地址。这时只需要在平衡堆栈后的地方，补上之前替换掉的6个字节即可。 最终功能函数实现如下： 实验结果我们使用OD，将编写的dll注入进去 注入后此处代码发生了变化 观察DbgView，发现成功拿到消息内容","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"第一周","slug":"第一周","date":"2020-03-11T12:40:24.000Z","updated":"2020-03-11T12:49:59.321Z","comments":true,"path":"2020/03/11/第一周/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/11/%E7%AC%AC%E4%B8%80%E5%91%A8/","excerpt":"","text":"今天是开博客的第七天，说满意其实也不是很满意，进度还是很慢的，当然计划也是长远的。一个是希望能坚持下来，也很久没坚持做一件事了；另一个是希望能够在4个月左右的时间，将所涉及的三个领域的基础知识，真正的掌握了，希望自己能真正尽力。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://cataloc.gitee.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"段权限检查（数据段）","slug":"段权限检查","date":"2020-03-11T01:55:19.000Z","updated":"2020-03-11T07:54:44.536Z","comments":true,"path":"2020/03/11/段权限检查/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/11/%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5/","excerpt":"","text":"访问违例问题在介绍内容前，先看两个程序 两个程序的差异仅仅在于段选择子的不同，结果则是一个访问成功另一个访问违例了。分别对两个段选择子进行拆分： Code10023 = 0000 0000 00100 0 11 RPL：3 Index : 4 Code1002B = 0000 0000 00101 0 11 RPL：3 Index : 5 可以看出，两个段选择子的差别仅在Index的不同，也就是指向的段描述符不同，再来看看两个段选择子对应的段描述符 注意：由于Index是从0开始算的（和数组一样），所以对应的实际上是表中第五个和第六个段描述符。 根据之前段描述符属性的内容，来查看属性位，分别为： Code1Attr: CFF3 DPL:3 Code1Attr: 008B DPL:0 可以发现，两个段描述符的DPL不同，之前在段选择子的篇章中提到过，在将段选择子指向的段描述符加载到段寄存器时，一定要保证数值上（RPLDPL。那为什么RPL>DPL就会出错呢？下面来逐步解析。 CPU分级先来了解一下CPU分级 CPU共划分了4个等级，Ring0~Ring3，其中Ring3级别最低，Ring0级别最高。这个分级是CPU划分的，并不是操作系统所划分的，操作系统只是使用了这个分级，其中Windows系统只用了Ring3和Ring0两个等级，分别表示应用级和系统级。应用级的程序往往不能访问系统级，所以保护模式不仅仅是防止段的胡乱访问，还保证了程序在相应的级别稳定的运行。 CPLCurrent Privilege Level，当前特权级，之前段选择子篇章中讲过，段选择子的后2位的值为RPL，而CPL指的CS或SS中的段选择子的后2位（CS/SS的后两位一定是相同的，所以无论用哪个作为CPL都一样），也就是说CS或SS的RPL就是当前程序的CPL。 下面来查看两个CPL： 随便拖一个程序进入OD，根据CS/SS可以算出当前程序的CPL为3。因为这些程序都是Ring3的程序。 按Ctrl+Break在Windbg中断下，查看寄存器，可以发现当前CPL为0。因为Windbg在调试系统时执行的都是内核函数，所以处在Ring0。 DPL Descriptor Privilege Level：描述符特权级别。在段描述符属性那一篇中解析DPL时提到过，在段描述符高4字节的第13~14位就是DPL，那么DPL到底有什么用呢？和CPL有什么关系呢？ DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么。 通俗的理解：如果你想访问我，那么你应该具备什么特权。例如： Code1mov ds, ax 如果ax指向的段DPL = 0 但当前程序的CPL = 3 这行指令是不会成功的，因为CPL = 3是应用层，权限较低，是不能访问DPL = 0的系统层的；这也是为什么之前的例子中会出现访问违例。 RPLRequest Privilege Level：请求特权级别 有小盆友可能会问了，既然已经有CPL和DPL，那只要CPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（上）","slug":"一次简单的Hook-上","date":"2020-03-10T01:36:42.000Z","updated":"2020-03-10T09:48:23.338Z","comments":true,"path":"2020/03/10/一次简单的Hook-上/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/10/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8A/","excerpt":"","text":"这一次hook小实验的目标是hook出某社交软件中的实时聊天内容，主要目的是了解hook的原理以及在hook之前对程序的分析流程及其他准备工作，从而对于hook有个完整的认识。 准备工具 OllyDbg调试器：用于单步跟踪，动态调试等。 IDA pro调试器：用于静态分析函数代码结构等。 Mircosoft Visual Studio 201*(版本随意)：用于dll代码编写 DbgView：捕获并查看程序中由OutputDebugString输出的信息。 Hook的分类Hook无非只有两种类型，一种是通过修改数据（通常是引用的函数地址）进行的Hook，这如何理解，简单而言，很多大型程序，都需要通过调用各式各样的函数库来实现一些功能，而这种Hook就是通过修改程序调用的函数地址，改成自己写的函数，从而额外实现一些功能，实现对程序的Hook，例如IAT Hook；另一种是直接修改函数内的指令进行Hook，通过控制函数内的跳转，在函数执行时，实现一些自己的功能，然后再返回到函数使之正常运行，例如Inline Hook。这次Hook实验，采用的就是Inline Hook的手法实现。 基址与偏移在逆向分析中，通过基址和偏移定位一个函数，会非常方便，同时可以对IDA的代码进行基址重定位，从而达到和OD的同步分析。 如何确定基址呢，一个程序需要调用一个外部的库函数，或者加载dll来实现某些功能，当dll被加载进程序时，会根据默认基址0x10000000进行载入dll，但是一个程序往往会加载多个dll，此时dll会根据重定位表来对dll进行重定位，基址也会有所变化。由于dll中的导出函数，距离基址的偏移是固定的，所以只要确定需求函数与dll基址的偏移，就可以轻松定位到这个函数。如图，将程序被OD附加时，通过点击上方的E按钮，进入模块列表，左边第一栏的Base就是dll的基址，例如IM.dll在此次加载时的基址为0x62840000。 右键View name查看IM.dll的导出函数，可以发现此次加载时PostTask_Session这个函数的地址为0x628E6EF9，相减可得偏移为0xA6EF9，以后每次只需确定IM.dll的基址，就可以通过偏移直接确定PostTask_Session的地址，这在hook代码中很有用。 程序分析流程查找需要被Hook函数根据我们需要Hook的功能来看，要截取实时聊天的数据，需要对接收聊天内容的函数做手脚，猜想这个函数的函数名一定与Message有关，例如GetMessage，RecvMessage等。将程序附加进OD，点击E查看Tim加载的主要模块(dll)，找到一个KernelUtil.dll，为啥找这个dll呢？根据之前逆向，发现很多功能都是由这个dll实现的，从dll名也可以看出这是一个实现功能的dll。右键View name，查看dll的导出函数。 查看和Message有关的函数，最终会发现一个名为GetMsgAbstract的导出函数 为什么选这个函数呢？因为看名字猜测这是一个获取消息摘要的函数，也许和收发消息有一定的关联，因此可以拿出来进行试一试。 在函数的开头，下一个断点，然后在Tim内任何发送一条消息。发现程序断了下来，说明这个函数的确和消息有关。 寻找聊天内容尽管确定了，这个函数和聊天消息有关，但是只有真正找到了消息内容，这个函数才能够被利用，否则还得换另一个函数分析。首先按照F8单步执行(不步入函数，为了节省时间并快速定位)，每当一个函数(call语句)执行完后，都要观察堆栈和寄存器的变化，看看是否有重要内容。继续单步，直到发现一个函数GetMsgAbstractByElement，这个函数执行完后，会在堆栈[ebp-8]的位置出现刚刚发送的消息。 这时，我们可以进一步GetMsgAbstractByElement，来寻找发送的消息是如何出现的。 函数入口 右图开始分析，在调用GetMsgAbstactByElement之前，共push了5个参数进去，其中第一个push进去的参数0x548FA04，此时所指向的堆栈中的值为0，第三个push进去的0x548FA01，所指位置，截断了堆栈中部分数据，也无意义。第四个push进去的参数，值为0，同样也用不到。第五个push进去的参数，首先将[ebp-8]处的地址加载到eax，然后再push进去，根据前一次的步入，已知函数执行后，[ebp-8]的位置即是发送的消息，但该参数用于存放取完后的消息，并不是消息的源头。这样就只剩下第二个参数，右键ebx，Follow in dump，进入数据窗口，并没有发现消息内容的存在，因此可以猜测，这是一个包含了消息的结构体，至于如何结构结构体获取消息，还得步入GetMsgAbstactByElement函数作进一步分析。 GetMsgAbstactByElement函数按F7步入函数 可以发现，栈顶足足降低了0x70字节，所以push进来的参数暂时只能靠[ebp+偏移]来访问，关注点仍然放在第二个参数的值上，目前除了ebx仍然为此值，push进入堆栈，目前位于[ebp+0x14]的位置，值也相同，由于[ebp+0x14]是作为参数push进来的，所以ebx的值多半用不到了，接下来只需关注[ebp+0x14]的值。 同一张图，距离函数开始不远，就有一条赋值语句将[ebp+0x14]的值赋给edi，这时edi的值也会成为第二个参数的值，同样需要关注。接着继续单步分析。 单步执行到这里时发现，在一次函数调用前，将edi作为参数push了，此外又将[ebp-0x20]处的位置清零，需要留意关注，然后单步步过该函数观察变化。 该函数执行后发现，[ebp-0x20]处的位置多了个数，右键-Follow in dump，进入数据窗口发现，在0x18偏移的位置，正好是发送的消息。这下就可以确定，是此处的call dword ptr ds:[eax + 0x48]这条语句，将传入的参数结构体进行解构，找到了消息。 解构参数结构体的函数接下来重新运行程序，再发送一条新的消息并断下。单步到call dword ptr ds:[eax + 0x48]处，按F7单步进入该函数。 这个函数并不长，但是实现了很关键的功能 Code1mov ebx,dword ptr ss:[ebp+0x8] 这一步，将[ebp+8]的值给到ebx，而这个值恰好就是外部传进来的需要解构的结构体，接下来需要关注涉及到ebx的指令。 其中接下来一条，将[ebx+0x38]的地址赋给eax，但是eax接下来就被重新赋值了，所以只需向下关注，其中这里方框框住的两行，实际上做了个减法运算，之后eax的值再一次被重置。接下来的一步，ecx也被清零了。 Code1mov eax,dword ptr ds:[ebx+0x28] 这是非常关键的一步，为什么说它关键呢，因为这时候已经脱离了ebx，说明ebx已经将结构体内部的信息传递给了eax上了，接着继续看eax，同时跟进[ebx+0x28]数据窗口查看。 Code1mov eax,dword ptr ds:[eax+ecx*4] => mov eax,dword ptr ds:[eax] 由于ecx的值为0，便可做一个优化。此时再去跟进[eax]数据窗口查看。 发现，刚好有一条发送出去但是还未接收到的消息。至此大功告成，已经确定GetMsgAbstractElement函数的解构过程： 首先将外部传入的第二个参数，赋值给edi寄存器暂存 接着将edi寄存器内的值作为参数，传入到一个解析结构体的函数内 进入函数，先将原先edi寄存器保存的参数，赋值给ebx寄存器 然后将ebx+0x28所在地址的值赋值给eax寄存器 最后eax寄存器将保存的值作为地址，进入后发现，在0x18处偏移，刚好就是保存的消息。 结论验证通过上述分析可以发现，在执行GetMsgAbstractElement，就可以通过其第二个push进去的参数，获取到消息内容了。这时，我们再次运行重新，发送消息，并重新断下。通过之前推论得出的偏移来计算： Code1[[ebx+0x28]]+18 该命令可以达到一个地址，而这个地址就应该存着消息。 验证成功。尽管我们是从GetMsgAbstract进来开始分析的，但是在分析的过程中发现GetMsgAbstractElement在执行前，就可以拿到消息内容，而GetMsgAbstract，执行的过程中总会执行GetMsgAbstractElement，因此可以在GetMsgAbstractElement函数执行前做手脚，注入我们的代码实现对消息内容的Hook。至于Hook代码的编写，限于篇幅，将在下一个部分呈现","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"段描述符属性","slug":"段描述符属性","date":"2020-03-09T09:19:09.000Z","updated":"2020-03-13T13:22:38.361Z","comments":true,"path":"2020/03/09/段描述符属性/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/09/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%9E%E6%80%A7/","excerpt":"","text":"之前介绍了，段描述符是用来填充段寄存器余下位置的，然而段寄存器余下位置有80位，而段描述符仅有64位，那到底是如何填充的呢？这篇就从这个问题开始，逐步探究段描述符的属性。首先，回顾一下段描述符的结构： P位P位，位于段描述符高4字节的第15位，是判断描述符是否有效的位置。 P = 1: 该描述符有效 P = 0：该描述符无效 G位在解析G位前，先来回顾下之前的问题，64位的段描述符到底是如何分配给段寄存器余下80位的。 首先回顾一下段寄存器的结构： c123456struct SegMent { WORD selector; WORD attribute; DWORD base; DWORD limit;} 段选择子： 由mov/les/lds/lss/lfs/lgs指令直接写入16位。 属性：段描述符中高4字节的第8-23位，刚好16位，作为属性写入段寄存器。 基址：将段描述符高4字节中第24-31位，与第0-7位拼接成作为高16位，低四字节的第16-31位作为低16位，拼接成32位，作为Base，写入到段寄存器里。 (这里没用~号是因为会转义成删除线) 限长：这里就要用到G位了。首先观察段描述符结构，可以发现，在高4字节的第16-19位，与低4字节的第0-15位，都是段限长，将他们拼接起来，也就是20位，那这20位是如何扩展成32位呢？这里就要用到这部分的关键G位了，当G的值为0时，表示以字节为单位，这时，假设Limit的值加起来为FFFFF(20位)，则取0x000FFFFF作为Limit写入段寄存器；当G的值为1时，表示以4KB为单位，这样去理解，如果一个段的大小为1KB，也就是1024B或0x400B，这时，实际上能取的范围是0-1023或0-0x3FF，所以此时的Limit应该为3FF。这样当以单位为4KB来计算一个段的Limit时，若Limit的值为1，说明可以取0和1两个值，也真正的大小实际上是2，所以用2*4KB=8192B=0x2000B，但是真是可以取到的值为0-1FFF，所以此时写入段寄存器Limit的值为1FFF。同理，若段描述符Limit的值为FFFFF，真正写入段寄存器的值为FFFFFFFF(32位)。 具体的公式如下： Code12345G = 0: = LimitG = 1: (Limit + 1)*4KB - 1 = Limit*4KB + 4KB - 1 = (Limit","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"段描述符与段选择子","slug":"段描述符与段选择子","date":"2020-03-08T11:31:33.000Z","updated":"2020-03-13T13:22:59.224Z","comments":true,"path":"2020/03/08/段描述符与段选择子/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/08/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90/","excerpt":"","text":"在探究段寄存器属性时，注意到，段寄存器在读的时候，只读了16位，但是写的时候会写入96位。那么，段寄存器是如何做到写入96位的呢？今天就要研究两个新的概念：段描述符与段选择子 基础知识Windbg指令Windbg是在调试Windows系统内核时常用的一个调试器，之后也会多次用到；通过Windbg可以实现主机对虚拟机上的Windows系统进行双击调试。搭建双击调试环境可以参考此贴：https://blog.csdn.net/q1007729991/article/details/52710390 这里，简单介绍一下，在研究段描述符和段选择子所需用到的几个Windbg指令： 命令 含义 r 查看和修改寄存器 dd 以4字节分隔，显示指定内存区域的数据内容 dq 以8字节分隔，显示指定内存区域的数据内容 第二个d和q分别是dword和qword的意思，第一个d是一个查看内存的指令，以后会详细说明。 汇编基础这里补充一点汇编基础，如何在确保，给一个拥有6个元素的char型数组赋值时，确保元素所在高位或者低位呢？ 通过观察反汇编可以看出，0x78处在 [ebp-8]的位置上，距离ebp相对较远；0x12处在[ebp-5]的位置上，距离ebp相对较近，两者差了4个字节，我们可以假象在地址空间中的位置如下表： 地址 值 0x12ff40(随便取个值) 0x78 0x12ff41 0x56 0x12ff42 0x34 0x12ff43 0x12 0x12ff44 0x23 0x12ff45 0x00 而Windows操作系统是小端模式，也就是高字节保存在高地址中；例如0x12在0x12345678这个数里属于高字节，0x12所在的地址位0x12ff43相当于0x78位于高地址，所以在赋值时，需要把0x12放到高地址中，根据小端模式在内存中的排列可知，若想确定一个实际值为0x12345678的数，在内存的排列大概是”78563412“这种形势，因此在赋值时按照如下方式： 这里还有一个坑是，赋值时不要加’ ‘，因为一个字节的数不止一个字符，不能放到单引号里。 GDT，LDTGDT和LDT分别指全局描述符表和局部描述符表。由于Windows系统没有使用LDT表，所以可以忽略这个表。而GDT表，表里存储的就是段描述符。 了解GDT表，需要先知道这个表有多大，存在哪里。这时需要借助一个寄存器gdtr，这是个48位的寄存器，其中32位存的是GDT表的位置，16位存的是GDT表的大小；可以通过以下指令进行查询。 由图可知，当前虚拟机中的操作系统，gdt表位于0x8003f000的位置，大小是0x03ff，也就是说从0x8003f000~0x8003f3ff这段内存中，存放着gdt表。 段描述符当执行以下语句时： Code1mov ds, ax CPU会去查表，根据ax的值决定查看GDT表还是LDT表，以及查找表的什么位置，查出哪些数据 首先查看一下GDT表，由于段描述符大小是8字节/64位，所以采用dq指令进行查看。 这里查看了GDT表0x80个字节大小的内存，一个段描述符的大小是8字节，所以显示了16个段描述符。 接下来看一下段描述符表的结构 可以发现，在段描述符中，有着Base，Limit，还有各种Attribute，这些就是从段描述符中查找的数据，并写入段寄存器剩下的80位里。那么有了GDT表和段描述符，那么究竟该选择哪一个段描述符的数据写入段寄存器呢？这就涉及到另一个结构：段选择子 段选择子“段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符”。 这句话怎么理解，怎么又是16位的段描述符，又是GDT表的段描述符？首先，段的Base，Limit以及Attribute都是由GDT表的段描述符来决定的，那么到底是由哪个段描述符来决定的？为了确定这个段描述符，引入了段选择子这个结构，段选择子，指向了GDT表中某一个段描述符，这样就可以把该段描述符的数据写入到段寄存器内了。所以说，段选择子，是一个段描述符的描述符。下面是段选择子的结构。 由图，结构非常简单，各个位的含义也比较好理解。这里有个小g巧，段选择子一共16位，由于Windows没有使用LDT表，所以TI位永远是0。请求特权级别一般也只有0和3，所以段选择子最后4位的值只有4种组合：0000, 0011, 1000, 1011 加载段描述符至段寄存器除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器。 CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，以后的文章会说到。 Code1les ecx,fword ptr ds:[buffer] //取buffer高2个字节给es，低4个字节给ecx 这里的buffer是一个地址，存了6个字节的数，例如定义buffer为一个6个元素的char型数组。这里的fword指的是三字，也就是6个字节 注意：在数值上需要要求RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"浅谈对称加密传输","slug":"浅谈对称加密传输","date":"2020-03-07T09:19:26.000Z","updated":"2020-03-09T13:59:14.424Z","comments":true,"path":"2020/03/07/浅谈对称加密传输/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/07/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/","excerpt":"","text":"看到crownless一篇关于Tor原理解析的文章，涉及到了加密传输的部分，以前没仔细理解，现在用通俗的语言记录下来。 基础概要对称加密所谓对称加密，就是通信双方，在发送和接收数据时，使用同一个密钥key对数据进行加密与解密。发送方和接收方必须在数据传送前商定好秘钥。 优点：加密速度快、效率高。 缺点：一旦密钥泄露，加密信息不再安全 25519曲线Curve25519椭圆曲线，是基于蒙哥马利曲线的密钥协商算法，具体如下 蒙哥马利曲线算法，可以做到”Time-constant”，也就是说不论他们进行运算的数值是多少，他们所花的时间是相同的，可以规避“ 时间旁路 ”攻击。（crownless文中有提到这是一种很神奇的可以在不安全的信道上建立共享的对称密钥的方法） 传输过程密钥获取Bob为了访问Alice，先访问Tor的目录服务器，获取一部分Tor节点的IP地址，并从中随机选择三个节点的IP地址A、B、C。然后，Bob会先和A节点通过Curve25519椭圆曲线算法以及协商所需的参数，协商一个对称密钥keyA；这时A节点会将Bob协商密钥所需参数发送给Bob。Bob通过算法计算出对称密钥keyA。之后，Bob和节点A之间就会用这把对称密钥keyA进行加密通信。 然后，Bob把B的IP地址和与B协商密钥所需的参数用对称密钥keyA加密后发送给A。A用keyA解密后，将Bob与B协商密钥所需的参数发送到B的IP地址。B收到参数后产生了对称密钥keyB，并将与Bob协商密钥所需的参数发还给A。A将参数通过keyA加密后发还给Bob。Bob用keyA解密后通过算法计算出对称密钥keyB。Bob通过相同的方法和C协商出keyC。至此，Bob有了三把钥匙keyA、keyB、keyC。 需要注意的是，当把协商密钥所需的参数，发给相应的节点时，若一方还没收到协商的参数并生成密钥，另一方就不会对协商参数进行加密。在B收到参数生成密钥keyB后，将与Bob协商密钥所需的参数发还给A，此时不会对协商参数用keyB进行加密，以保证另一方可以拿到参数生成密钥。但已经进行加密通信的双方，则会使用密钥加密通信数据。 加密传输Bob往Alice发送数据包时，先将数据Data用keyC加密，再用keyB加密，再用keyA加密，就好像层层包裹一样，然后发往节点A。节点A解开一层加密，发往节点B。节点B解开一层加密，发往节点C。节点C解开一层加密，得到Bob发往Alice的明文，发送给Alice。 参考文章： https://bbs.pediy.com/thread-248850.htm https://www.jianshu.com/p/5dba044f67b1","categories":[],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"http://cataloc.gitee.io/blog/tags/NetWork/"}]},{"title":"探究段寄存器","slug":"探究段寄存器","date":"2020-03-06T15:00:07.000Z","updated":"2020-03-08T10:35:10.662Z","comments":true,"path":"2020/03/06/探究段寄存器/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/06/%E6%8E%A2%E7%A9%B6%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"被忽视的ds1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域","text":"被忽视的dsCode1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域 这些是OllyDbg调试器显示出当前程序运行时段寄存器的各部分属性的值。接下来分析这些值的来源和含义。 段寄存器的读写在后面的部分会经常用到段寄存器的读写，这里先说明一下： 读： Code1mov ax, fs 写： Code1mov ds, ax 段寄存器在读的时候，只读了16位，但是写的时候会写入96位。 注意：ldtr和tr段寄存器不能用mov指令进行读写 段寄存器结构Code123456struct SegmentReg { WORD selector; WORD attribute; DWORD base; DWORD limit;} 由段寄存器的结构可知，段寄存器共96位，由16位的段选择子，16位的段属性，32位的base和32位的limit组成。 打印ds寄存器的值，发现只能显示0x0023，也就是段选择子那16位。不是说好的共96位吗？实际上，剩下来80位是不可见的部分，只不过OD也展示出来了，接下来证明每个属性的存在。 段基址Code1mov eax, dword ptr ds:[0] 理论上，上面这条语句是无法执行成功的，因为零地址是不允许访问的（因为没有给零地址挂物理页） 但是上述程序可以成功执行（这里不使用ds，原因是vc6作者对ds做过优化，写成ds将编译不过去），说明了这里访问的不是零地址，而是其它地址，也就是说，段寄存器修改了写入数据的地址，证明了段基址的存在。 这里真正的将数据写入eax的地址是： Code1gs.base + 0x0 以下是常见段的基址 段寄存器 Base ES 0 CS 0 SS 0 DS 0 FS 0x7FFDE000 GS - 由于将fs段的值赋给了gs段，因此写入eax寄存器的是0x7FFDE000地址上的值。 段属性 上面两段程序的差别仅仅在于插入的汇编的第一条指令，mov ax, cs 和 mov ax, ss。造成结果不同的原因是，ss段寄存器是可读、可写的，而cs段寄存器是可读、可执行，但是不可写；因此在试图向cs段寄存器所指向的基址+偏移（既[ ]内的值）是会发生访问违例的，这也说明了，不同的段寄存器，属性是不同的，证明了段属性的存在。 段限长 又出现了访问违例的情况，此处var的值为0x1000，超过了fs段寄存器的Limit：0xFFF，所以此时已经不能通过fs段来访问fs.base+0x1000这个地址了，这说明段寄存器也有一定的管辖范围，超出这个范围，就没有权限访问了 总结这次的笔记主要探究了段寄存器的属性和结构，大致整理如下 段寄存器 段选择子 属性 基址 限长 ES 0x0023 RW 0 0xFFFFFFFF CS 0x001B RX 0 0xFFFFFFFF SS 0x0023 RW 0 0xFFFFFFFF DS 0x0023 RW 0 0xFFFFFFFF FS 0x003B RW 0x7FFDE000 0xFFF GS - - - - 参考文章：https://blog.csdn.net/q1007729991/article/details/52537943 参考教程：https://www.bilibili.com/video/av68700135?p=7","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"初见保护模式","slug":"初见保护模式","date":"2020-03-05T09:19:09.000Z","updated":"2020-03-09T13:58:29.632Z","comments":true,"path":"2020/03/05/初见保护模式/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/05/%E5%88%9D%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","excerpt":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。","text":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。 保护模式的引入提供了段间的保护机制，防止程序间胡乱访问地址带来的问题，同时也扩大了访问的内存空间（没整明白8086实模式的寻址方式，看结果，保护模式的确扩大了寻址空间）。 段、页机制段，页机制均是CPU所提供的，操作系统利用CPU提供的段，页机制，实现对虚拟地址空间的管理，使得操作系统在保护模式上有序，”安全”的工作。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]}]}