{"meta":{"title":"cataLoc's Blog","subtitle":"","description":"","author":"cataLoc","url":"http://cataloc.gitee.io/blog","root":"/blog/"},"pages":[{"title":"link","date":"2020-03-07T03:28:51.000Z","updated":"2020-03-07T03:28:52.000Z","comments":true,"path":"link/index.html","permalink":"http://cataloc.gitee.io/blog/link/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-07T03:27:53.000Z","updated":"2020-03-07T03:27:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://cataloc.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"movies","date":"2020-03-07T03:28:28.000Z","updated":"2020-03-07T03:28:30.000Z","comments":true,"path":"movies/index.html","permalink":"http://cataloc.gitee.io/blog/movies/index.html","excerpt":"","text":""},{"title":"messageboard","date":"2020-03-07T03:28:09.000Z","updated":"2020-03-07T03:28:12.000Z","comments":true,"path":"messageboard/index.html","permalink":"http://cataloc.gitee.io/blog/messageboard/index.html","excerpt":"","text":""},{"title":"music","date":"2020-03-07T03:28:22.000Z","updated":"2020-03-07T03:28:24.000Z","comments":true,"path":"music/index.html","permalink":"http://cataloc.gitee.io/blog/music/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-03-07T03:28:40.000Z","updated":"2020-03-07T03:28:42.000Z","comments":true,"path":"photos/index.html","permalink":"http://cataloc.gitee.io/blog/photos/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-07T03:27:42.000Z","updated":"2020-03-07T03:27:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://cataloc.gitee.io/blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-28T06:28:51.287Z","updated":"2020-03-28T06:28:51.287Z","comments":true,"path":"link/link.json","permalink":"http://cataloc.gitee.io/blog/link/link.json","excerpt":"","text":"{\"class\":{\"class_name\":\"友情链接\",\"link_list\":{\"1\":{\"name\":\"Joney\",\"link\":\"https://www.cnblogs.com/joneyyana/p/\",\"avatar\":\"xxxx\",\"descr\":\"xxxx\"}}}}"}],"posts":[{"title":"跨进程读写内存","slug":"跨进程读写内存","date":"2020-04-05T17:15:42.000Z","updated":"2020-04-05T17:16:24.647Z","comments":true,"path":"2020/04/06/跨进程读写内存/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/06/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/","excerpt":"","text":"s","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"进程挂靠","slug":"进程挂靠","date":"2020-04-05T00:46:28.000Z","updated":"2020-04-06T09:51:41.648Z","comments":true,"path":"2020/04/05/进程挂靠/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/05/%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0/","excerpt":"","text":"在学习进程挂靠之前，先回顾一下进程与线程相关的知识 进程与线程的关系基本关系 一个进程可以包含多个线程 一个进程至少要有一个线程 进程为线程提供资源，也就是提供Cr3的值，Cr3中存储的是页目录表基址，Cr3确定了，线程能访问的内存也就确定了。 代码分析来看这样一行代码： Code1mov eax,dword ptr ds:[0x12345678] CPU如何解析0x12345678这个地址呢？ CPU解析线性地址时，需要通过页目录表（PDT）来找到对应的物理页，页目录表基址存在Cr3寄存器中，这些都是保护模式的内容，已经很熟悉了","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"线程优先级","slug":"线程优先级","date":"2020-04-04T14:04:35.000Z","updated":"2020-04-06T08:12:02.884Z","comments":true,"path":"2020/04/04/线程优先级/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/04/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"前面分析过了SwapContext函数，用来线程切换的；线程切换需要2个线程，一个是当前线程，一个是用来切换的目标线程，我们知道当前线程可以通过KPCR+0x124位置的CurrentThread获得，那么目标线程该如何获得呢？下面一块来研究一下 线程切换的方式先回顾一下线程切换三种方式的过程： 当前线程主动调用API： API函数 -> KiSwapThread -> KiSwapContext -> SwapContext 当前线程时间片到期： KiDipatchInterrupt -> KiQuantumEnd -> SwapContext KPCR中存有备用线程： KiDispatchInterrupt -> SwapContext 在有备用线程的条件下，SwapContext的目标线程参数可以通过(KPCR.PrcbData.NextThread)直接取出。那么另外两种方式，是如何找到下一个要切换的线程呢？ 先看主动调用API的方式，进入IDA分析一下KiSwapContext函数执行之前的流程 由图，我们可以看出，KiSwapThread函数内，会先执行KiFindReadyThread取出目标线程，之后再执行KiSwapContext函数的 再看时间片到期的方式，我们进入KiQuantumEnd进行分析 发现，KiQuantumEnd内部，也会先执行KiFindReadyThread函数，返回一个线程结构体 通过分析可以得知，线程切换的目标线程，与KiFindReadyThread有关，接下来就结合KiFindReadyThread函数来分析一下如何获取目标线程。 线程查找在分析查找线程之前，我们先来回顾一下之前学习的调度链表的知识 调度链表共32个，如果说一个线程，它满足运行条件了，就会被扔到这个链表里面(根据优先级)，也就是说，线程切换的时候，就是从这个调度链表里面找一个线程出来，而KiFindReadyThread函数就是干这事的。 KiFindReadyThread查找方式这个函数的查找方式非常简单暴力，会按照优先级别进行查找：31..30..29..28 换句话说，在本次查找中，如果级别31的链表里面有线程，那么就不会查找级别为30的链表，直接从级别31的链表里取一个出来 如何高效查找调度链表有32个，如果每次都从开始查找效率就太低了，因此Windows通过一个DWORD类型的变量来记录： 当向调度链表（32个）中挂入或者摘除某个线程时，会判断当前级别的链表是否为空，会判断当前级别的链表是否为空，为空则将DWORD变量（_KiReadySummary）对应位置0，否则置1。大致如下图： 多CPU下会随机寻找KiDispatcherReadyListHead指向的数组中的线程。线程可以绑定某个CPU（使用API：setThreadAffinityMask） 如果没有就绪线程怎么办这里我们先了解一下如何看调度链表 大致分三种情况： 双向链表的值一样，且等于当前地址，说明该链表是空的 双向链表的值一样，但是不等于当前地址，说明该链表只有一个线程 双向链表的值不一样，说明链表中存在2个或者2个以上个线程 那么，如果32个调度链表都是空的怎么办？ 我们来进入IDA看一下执行流程： 查看KiFindReadyThread执行后的代码 若eax值为空（即没有取到线程）那么会跳转到loc_8000EA85的位置执行 来看看loc_8000EA85处做了什么 实际上只做了一件事，就是给eax赋值，因为KiFindReadyThread函数没有找到就绪线程，因此eax值是空的，这里给eax赋的值，就是KPCR.PrcbData.IdleThread。也就是KPCR中存着的空闲线程 这下我们弄明白了，如果就绪链表中没有线程，那么发生线程切换时，会切换到一个Idle线程继续执行，从而保证CPU一直稳定的执行 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=53 参考文章： https://blog.csdn.net/qq_38474570/article/details/104286223 https://blog.csdn.net/qq_41988448/article/details/103435464 参考笔记：张嘉杰的笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"分析SwapContext","slug":"分析SwapContext","date":"2020-04-03T14:46:28.000Z","updated":"2020-04-05T17:13:26.639Z","comments":true,"path":"2020/04/03/分析SwapContext/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/03/%E5%88%86%E6%9E%90SwapContext/","excerpt":"","text":"SwapContext这个函数是Windows线程切换的核心，无论是主动切换还是系统时钟导致的线程切换，最终都会调用这个函数。在这个函数中，除了切换堆栈以外，还做了一些其它事情，了解这些细节对我们学习操作系统至关重要。 遗留问题在分析SwapContext函数之前，来回顾两个之前的文章中并没有交代的问题： 我们知道，在程序从3环进入0环时，会发生权限的切换，这就意味着堆栈发生了切换，也必然，线程发生了切换。之前学习过，3环进入0环，有两种方式，分别是中断门进0环以及快速调用。这里我们来简单的回顾一下： 通过中断门进0环时，会从TSS中获取到esp0的值。 快速调用进入0环时，则是从MSR寄存器中获取esp0的值，但是实际情况是，在分析快速调用进0环使用的KiFastCallEntry函数时，我们发现，快速调用进入0环时也是通过TSS来获取esp0的值的，所以MSR寄存器给的值，实际上只是作为中间过渡用 那么问题来了，TSS寄存器里面的这个esp0，到底是哪来的？如何保证每次切换线程后，TSS中的esp0对应的仍然是当前线程的esp0呢？分析SwapContext函数时便会找到答案。 另一个问题呢，是关于FS的；我们知道FS:[0]寄存器在3环时指向TEB，进入0环后FS:[0]指向KPCR；系统中同时存在很多个线程，那该如何保证FS:[0]在3环时一定是指向的当前正在运行的线程呢？同样，想知道这个答案，我们也需要通过分析SwapContext函数来解开。 SwapContextSwapContext函数比较长，就分为5个部分来进行分析，当然，这5个部分是连续的。另外，由于我已经在IDA中分析好了，这里就不贴上源码，直接通过图片来分析了。 Part1 来看看这部分做了些啥事，首先将目前线程(即将切换的线程)的线程状态置为2。这一部分有几个外部通过寄存器传进来的参数的含义，具体可以看图 第二步将Eflags入栈，在线程切换时，会有很多判断操作，势必会影响到标志寄存器的值，这里需要保存一下 接下来的4行，放在一起看。这里有两个操作： 1）将ExceptionList入栈，由于将发生线程切换，需要保存当前线程的异常链表。ebx指向的KPCR，所以[ebx]的值刚好是KPCR的第一个成员NtTib内的第一个成员，也就是ExceptionList 2）KPCR+0x994的位置是DPCRoutineActive，DPC是延迟过程调用，和APC相对，这里不再扩展，需要注意一点，这个会有个判断，如果DPCRoutineActive的值不为0，那就执行蓝屏程序 第四步，这个_PPerfGlobalGroupMask，仅仅在Windows Server2003中，5.2版本出现的一个字段，位于NtTib+0x08的位置，主要与日志，调式相关的。 到这就差不多了，接下来从mov ebp, cr0这条指令开始，开始第二部分的分析 Part2 来看第二部分，先让edx获取当前线程的Cr0寄存器的值。这里仅作暂存，具体后面会用到 KPCR中需要保存当前线程的相关信息，所以接下来，获取到目标线程的DebugActive写入到KPCR的DebugActive位上 这一步，比较好理解。毕竟一会要进行线程切换，总不能切换到一半去执行别的任务吧。因此就把中断屏蔽了 保存当前线程的esp到KernelStack字段中，这是我们熟知的经典线程切换操作的第一步。为什么没有紧接着进行第二步的操作呢？因为还有一些细节需要处理。接着往下看 第五步，主要做一些准备工作，这里能有两个操作，分别来看看 1）将目标线程的StackLimit保存到KPCR的StackLimit位置上 2）将目标线程的InitialStack处的值减去0x210后，赋到StackBase上。为什么要减去0x210呢？这里涉及到了内核堆栈的结构 每个线程的内核堆栈，栈底开始共有0x210个字节用于存储浮点寄存器相关的内容。因此KPCR中记录的栈基址需要减去0x210个字节 第六步，仍然是与浮点寄存器相关，在KTHREAD+0x031的位置，有一个字段叫做NpxState。这里主要是判断NpxState有没有浮点支持，以及上一个线程和当前线程对于浮点的支持是否相同，来决定是否需要重新修改Cr0寄存器的值。 下一部分，从loc_80004983开始 Part3 这部分内容较多，慢慢来看，第一步eax-0x10，结合Part2的分析可以知道，eax刚刚提升了0x210个字节，用于存储浮点寄存器相关内容，这里又提升0x10个字节的目的，同样可以根据上图可知，_Trap_Frame结构的开始部分，有0x10字节存储的内容是用于虚拟8086模式下的值，因此这里再次提升0x10字节的堆栈 第二步是最为关键的一步，这里实现了两个关键的操作： 1）将eax存的值赋值给TSS.esp0的位置，之前分析3环进0环时，有提到过，进入0环后的esp的位置，这里回顾一下： 而此时，eax所存的值，刚好位于快速调用进0环后esp所处的位置(InitialStack-0x210-0x10)。所以这个值，就是3环进0环后esp0的值，此处将这个值赋值给了TSS.esp0，自然也就解释了为什么TSS中存的esp0总是指向当前线程的0环堆栈，原因就是，每次堆栈切换发生时，SwapContext函数内，都会将切换后，线程堆栈栈顶存储到TSS.esp0的位置 2）第二个操作，哎，是我们非常熟悉的线程切换的经典步骤第二步，切换堆栈。这里就不多解释了，总之，至此，堆栈切换完成了，但是还是有一些善后工作需要处理。相比海哥的ThreadSwitch模拟切换函数来说，SwapContext还是略微复杂些的。 第三步，很容易看懂，设置KPCR.NtTib.Self指向Teb。这步有啥用呢？到Part4就能明白啦 第四步，就做了一个事，判断线程切换前后的2个线程，是不是属于同一个进程，方法也很简单，分别取两个线程KTHREAD+0x44位置指向的值（这里要注意下，在KTHREAD+0x34的偏移处，有一个ApcState结构体，其中+0x10位置存着指向当前线程所属进程的指针） 然后比较一下，若值不相同的话，那就将新的线程所属进程结构体的指针保存到edi中 第五步，紧接着第四步继续，如果俩线程的所属进程不同，就会走到这一步。这一步也有两个操作： 1）因为进程切换了，因此Cr3的值也要跟着变，因此这里从新的进程中获取Cr3，并保存到TSS中 2）同理，另一个需要更新的值，IO位图，也就是TSS最后一个元素，当然，这个值不重要，详情见图 下一部分，从loc_800049D7开始 Part4 这一部分，也就做一些收尾工作了，毕竟线程切换已经完了嘛。这里的第一步，最为关键。Part3的第三步，让KPCR.NtTib.Self指向了Teb。这里就用上了。我们有了这个Teb的地址后，就通过移位，将这个地址分3个部分(根据段描述符的结构)，写入到GDT表中，下标为7的这个段描述符中。这个段描述符对应的段选择子是0x3B，也就是3环FS寄存器存着的段选择子。这就解释了文章开头提到的第二个问题，为什么3环FS:[0]指向的一定是当前线程的Teb，原因就在这里，因为每次线程切换时，都会给3环FS:[0]对应的段描述符赋上当前线程Teb的地址 第二步，主要做了一些统计相关的操作，例如，CPU发生了多少次线程切换，以及这个线程被切换了多少次 第三步，主要做了一些恢复现场的工作，具体看图中注释。 总结至此，SwapContext函数已分析完毕，我们进一步了解了线程切换的细节，以及线程切换时，对TSS，FS的影响 参考教程： https://www.bilibili.com/video/BV1NJ411M7aE?p=51 https://www.bilibili.com/video/BV1NJ411M7aE?p=52 参考文章：https://blog.csdn.net/weixin_42052102/article/details/83217867 参考笔记：张嘉杰的笔记，Joney的笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"时间片管理与备用线程","slug":"时间片管理","date":"2020-04-02T08:11:54.000Z","updated":"2020-04-03T02:04:01.151Z","comments":true,"path":"2020/04/02/时间片管理/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/02/%E6%97%B6%E9%97%B4%E7%89%87%E7%AE%A1%E7%90%86/","excerpt":"","text":"前一篇，我们主要分析了线程切换的几种情况，其中一种是时钟中断，但并不是说只要有时钟中断就一定会切换线程，时钟中断时，两种情况会导致线程切换： 当前线程的CPU时间片到期 存在备用线程（KPCR.PrcbData.NextThread处值不为空） CPU时间片ThreadQuantum当一个新的线程开始执行时，初始化程序会在KTHREAD.Quantum赋初始值，该值的大小由KPROCESS.ThreadQuantum决定 随机选择一个进程查看，发现ThreadQuantum的值为6。这个值，就是该进程的线程执行时的CPU时间片。那如何使用这个值呢？我们接下来继续看。 分析KeUpdateRunTime每次时钟中断发生时都会先调用KeUpdateRunTime函数，我们来看看这个函数干了什么事 结合两张图来看，ebx保存的是当前线程的KTHREAD，接着将当前线程的Quantum的值-3。这下就清晰一些了，前面说了，一个线程初始的Quantum值为6，这里将Quantum的值 减了3。然后还做了什么呢，根据上面的信息，可以得知eax保存的KPCR，下面有一个逻辑判断，如果减3后值不为0，这里程序就跳转了，但是如果为0，此时程序会给KPCR+0x9AC处（QuantumEnd）的值赋上一个不为0的值，这个操作有什么用呢？往后看就知道了。 分析KiDispatchInterrupt这里小盆友可能会奇怪了，为什么突然就从KeUpdateRunTime就跳到这了呢？这里需要说明一下，KeUpdateRumTime函数，是每次时钟中断发生时都会调用的函数，这个函数做了两件事： 将当前线程的KTHREAD.Quantum的值减3 若Quantum的值减到了0，则会将KPCR.QuantumEnd的值置为一个不为0的数 之后这个函数就执行完了，接着，就是我们上一篇分析过的，时钟中断的执行流程，最终，在进行线程切换之前，会执行到KiDispatchInterrupt函数，接下来，就来看看刚刚修改过的两个值，和这个函数有何关系： 进入KiDispatchInterrupt函数，这里有一个判断，稍作分析 这里的ebx存着的是KPCR，然后程序会去判断KPCR.QuantumEnd处的值是否为0，如果不是0，说明时间片走完了，也就是KTHREAD.Quantum值被减为0了，这是就会进行跳转，图中会跳转到loc_404902的位置 跟到loc_404902的位置继续观察， 这里先将KPCR.QuantumEnd的值置零，然后跳转到KiQuantumEnd函数中继续执行（为什么先赋值，再清零呢？因为已经判断过了，已经跳转到这里了，将QuantumEnd的值置零，也是为了下一个执行的线程） 好，进入KiQuantumEnd函数 具体细节看图，这部分，主要是重新设置了当前这个线程的CPU时间片的值为ThreadQuantum。接着往下看 然后这个函数调用了KiFindReadyThread函数，在就绪队列中找到一个线程，接着就返回了 执行完KiQuantumEnd函数后，我们又回到了KiDispatchInterrupt函数 如果刚刚在KiFindReadyThread可以在就绪队列中找到一个线程，那么eax的值就不为空，如图，接下来会跳转到loc_4048BB的位置 接着看4048BB的位置 看到了我们熟悉的线程切换函数 小结通过分析KeUpdateRunTime和KiDispatchInterrupt函数，我们可以发现。在CPU时间片用完的情况下，当时钟中断发生时，会发生线程的切换，这里做个小结： 当一个新的线程开始执行时，初始化程序会在KTHREAD.Quantum赋初始值，该值的大小由KPRCOESS.ThreadQuantum决定 每次时钟中断会调用KeUpdateRunTime函数，该函数每次将当前线程Quantum减少3个单，如果减到0，则将KPCR.PrcbData.QuantumEnd的值设置为非0 KiDispatchInterrupt判断时间片到期后，调用KiQuantumEnd函数（重新设置时间片、找到要运行的线程） 备用线程这里我们直接定位到KiDispatchInterrupt的位置，看图 可以发现，这是刚刚判断时间片是否到期的位置，这里共有两个判断： 若CPU时间片到期（即KPCR.QuantumEnd的值为非0），则跳转，否则继续执行 若存在备用线程，则将备用线程取出。啥是备用线程呢？就是KPCR+0x128的位置，该处成员名称叫做NextThread，是一个KTHREAD结构。如果这个位置的值不为0，那么程序会继续执行 后面的事情，看图片也就知道了。取出备用线程后，会先将当前线程放入就绪链表。这里为什么不放入等待链表呢？因为该线程处于就绪状态，只是在时钟中断发生时CPU时间片走完了或者存在备用线程，所以不会放入等待链表中。 当然。如果两个判断都没有执行，程序会直接跳到最后，返回了，也就是不发生线程切换 总结 当前线程主动调用API： KiSwapThread -> KiSwapContext -> SwapContext 当前线程时间片到期：KiDispatchInterrupt -> KiQuantumEnd -> SwapContext 存在备用线程：KiDispatchInterrupt -> SwapContext 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=50 参考文章： https://blog.csdn.net/qq_41988448/article/details/103421772 https://blog.csdn.net/qq_38474570/article/details/104273704","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"Windows线程切换","slug":"Windows线程切换","date":"2020-04-01T15:36:56.000Z","updated":"2020-04-02T06:12:24.389Z","comments":true,"path":"2020/04/01/Windows线程切换/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/04/01/Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/","excerpt":"","text":"前一篇介绍了海哥写的一份Windows线程切换代码，通过对代码的分析和学习，我们知道了线程切换的本质就是堆栈的切换，其中有一个非常关键的函数：SwitchContext，当调用这个函数时，就会导致线程切换。同样，Windows也有一个用于线程切换的函数：KiSwapContext KiSwapContext分析我们先从这个函数开始说起，当然，相比海哥写的代码，Windows中切换线程的代码更为复杂，但本质还是一样的，这里不作详细分析，分析关键函数，找到KiSwapContext的核心实现。 首先定位到KiSwapContext 根据这几步，我们发现，外层函数传来了一个未知的参数ecx 我们跟进调用KiSwapContext的KiSwapThread 分析调用KiSwapContext的代码 可以发现，ecx的值，来源于KiFindReadyThread的返回值，顾名思义，这是一个在就绪队列中查找线程的函数，因此返回值应为一个KTHREAD 有了上面几步的分析，再回来看，就好理解了 这几步的含义是，先把当前运行的线程取出到edi中，然后将刚刚从就绪队列中取出来的线程，放到KPCR中。我们可以看到，目前esi，edi，分别存放了切换后将执行的线程和正在执行的线程，但这里没有实现，需要进一步跟进SwapContext函数。 进入SwapContext函数后，忽略细节，我们可以很快找到线程切换最精髓的两条语句 堆栈切换，回忆一下，上一篇海哥写的程序里，线程切换最关键的两条语句也是这样的原理，将esp保存到原线程的KernelStack中，并将新线程的KernelStack的值赋给esp，从而实现堆栈的切换，这也就是线程切换的本质。 主动切换函数调用过程在分析完KiSwapContext函数后，我们可以总结出这样一个调用过程： c1KiSwapThread -> KiSwapContext -> SwapContext(内部实现线程切换) 虽然，真正的切换是SwapContext函数实现的，但是经过分析，从KiSwapThread到KiSwapContext再到SwapContext是一个顺序执行的过程。所以我们可以认为，凡是调用了KiSwapThread函数，就一定会触发线程切换。 在IDA中查看KiSwapThread的交叉引用表 我们可以看到，一共有7个函数调用了KiSwapThread函数，说明执行这些函数时，都会发生线程切换 随机选取其中一个调用KiSwapThread的函数：KeWaitForSingleObject，查看KeWaitForSingleObject的交叉引用表 我们可以看到有很多函数都调用了KeWaitForSingleObject，这也意味着这些函数在执行时，都会发生线程切换，因为它们最终都会调用SwapContext函数 小结我们可以看到，Windows中绝大部分API都会直接或间接调用SwapContext这个函数，也就是说，只要调用这些API函数，就会发生线程切换，这种通过调用API函数导致的线程切换叫做主动切换。 时钟中断切换上面介绍了主动切换，需要依赖对系统API函数的调用才能触发。那么，如果不去主动调用系统API函数，该如何触发线程切换呢？这里介绍另一个导致线程切换的方式，通过时钟中断。 为何要采用时钟中断的方式呢？实际上我们在切换线程时，必须先让当前执行的线程停下来，保存了线程当前的环境后，再去切换线程。线程的暂停也意味着程序的暂停。那么，如何中断一个正在执行的程序呢？ 异常：例如缺页异常或者INT N指令 中断：例如时钟中断 系统时钟 （IDT表）中断号 IRQ 说明 0x30 IRQ0 时钟中断 在Windows操作系统中，每10~20毫秒便会触发一次时钟中断 想要获取当前版本Windows时钟间隔值，可使用Win32API：GetSystemTimeAdjustment 时钟中断的执行流程进入IDA，我们一起来分析一下时钟中断的执行流程 Alt+T 搜索_IDT，找到IDT表 之前中断门进0环学习过，int 2e执行的是KiSystemService，而时钟中断是int 30，所以我们可以很快定位它的中断例程是KiStartUnexpectedRange() 进入KiStartUnexpectedRange 发现里面跳转到了KiEndUnexpectedRange函数 继续跟进KiEndUnexpectedRange 内部跳转到函数KiUnexpectedInterruptTail 进入KiUnexpectedInterruptTail内部 在这个函数结束前，我们可以看到，它调用了一个外部函数HalEndSystemInterrupt，在导入表中可以看到，这个外部函数位于HAL.dll 用IDA打开hal.dll，找到HalEndSystemInterrupt继续分析，这个函数不大，一眼看完就可以发现，它又调用了一个外部函数KiDispatchInterrupt 我们再次进入导入表查看 巧了嘛！这个函数是ntoskrnl的，那我们又调回去了。。。 我们进入KiDispatchInterrupt康康 哦吼，我们发现了什么？这不是就是SwapContext嘛！就是线程切换函数！ 经过这么多步，终于找到了关键的函数，这里简单梳理一下流程 小结分析完时钟中断的执行流程可以发现，时钟中断最终会执行SwapContext函数，同样会发生线程切换。 异常处理还有一种导致线程切换的就是异常处理了。当程序发生异常时，会根据中断号，跳转到相应中断处理例程进行处理，也会导致线程的切换，这里不作详细分析了。具体的可以参考任务段这篇通过TSS模拟实现进程切换。本质同样是堆栈的切换。 关于进程切换本质上，进程的切换就是线程的切换，所以并不存在真正意义上进程的切换，与普通线程的切换相比，进程的切换仅仅是，两个线程不属于同一进程。因此在线程切换的过程中，Cr3换了，从而进程也就换了。 总结 如果一个线程不调用API，并且在代码中屏蔽中断（通过CLI指令），并且程序不会出现异常，那么当前线程将永久占有CPU（单核CPU占用率100%，2核CPU占用率50%） Windows并且是“抢占式”操作系统，所谓的“抢“必须是当前线程允许其它线程“抢”，否则是“抢”不到的 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=48 参考文章： https://blog.csdn.net/qq_41988448/article/details/103406636 https://blog.csdn.net/qq_38474570/article/details/104273704","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"模拟线程切换","slug":"模拟线程切换","date":"2020-03-31T13:15:33.000Z","updated":"2020-04-04T14:30:04.831Z","comments":true,"path":"2020/03/31/模拟线程切换/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/31/%E6%A8%A1%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/","excerpt":"","text":"我们知道CPU执行和调度的单位是线程，在有了线程结构体（ETHREAD）以及等待链表，调度链表的概念后，这一篇简单介绍一下线程切换，通过分析模拟线程切换的代码（源于滴水编程达人海东老师编写）来了解线程切换的过程及原理。 示例代码c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#include #include #define MAXGMTHREAD 0x100#define GMTHREADSTACKSIZE 0x80000#define GMTHREAD_CREATE 0x1#define GMTHREAD_READAY 0x2#define GMTHREAD_RUNING 0x4#define GMTHREAD_SLEEP 0x8#define GMTHREAD_EXIT 0x100#define _SELF abcd1234typedef struct //定义线程结构体{ char* name; //线程名 int Flags; //定义状态：Ready/Sleep/Running int SleepMillisecondDot; //休眠时间 void* InitialStack; //栈底 void* StackLimit; //栈限长 void* KernelStack; //栈顶 void *lpParameter; //线程函数参数 void (*func)(void *lpParameter); //线程函数}GMThread_t;int CurrentThreadIndex = 0;void* WindowsStackLimit = NULL;GMThread_t GMThreadList[MAXGMTHREAD] = {NULL, 0};void PushStack(unsigned int** Stackpp, unsigned int v);int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter); void InitGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void * lpParameter); void GMThreadStartup(GMThread_t* GMThreadp);void Scheduling(void); void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp);void GMSleep(int Milliseconds); void Thread1(void* lpParameter); void Thread2(void* lpParameter);void Thread3(void* lpParameter);void Thread4(void* lpParameter);int main(int argc, char* argv[]){ RegisterGMThread(\"Thread1\", Thread1, NULL); RegisterGMThread(\"Thread2\", Thread2, NULL); RegisterGMThread(\"Thread3\", Thread3, NULL); RegisterGMThread(\"Thread4\", Thread4, NULL); while(1) { Sleep(20); Scheduling(); } return 0;}//向栈中压入值void PushStack(unsigned int** Stackpp, unsigned int v) { *Stackpp -= 1; **Stackpp = v; return;}//将一个函数注册为单独线程执行int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter){ int i = 0; for (i=1; GMThreadList[i].name; i++) { if (0 == strcmp(GMThreadList[i].name, name)) { break; } } InitGMThread(&GMThreadList[i], name, func, lpParameter); return i;}//初始化线程的信息void InitGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void * lpParameter){ unsigned char* StackPages; unsigned int* StackDWORDParam; GMThreadp->Flags = GMTHREAD_CREATE; GMThreadp->name = name; GMThreadp->func = func; GMThreadp->lpParameter = lpParameter; StackPages = (unsigned char*)VirtualAlloc(NULL, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE); memset(StackPages, NULL, GMTHREADSTACKSIZE); GMThreadp->InitialStack = StackPages + GMTHREADSTACKSIZE; GMThreadp->StackLimit = StackPages; StackDWORDParam = (unsigned int*)GMThreadp->InitialStack; PushStack(&StackDWORDParam, (unsigned int)GMThreadp); PushStack(&StackDWORDParam, (unsigned int)9); PushStack(&StackDWORDParam, (unsigned int)GMThreadStartup); PushStack(&StackDWORDParam, 5); PushStack(&StackDWORDParam, 7); PushStack(&StackDWORDParam, 6); PushStack(&StackDWORDParam, 3); PushStack(&StackDWORDParam, 2); PushStack(&StackDWORDParam, 1); PushStack(&StackDWORDParam, 0); GMThreadp->KernelStack = StackDWORDParam; GMThreadp->Flags = GMTHREAD_READAY; return;}//启动线程的函数void GMThreadStartup(GMThread_t* GMThreadp){ GMThreadp->func(GMThreadp->lpParameter); GMThreadp->Flags = GMTHREAD_EXIT; Scheduling(); return;}//线程调度函数，这个函数使得当前线程让出CPU，从队列里重新选择一个线程执行void Scheduling(void){ int i; int TickCount; GMThread_t* SrcGMThreadp; GMThread_t* DstGMThreadp; TickCount = GetTickCount(); SrcGMThreadp = &GMThreadList[CurrentThreadIndex]; DstGMThreadp = &GMThreadList[0]; for (i=1; GMThreadList[i].name; i++) { if (GMThreadList[i].Flags & GMTHREAD_SLEEP) { if (TickCount > GMThreadList[i].SleepMillisecondDot) { GMThreadList[i].Flags = GMTHREAD_READAY; } } if (GMThreadList[i].Flags & GMTHREAD_READAY) { DstGMThreadp = &GMThreadList[i]; break; } } CurrentThreadIndex = DstGMThreadp - GMThreadList; SwitchContext(SrcGMThreadp, DstGMThreadp); }//切换线程__declspec(naked) void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp) { __asm { push ebp mov ebp, esp push edi push esi push ebx push ecx push edx push eax mov esi, SrcGMThreadp mov edi, DstGMThreadp mov [esi + GMThread_t.KernelStack], esp //经典线程切换的实现，本质就是切换堆栈 mov esp, [edi + GMThread_t.KernelStack] pop eax pop edx pop ecx pop ebx pop esi pop edi pop ebp ret }}void GMSleep(int Milliseconds){ GMThread_t* GMThreadp; GMThreadp = &GMThreadList[CurrentThreadIndex]; if (GMThreadp->Flags != 0) { GMThreadp->SleepMillisecondDot = GetTickCount() + Milliseconds; GMThreadp->Flags = GMTHREAD_SLEEP; } Scheduling(); return;}void Thread1(void* lpParameter){ while(1) { printf(\"Thread1\\n\"); GMSleep(500); }}void Thread2(void* lpParameter){ while(1) { printf(\"Thread2\\n\"); GMSleep(200); }}void Thread3(void* lpParameter){ while(1) { printf(\"Thread3\\n\"); GMSleep(10); }}void Thread4(void* lpParameter){ while(1) { printf(\"Thread4\\n\"); GMSleep(1000); }} 代码分析上述代码较长，且每行长短不一，故注释较乱，这里进行一些简要分析 模拟线程结构体c12345678910111213typedef struct //定义线程结构体{ char* name; int Flags; //定义状态：Ready/Sleep/Running int SleepMillisecondDot; //线程等待时间 void* InitialStack; //栈底 void* StackLimit; //栈限长 void* KernelStack; //栈顶 void *lpParameter; //线程函数参数 void (*func)(void *lpParameter); //线程函数}GMThread_t; 这是这份代码里最重要的结构体，它定义了我们模拟线程的结构，实际上，就是一个乞丐版的ETHREAD，只是很多ETHREAD中的成员我们用不到，就省去了，但仍然可以模拟线程切换的过程，这也算是个五脏俱全的线程结构体，我们来看看都有哪些成员吧： name：很好理解，线程的名字，用于标记线程 Flags：线程的状态，我们可以根据线程的状态将它放入等待链表或者让它执行 SleepMillisecondDot：线程的休眠时间。 InitialStack/StackLimit/KernelStack：可以说这是线程切换最重要的3个成员，每个线程执行时都需要有自己的堆栈，而具体该如何分配堆栈就要依靠这3个值，InitialStack提供了线程的栈底(ebp)；KernelStack提供了栈顶(esp)；StackLimit决定了栈的边界，可以这样理解，该线程的堆栈只能位于[ebp, ebp+StakLimit]的范围内，一旦超出这个范围，就会发生错误 lpParameter/func：分别是线程函数参数和线程函数，可以执行特定函数显示具体线程 全局变量和宏c1234567891011#define MAXGMTHREAD 0x100#define GMTHREADSTACKSIZE 0x80000#define GMTHREAD_CREATE 0x1#define GMTHREAD_READAY 0x2#define GMTHREAD_RUNING 0x4#define GMTHREAD_SLEEP 0x8#define GMTHREAD_EXIT 0x100int CurrentThreadIndex = 0;GMThread_t GMThreadList[MAXGMTHREAD] = {NULL, 0}; MAXGMTHREAD：指明线程最多能有多少个 GMTHREADSTACKSIZE：这里说的是线程分配的堆栈能有多大，每个线程都拥有自己的堆栈，但是不能无限大，大小的限制由KTHREAD结构里的KernelStack决定 GMTHREAD_CREATE/READAY/RUNING/SLEEP/EXIT：均为线程的状态 CurrentThreadIndex：可以理解为Index，用于遍历，这里作为全局变量进行声明。 GMThreadList：这里的类型是GMThread_t，说明这是模拟线程结构体链表，在KTHREAD结构体中，使用了WaitListEntry和SwapListEntry，根据线程的状态，将线程放入不同的链表中。这里，海东老师只用了一个数组，用来存放线程，其中下标0的位置，存放主函数的线程，其余位置存放不同状态的线程。 主函数c1234567891011121314int main(int argc, char* argv[]){ RegisterGMThread(\"Thread1\", Thread1, NULL); //注册线程1， 2， 3，4 RegisterGMThread(\"Thread2\", Thread2, NULL); RegisterGMThread(\"Thread3\", Thread3, NULL); RegisterGMThread(\"Thread4\", Thread4, NULL); while(1) { Sleep(20); //短暂等待 Scheduling(); //线程调度 } return 0 程序是从主函数开始执行的，我们按照函数执行的顺序进行分析 RegisterGMThread()：将一个函数注册为单独的线程来执行 Scheduling()：调度函数，使得当前线程让出CPU，并从队列中（GMThreadList）重新选择一个线程执行 线程注册函数c123456789101112131415int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter){ int i = 0; for (i=1; GMThreadList[i].name; i++) { if (0 == strcmp(GMThreadList[i].name, name)) { break; } } InitGMThread(&GMThreadList[i], name, func, lpParameter); return i；} 参数：线程名，线程函数，线程函数参数 前面提到了，下标0的位置，存放着是main线程，所以这里从下标1开始写入，对数组中未初始化的线程通过初始化函数InitiGMThread()进行初始化 压栈函数c1234567void PushStack(unsigned int** Stackpp, unsigned int v) { *Stackpp -= 1; //栈减一个int长度，就是4字节 **Stackpp = v; //并在这个位置存值 return;} 在介绍线程初始化函数前，先看一下这个压栈函数，这个函数非常简单，传了2个参数，一个指针，一个数。压栈函数的作用就是，指针-1（因为是*Stackpp，所以减的是int类型，即4字节），并在压栈后的地址存这个数，文字叙述可能不好理解，我们把这个转换一下就好理解了，其实就是代码实现的一个简单压栈操作 Code1234567891011_asm { sub esp, 4 mov eax, v mov esp, eax}or _asm { push v} 线程初始化函数c123456789101112131415161718192021222324252627282930313233343536373839void InitGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void * lpParameter){ unsigned char* StackPages; unsigned int* StackDWORDParam; //初始化线程结构体 GMThreadp->Flags = GMTHREAD_CREATE; GMThreadp->name = name; GMThreadp->func = func; GMThreadp->lpParameter = lpParameter; //分配80个连在一起的可以直接用的物理页 StackPages = (unsigned char*)VirtualAlloc(NULL, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE); //将分配的内存先都清0 memset(StackPages, NULL, GMTHREADSTACKSIZE); //设置栈底ebp GMThreadp->InitialStack = StackPages + GMTHREADSTACKSIZE; //设置栈的最大上限 GMThreadp->StackLimit = StackPages; //将ebp赋值StackDWORDParam StackDWORDParam = (unsigned int*)GMThreadp->InitialStack; PushStack(&StackDWORDParam, (unsigned int)GMThreadp); PushStack(&StackDWORDParam, (unsigned int)9); PushStack(&StackDWORDParam, (unsigned int)GMThreadStartup); PushStack(&StackDWORDParam, 5); //ebp PushStack(&StackDWORDParam, 7); //edi PushStack(&StackDWORDParam, 6); //esi PushStack(&StackDWORDParam, 3); //ebx PushStack(&StackDWORDParam, 2); //ecx PushStack(&StackDWORDParam, 1); //edx PushStack(&StackDWORDParam, 0); //eax //令KernelStack指向栈顶esp GMThreadp->KernelStack = StackDWORDParam; //修改线程状态Create->Ready GMThreadp->Flags = GMTHREAD_READAY; return;} 线程初始化：线程初始化总共分为2步，一个是对线程结构体的初始化，另一个是对线程所在堆栈的初始化 线程结构体初始化：对代码中定义的简约版线程结构体GMThread_t中的部分成员进行初始化，包括线程状态，线程名，线程函数及参数。 线程堆栈初始化：我们知道，每一个线程，都得有属于自己堆栈，总不能跑到别人的堆栈上执行吧，这样就乱套了因此线程得拥有自己的堆栈。来看一下模拟线程切换的代码中是如何实现的： 第一步用VirutalAlloc函数申请一块连续的内存（分配类型使用MEM_COMMIT） 初始化这块内存（置零） 设置栈底，栈顶，边界，这部分非常关键，也是设置线程堆栈的核心步骤。在KTHREAD结构中，有InitialStack/StackLimit/KernelStack决定线程的堆栈相关参数。本次的模拟程序里也定义了这三个成员，我们来看下他们是如何运作的。 InitialStack：这个成员相当于栈底，也就是ebp，在Windows中，堆栈的由高地址向低地址延申的，所以这里设置ebp的值为申请内存的首地址+堆栈限制大小 StackLimit：这个成员定义栈的边界，栈的范围应在[InitialStack, StackLimit]内，这里令其等于申请内存的首地址，因为栈由高地址向下延申，因此栈的边界会位于此处 KernelStack：这个成员指向栈顶，相当于esp。这里的几步非常关键，按照顺序依次push了线程结构体，一个数，一个执行线程的函数GMThreadStartup()，接着又是一堆数，最后，将栈顶（通过压栈函数减了很多次），赋值给了KernelStack 以上就是线程初始化最关键的部分，可以参考这张图 线程调度函数回到主函数，线程注册函数执行完后（线程初始化函数中的线程调用函数并未执行，只是被压栈了，所以稍后分析），就到了线程调度函数，一起来看一下线程调度函数都做了些什么吧 c12345678910111213141516171819202122232425262728293031323334353637void Scheduling(void){ int i; int TickCount; GMThread_t* SrcGMThreadp; GMThread_t* DstGMThreadp; TickCount = GetTickCount(); //指向正在执行的线程 SrcGMThreadp = &GMThreadList[CurrentThreadIndex]; //指向准备执行的线程 DstGMThreadp = &GMThreadList[0]; //遍历线程数组，找到第一个状态为就绪的线程 for (i=1; GMThreadList[i].name; i++) { if (GMThreadList[i].Flags & GMTHREAD_SLEEP) { if (TickCount > GMThreadList[i].SleepMillisecondDot) { GMThreadList[i].Flags = GMTHREAD_READAY; } } if (GMThreadList[i].Flags & GMTHREAD_READAY) { DstGMThreadp = &GMThreadList[i]; break; } } //得到即将执行的线程下标 CurrentThreadIndex = DstGMThreadp - GMThreadList; //线程切换 SwitchContext(SrcGMThreadp, DstGMThreadp); } 线程调度函数不是很复杂，比较好理解，这里简要概括下： 开头部分定义了两个线程结构体指针：SrcGMThreadp，DstGMThreadp SrcGMThreadp指向正在运行的线程，DstGMThreadp遍历线程数组，找到第一个状态为就绪的线程并指向它 保存DstGMThreadp指向的线程在数组中的下标（下次调度时好知道，正在运行的线程位于什么位置） 通过SwitchContext将这两个线程进行切换 线程切换函数c1234567891011121314151617181920212223242526272829303132__declspec(naked) void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp { __asm { push ebp mov ebp, esp push edi push esi push ebx push ecx push edx push eax mov esi, SrcGMThreadp mov edi, DstGMThreadp mov [esi + GMThread_t.KernelStack], esp //经典线程切换!!!本质是堆栈的切换！ mov esp, [edi + GMThread_t.KernelStack] pop eax pop edx pop ecx pop ebx pop esi pop edi pop ebp ret }} 这是本篇最高能的地方了，我们来详细分析一下，这个看上去简单的代码是如何实现线程切换的。我们来一步步的看： 最开始，一堆push，非常好理解，就是保存寄存器的值嘛！ 接下来，两个mov操作，将指向正在运行的线程结构体的指针赋给了esi，将指向准备运行的线程结构体的指针赋给了edi 然后，线程切换最经典的操作来了！将当前esp，赋值给esi指向线程的KernelStack；同时，将edi指向线程的KernelStack赋给esp。我们知道KernelStack存的是线程自己堆栈的esp，程序中的esp，是当前CPU执行的时的堆栈，而这个操作就是把当前堆栈保存到即将被切换的线程的KernleStack中，同时，让CPU执行所在的堆栈变成切换后的线程的KernelStack，说简单点，这个操作就是一次堆栈的切换！ 还没完！后面还有一堆pop，你以为就没用了嘛？仔细想想，堆栈已经发生了切换了！所以即将pop的那些值已经不是上面push进去的值了！那pop出来的值又是什么值呢？ 没错，就是在线程初始化函数中Push进去的那些值，一直到pop ebp都比较好理解 接下来，一个ret，又是一个精髓指令，通过这个ret指令，刚好调用一个用来执行线程的函数GMThreadStartup()，这个函数会让线程调用自己的线程函数。这里有一个细节，就是这个函数传递了一个线程结构体指针，但是在裸函数中，ret语句执行完就跳转到GMThreadStartup()函数的开始处执行，那么它又是如何获取参数的呢？我们来查看一下反汇编 根据这个函数的反汇编可以发现，它是通过[ebp+8]来获取参数的，而这个位置，刚好就是在初始化函数中，第一个push进去的线程结构体，紧接着push了一个9，仅仅是用来占位，从而使得[ebp+8]刚好可以指向线程结构体，从而获取参数，u1s1，这里细节妙不可言 这里贴一张群友张嘉杰做的笔记，做的非常好，结合着看更易看懂代码 执行线程函数c123456789void GMThreadStartup(GMThread_t* GMThreadp){ GMThreadp->func(GMThreadp->lpParameter); GMThreadp->Flags = GMTHREAD_EXIT; //线程切换 Scheduling(); return;} 这个函数，在上面刚讲过，主要就是最后，会再执行一次线程调度函数，实现下一次的线程切换，说明了一点，线程是主动切换的，主动让出CPU 程序运行结果最后，来看一下程序运行时的样子，就是在不断的线程切换 总结至此，程序主要部分就基本分析完毕，真的是非常巧妙的代码，海东老师太厉害了！这里对模拟线程切换做一个总结： 线程不是被动切换的，而是主动让出CPU 线程切换并没有使用TSS来保持寄存器，而是使用堆栈。 线程切换的过程就是切换堆栈的过程 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=47 参考文章： https://blog.csdn.net/qq_38474570/article/details/104245111 https://blog.csdn.net/qq_41988448/article/details/103098367 参考笔记：张嘉杰，Joney，米高扬设计局，馍馍","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"等待链表&调度链表","slug":"等待链表-调度链表","date":"2020-03-30T15:38:42.000Z","updated":"2020-03-30T16:28:53.447Z","comments":true,"path":"2020/03/30/等待链表-调度链表/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/30/%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8-%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"在前面介绍进程结构体时，进行了断链实验，程序可以正常运行，原因是CPU执行与调度的单位是线程，因此进程的断链并不影响程序的正常执行。对线程的断链也是一样的，断链后虽然可以隐藏断掉的线程，但同样不影响程序的执行。这说明，CPU调度时根本没有用到ThreadListEntry这个链表。接下来介绍两个与调度相关的链表：等待链表&调度链表 33个链表 线程有3种状态：就绪、等待、运行 正在运行中的线程存储在KPCR中，就绪和等待的线程全在另外的33个链表中。包括1个等待链表，32个就绪链表 这些链表都使用了_KTHREAD+0x060这个位置（如果是Win7的话，位于KTHREAD+0x074的位置），也就是说，线程在某一时刻，只能属于其中一个链表内 等待链表 查询指令：dd KiWaitListHead 说明： 等待链表是一个双向链表 当线程调用了Sleep()或者WaitForSingleObject()等函数时，就挂到这个链表 结构图： 关系梳理：KiWaitListHead -> WaitListEntry(KTHREAD+0x60) -> ThreadProcess(ETHREAD+0x220) -> EPROCESS 调度链表 查询指令：dd KiDispatcherReadyListHead L70 说明： 调度链表共32个双向链表 有32个调度链表的原因是，运行中的线程是有线程优先级，根据下标表示线程优先级别（0~31） 32位系统中，调度链表有32个（一组），64位系统则有64个（一组） 普通操作系统，只有一组调度链表，服务器版本系统中，调度链表的数量等于CPU的数量，但等待链表只有一个 结构图： 总结 正在运行的线程位于KPCR中 准备运行的线程根据线程优先级的不同，分布在32个调度链表中； KiDispatcherReadyListHead是个数组，存储了32个链表头 等待状态的线程存储在等待链表里，KiWaitListHead存储了链表头 这些圈均挂在KTHREAD+0x060的位置（XP系统）","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"KPCR","slug":"KPCR","date":"2020-03-30T01:06:50.000Z","updated":"2020-03-30T15:22:42.805Z","comments":true,"path":"2020/03/30/KPCR/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/30/KPCR/","excerpt":"","text":"进程在内核中对应结构体：EPROCESS 线程在内核中对应结构体：ETHREAD CPU在内核中也有一个对应的结构体：KPCR（Processor Control Region） KPCR结构我们已经很熟悉了，在API函数的调用过程中，多次使用到了KPCR，也简要介绍过一点。在保存现场之前有一个步骤就是将fs寄存器写入0x30，并根据GDT表，让fs寄存器指向KPCR。 KPCR介绍 当线程进入0环时，FS:[0]指向KPCR（3环时FS:[0] -> TEB） 每个CPU都有一个KPCR结构体（一个核一个） KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息。 在Windbg中执行指令：dt _KPCR 查看KPCR结构 结构图： KPCR成员+0x000 NtTib 成员名：NtTib 数据类型：_NT_TIB 说明：KPCR的第一个成员，存储部分关键信息（TEB的第一个成员也是这个结构） 结构图： +0x000 ExceptionList 成员名：ExceptionList 数据类型：Ptr32 _EXCEPTION_REGISTRATION_RECORD 说明：指向当前线程的异常链表（SEH），包含了当前线程的异常处理函数。Ring0（KPRC的ExceptionList）和Ring3（TEB的ExceptionList）的异常处理函数不同 +0x004 StackBase/+0x008 StackLimit 成员名：StackBase/StackLimit 数据类型：Ptr32 Void 说明：当前线程内核栈的基址和大小（KPCR中的是Ring0相关，TEB中就是Ring3相关） +0x018 Self 成员名：Self 数据类型：Ptr32 _NT_TIB 说明：指向自己（也就是指向_NT_TIB结构）这样设计的目的是为了查找方便。Ring0->KPCR，Ring3->TEB +0x01c SelfPcr 成员名：SelfPcr 数据类型：Ptr32 _KPCR 说明：指向自己，方便寻址 +0x020 Prcb 成员名：Prcb 数据类型：Ptr32 _KPRCB 说明：指向扩展结构体KPRCB +0x038 IDT 成员名：IDT 数据类型：Ptr32 _KIDTENTRY 说明：指向IDT表首地址 +0x03c GDT 成员名：GDT 数据类型：Ptr32 _KGDTENTRY 说明：指向GDT表首地址 +0x040 TSS 成员名：TSS 数据类型：Ptr32 _KTSS 说明：指向TSS，每个CPU都有一个TSS +0x051 Number 成员名：Number 数据类型：UChar 说明：CPU编号 +0x120 PrcbData 成员名：PrcbData 数据类型：_KPRCB 说明：KPCR的扩展结构体 结构图： KPRCB结构体KPRCB（Kernel Processor Control Block）是KPCR的扩展结构体 +0x004 CurrentThread成员名：CurrentThread 数据类型：Ptr32 _KTHREAD 说明：指向当前线程的KTHREAD +0x008 NextThread成员名：CurrentThread 数据类型：Ptr32 _KTHREAD 说明：指向下一个要执行线程的KTHREAD +0x00c IdleThread成员名：IdleThread 数据类型：Ptr32 _KTHREAD 说明：指向空闲线程的KTHREAD +0x88c QuantumEnd成员名：QuantumEnd 数据类型：Uint4B 说明：CPU时间片标志 关系梳理在简单了解完进程结构体（EPROCESS）、线程结构体（ETHREAD）、CPU结构体（KPCR）以后，来梳理一下它们之间的关系。 已知进程遍历进程：PsActiveProcessHead -> ActiveProcessLinks(EPROCESS+0x88)…… 遍历线程：PsActiveProcessHead -> ActiveProcessLinks(EPROCESS+0x88) -> ThreadListHead(KPROCESS+0x50 / EPROCESS+0x190) -> ThreadListEntry(KTHREAD+0x1b0 / ETHREAD+0x22c)…… 已知线程遍历进程：ETHREAD+0x220 -> EPROCESS -> ActiveProcessLinks(EPROCESS+0x88)…… 遍历线程：ETHREAD+0x22c / ETHREAD+0x1b0 -> ThreadListEntry…… 已知KPCR遍历进程：进入0环后 -> fs:[0] -> KPCR -> PrcbData(KPCR+0x120) -> CurrentThread(KPRCB+0x4) -> EPROCESS(ETHREAD+0x220) -> ActiveProcessLinks(EPROCESS+0x88)…… 遍历线程：进入0环后 -> fs:[0] -> KPCR -> PrcbData(KPCR+0x120) -> CurrentThread(KPRCB+0x4) -> ETHREAD+0x22c / ETHREAD+0x1b0 -> ThreadListEntry…… 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=45 参考文档：张嘉杰笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"线程结构体","slug":"线程结构体","date":"2020-03-29T09:01:47.000Z","updated":"2020-03-30T15:22:17.474Z","comments":true,"path":"2020/03/29/线程结构体/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/29/%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"Windows中每个进程会包含一个或多个线程，每个线程在0环都有一个对应的结构体：ETHREAD，这个结构体包含了线程所有重要的信息，下面来简单了解一下。 ETHREADWindbg中，执行dt _ETHREAD可以看到这个完成的结构： +0x000 Tcb 成员名：Tcb 数据类型：_KTHREAD Windbg查询指令：dt _KTHREAD 结构图： 说明：KTHREAD这个结构应该已经比较眼熟了，在API函数的调用过程（保存现场），就多次用到了KTHREAD结构里的成员。 +0x000 Header 成员名：Header 数据类型：_DISPATCHER_HEADER 说明：结构体内若包含_DISPATCHER_HEADER这个数据类型，说明这是一个可等待对象 可等待对象：Mutex，Event都是可等待对象，可被作用于WaitForSingleObject这类函数 +0x018 InitialStack/+0x01c StackLimit/+0x028 KernelStack 成员名：InitialStack/StackLimit/KernelStack 数据类型：Ptr32 Void 说明：这三个成员与线程切换有关。有印象的话，在分析KiFastCallEntry函数保存现场的过程中，曾有一行代码获取了InitialStack的值，并存到了ebp中。 此外，线程切换发生时，会根据KernelStack修改TSS的ESP0。更多关于这三个成员的用法，会在后面线程切换的地方再提到 +0x020 Teb 成员名：Teb（Thread Environment Block），线程环境块 数据类型：Ptr32 Void 大小：4KB 结构图： 说明： 0x20位置存着一个指向Teb结构的指针 Teb是在3环用来描述线程的一个结构。 0环时，FS:[0]指向KPCR；3环时，FS:[0]指向TEB +0x02c DebugActive 成员名：DebugActive 数据类型：UChar 说明：在分析KiSystemService进行保存现场的过中遇到过，若这个位置的值不是-1，说明处于调试状态，程序会跳转到执行一个将Dr0~Dr7保存到_Trap_Frame里面的操作。从而衍生出了一个反调试手段，将这个位置的值置为-1，从而不能使用8个调试寄存器 +0x02d State 成员名：State 数据类型：UChar 说明：线程状态-就绪/等待/运行 +0x060 WaitListEntry/SwapListEntry 成员名：WaitListEntry/SwapListEntry 数据类型：WaitListEntry为_LIST_ENTRY / SwapListEntry为 _SINGLE_LIST_ENTRY 说明：此处为Wait链表或Ready链表。Windows线程总是处于Wait/Running/Ready这三种状态之一 +0x06c BasePrioirty 成员名：BasePriority 数据类型：Char 说明：其初始值是所属进程的BasePrioirty值（KPROCESS->BasePriority），以后可以通过KeSetBasePriorityThread()函数重新设定 +0x070 WaitBlock 成员名：WaitBlock 数据类型：[4]_KWAIT_BLOCK 说明：当前线程，正在等待哪个可等待对象（WaitForSingleObject）这个可等待对象的信息就会被写入这个_KWAIT_BLOCK结构的数组里。 +0x0E0 ServiceTable 成员名：ServiceTable 数据类型：Ptr32 Void 说明：这个应该很熟悉了，指向系统服务表基址；通过系统服务表，可以找到函数地址表，根据系统服务号提供的偏移，就可以在函数地址表中找到3环API接口对应的0环内核函数 +0x134 TrapFrame 成员名：TrapFrame 数据类型：Ptr32 _KTRAP_FRAME 说明：这个也很熟悉了，进0环时，保存现场的原理就是填充寄存器及相关数据到TrapFrame结构中，最后更新TrapFrame位置的值，使其指向新保存的TrapFrame +0x140 PerviousMode 成员名：PerviousMode 数据类型：Char 说明：在调用0环函数，保存现场的过程时，会将先前模式保存到TrapFrame结构中，以便根据先前模式，能够正确的返回到调用它的函数。 +0x1b0 ThreadListEntry 成员名：ThreadListEntry 数据类型：_LIST_ENTRY 说明： 双向链表，一个进程所有的线程，都挂在一个链表中，挂的就是这个位置 链表头位于KPROCESS+0x50的位置以及EPROCESS+0x194的位置，相当于ThreadListEntry的PsThreadListHead 一共有两个这样的链表 APC相关（位于KTHREAD内） 成员位置 成员名 数据类型 0x034 ApcState _KAPC_STATE +0x0e8 ApcQueueLock Uint4B +0x138 ApcStatePointer [2] Ptr32 _KAPC_STATE +0x14c SavedApcState _KAPC_STATE 说明：这些均为与APC相关的结构，具体到APC章节再做分析，这里仅作了解 +0x1ec Cid 成员名：Cid 数据类型：_CLIENT_ID 说明：共八字节，包含两个值，当前进程的PID和当前线程的CID 结构图： +0x220 ThreadProcess 成员名：ThreadProcess 数据类型：Ptr32 _EPROCESS 说明：指向自己所属进程 +0x22c ThreadListEntry 成员名：ThreadListEntry 数据类型：_LIST_ENTRY 说明： 双向链表，一个进程所有的线程，都挂在一个链表中，挂的就是这个位置 链表头位于KPROCESS+0x50的位置以及EPROCESS+0x194的位置，相当于ThreadListEntry的PsThreadListHead 一共有两个这样的链表 这个双向链表的内容和0x1b0位置的完全一样，构建2个双向链表主要是为了方便，一个位于KPROCESS内，一个位于EPROCESS内 结构图： 关于断链在进程结构体中，我们通过断链实现了简单的进程隐藏，其原理在于，任务管理器在查询进程便是通过遍历ActiveProcessLink实现的。尽管进程已经不在活动进程链表上，但是仍然可以运行，原因是Windows调度的基本单位是线程，而不是进程，所以才有从进程链表上摘除自身进程的隐藏方法，这虽然从进程链表上摘除了自身，但不会影响操作系统的调度，所以不影响程序运行。 不过这里没能完成线程断链的实验，原因可能在于VMware虚拟机的指令问题，Windbg无法中断操作系统时间过长，所以经常实验到一半，就无法继续执行指令了，只能重启虚拟机，后续到驱动章节会此实验作为练习补上。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=44 参考文章：https://blog.csdn.net/emaste_r/article/details/8916786 参考笔记：张嘉杰的笔记","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"进程结构体","slug":"进程结构体","date":"2020-03-28T15:50:13.000Z","updated":"2020-03-30T01:46:19.225Z","comments":true,"path":"2020/03/28/进程结构体/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/28/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"进程，站在内核的角度来说，它就是个结构体。当操作系统想要创建一个进程时，本质上就是分配一块内存，填充一个结构体，今天就来了解一下这个进程结构体EPROCESS。 EPROCESS每个Windows进程在0环都有一个对应的结构体：EPROCESS，这个结构体包含了进程所有重要的信息。 在Windbg中，执行指令dt _EPROCESS 我们就可以看到这个完整的结构。 这个结构非常的庞大，本篇先混个眼熟，介绍一些比较关键的字段，其余在后续文章中用到时再详细介绍。 +0x000 Pcb 成员名：Pcb 数据类型：_KPROCESS 说明：在EPROCESS开始的位置，有一个Pcb，它是一个KPROCESS结构，同样包含了描述进程的信息，先来看一下这个结构比较关键的一些字段。 结构图： +0x000 Header 成员名：Header 数据类型：_DISPATCHER_HEADER 说明：结构体内若包含_DISPATCHER_HEADER这个数据类型，说明这是一个可等待对象 可等待对象：Mutex，Event都是可等待对象，可被作用于WaitForSingleObject这类函数 +0x018 DirectoryTableBase 成员名：页目录表基址 数据类型：[2] Uint4B 说明：进程结构体中最重要的成员，控制整个进程的物理页，进程切换时会将值填入Cr3 +0x038 KernelTime/+0x03c UserTime 成员名：KernelTime/UserTime 数据类型：Uint4B 说明：统计信息，记录了一个进程在内核模式/用户模式下所花的时间 +0x050 ThreadListHead 成员名：ThreadListHead 数据类型：_LIST_ENTRY 说明：指向当前进程的，线程链表 +0x05c Affinity 成员名：Affinity 数据类型：Uint4B 说明：规定进程里面的所有线程能在哪个CPU上跑 如果值为1，那这个进程的所有线程只能在0号CPU上跑（00000001） 如果值为3，那这个进程的所有线程能在0、1号CPU上跑（000000011） 如果值为4，那这个进程的所有线程能在2号CPU上跑（000000100） 如果值为5，那这个进程的所有线程能在0，2号CPU上跑（000000101） 4个字节共32位，所以最多只能32核，Windows64位，就64核；如果只有一个CPU，把这个值设置为4，那么这个进程就死了。 +0x062 BasePriority 成员名：BasePriority 数据类型：Char 说明：表示基础优先级/最低优先级，该进程中的所有线程一创建出来时最初的优先级 到这里KPROCESS内部的主要成员就介绍完了，现在又要回到EPROCESS这个结构中了 +0x063 ThreadQuantum 成员名：ThreadQuantum 数据类型：Char 说明：线程时间片的初始值 +0x070 CreateTime/+0x078 ExitTime 成员名：CreateTime/ExitTime 数据类型：_LARGE_INTEGER 说明：进程的创建/退出时间 +0x084 UniqueProcessId 成员名：UniqueProcessId 数据类型：Ptr32 Void 说明：进程的编号，任务管理器中显示的PID就是这个值 +0x088 ActiveProcessLinks 成员名：ActiveProcessLinks 数据类型：_List_Entry 说明：双向链表，所有的活动进程都连接在一起，构成了一个链表 PsActiveProcessHead指向全局链表头 第一个成员指向后一个进程结构体0x88偏移的位置，第二个成员指向前一个结构体0x88偏移的位置 通过断链，可以实现简单的进程隐藏 结构图： 查询示范： +0x090 QuotaUsage/+0x09c QuotaPeak 成员名：QuotaUsage/QuotaPeak 数据类型：[3] Uint4B 说明：物理页相关的统计信息（到内存部分会详细分析） +0x0a8 CommitCharge/+0x0ac PeakVirtualSize/+0x0b0 VirtualSize 成员名：CommitCharge/PeakVirtualSize/VirtualSize 数据类型：Uint4B 说明：虚拟内存相关的统计信息（到内存部分会详细分析） +0x11c VadRoot 成员名：VadRoot 数据类型：Ptr32 Void 说明：指向一个平衡二叉树，标识了0~2G哪些内存被分配了，哪些没被分配；该成员和内存遍历，模块隐藏有关 +0x0bc DebugPort /+0x0c0 ExceptionPort 成员名：DebugPort/ExceptionPort 数据类型：Ptr32 Void 说明：调试相关，通过清零DebugPort，是一种简单的反调试手段，具体关于调试的内容，到调试相关章节会详细分析 +0x0c4 ObjectTable 成员名：ObjectTable 数据类型：Ptr32 _HANDLE_TABLE 说明：句柄表，存储在0环，记录了当前进程所使用的别的进程的句柄地址，可以通过遍历所有进程的句柄表来查看当前程序是否被调试。在句柄表的章节，会详细讲解这个成员的内容 +0x174 ImageFileName 成员名：ImageFileName 数据类型：[16]UChar 说明：进程镜像文件名，最多16个字节。如上面查询活动进程链表的实验中，可以看到进程名为”System” 0x1a0 ActiveThreads 成员名：ActiveThreads 数据类型：Uint4B 说明：活动线程的数量 0x1b0 Peb 成员名：Peb 数据类型：Ptr32_PEB 说明：PEB（Process Enviroment Block 进程环境快）：位于3环的一个描述进程的结构，里面包含了进程的模块列表、是否处于调试状态，等信息 结构图： 下面简单介绍其中2个成员： 0x2 BeingDebugged 成员名：BeingDebugged 数据类型：Uchar 说明：当进程属于被调试的时候，这个位置的值会被置1。调试器可以通过不断清零这个值，做到简单的反反调试 0xc Ldr 成员名：Ldr 数据类型：_PEB_LDR_DATA 该结构内有3个双向链表成员，存储了当前进程所有的模块（只是顺序不同），通过断链可以实现简单的模块隐藏 结构图： 进程隐藏在前面介绍了EPROCESS里有一个双向链表ActiveProcessLinks，我们可以通过断链，实现简单的进程隐藏。 打开OD，然后打开任务管理器，可以看到，OD这个进程 然后找到活动进程链表头 从后往前遍历（刚打开的进程，位于链表靠后的位置），找到OD这个进程对应的EPROCESS 修改OD前后进程结构体的活动进程链表，将OD断链 再次打开任务管理器，发现没有OD这个进程了，但是程序仍能正常执行 说明任务管理器是通过遍历活动进程链表来查询所有进程的 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=43 参考文章： https://blog.csdn.net/qq_41988448/article/details/103005060 https://blog.csdn.net/qq_38474570/article/details/103722984","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（系统服务表）","slug":"API函数的调用过程（系统服务表）","date":"2020-03-27T15:49:50.000Z","updated":"2020-03-29T13:08:03.028Z","comments":true,"path":"2020/03/27/API函数的调用过程（系统服务表）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/","excerpt":"","text":"前面的学习过程中，我们了解到程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做_Trap_Frame的结构体中。在3环部分，程序将一个编号存到了eax中，这个编号叫做系统服务号，此外，在保存现场的过程中，程序还让edx指向了3环第一个参数的地址。回忆起这两步，接下来，就可以继续探究执行内核函数的过程了。 系统服务表在分析代码前，我们先来学习一个结构，系统服务表（System Service Table） 在Windows XP系统下，系统服务表有两张，这两张表存着内核文件的导出函数（不包括内核文件的所有函数，主要是3环函数常用的内核函数）。第一张表导出的内核函数主要来源于ntoskrl.exe，实现大部分3环函数基本功能；第二张表导出的内核函数主要来源于win32k.sys，主要实现图形界面相关功能（例如GDI32.dll的底层实现）。 系统服务表结构根据示例图，我们先简单认识一下系统服务表，先从结构看起： ServiceTable：指向一个函数地址表，通过系统服务号可以在函数地址表中找到指定的内核函数。 Count：指当前系统服务表被调用的次数。 ServiceLimit：函数地址表的大小，即系统服务函数的个数 ArgmentTable：系统服务函数参数的大小，以字节为单位，每个成员大小为1个字节。 系统服务表位置这个系统服务表位于KTHREAD结构的0xE0偏移处。这样，在进入0环后我们可以通过fs:[0]找到KPCR结构，然后在KPCR->0x124找到当前线程的KTHREAD结构，再根据KTHREAD->0xE0就可以找到当前线程所拥有的系统服务表。 Code1fs:[0] -> KPCR -> KPCR+0x124 -> KTHREAD -> KTHREAD+0xE0 -> 系统服务表 系统服务号系统服务号用来定位所要寻找的系统服务表的函数。 系统服务号只有低13位是有用的 下标12：判断去查服务表，0去查第一张表；1去查第二张表 下标0~11：函数地址表的索引 SharedCode分析在前面保存现场的代码分析中，由于进入0环的方式不同，中断进0环（int 2E）和快速调用（sysenter）保存现场的方式也不一样，但是当这两种方式，将寄存器保存到_Trap_Frame结构中以后（保存现场），便会从同一个地放（KiFastCallEntry+0x8D）开始执行，我们把这一部分共同的代码称作SharedCode（引用Joney的文中的称呼），接下来，我们简要分析一下SharedCode到底做了什么事。 这里还是将代码放在一起分析，更有连贯性，具体细节可以到Windbg中动手实现 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455804df781 8bf8 mov edi,eax //eax保存的是系统服务号(参考3环部分)，edi获804df781 //取服务号804df783 c1ef08 shr edi,8 //将edi右移8位，系统服务号只用到13位，这样还804df783 //剩下5位804df786 83e730 and edi,30h //将余下的5位与0x30(0011 0000)进行与804df786 //算,得到的结果只有可能是0x10或者0，这里非常巧804df786 //妙，因为0x10刚好是16个字节804df789 8bcf mov ecx,edi //将与后的结果，赋值给ecx804df78b 03bee0000000 add edi,dword ptr [esi+0E0h] //esi指向KTHREAD，[esi+0xE]就算获取到第一个系804df78b //统服务表的首地址，然后加上edi。这里如果edi的804df78b //值是0x10，运算后，edi就会指向第二个系统服务804df78b //表的首地址，所以上一步的与运算很巧妙804df791 8bd8 mov ebx,eax //ebx获取服务号804df793 25ff0f0000 and eax,0FFFh //对服务号进行与运算，因为上面的步骤已经确定了804df793 //从哪一个系统服务表里找，这里将下标12的位置零804df793 //，获取在函数地址表里的索引804df798 3b4708 cmp eax,dword ptr [edi+8] //[edi+8]指向ServiceLimit，这里与系统服务号作804df798 //比较，防止系统符服务号越界804df79b 0f8341fdffff jae nt!KiBBTUnexpectedRange (804df4e2) //若越界则跳转异常处理804df7a1 83f910 cmp ecx,10h //这里判断系统服务号属于哪个表(虽然前面的步骤判804df7a1 //断过一次了，前面是为了判断服务号是否越界，这804df7a1 //里主要是找到合适的处理函数)804df7a4 751a jne nt!KiFastCallEntry+0xcc (804df7c0) //若不等，就跳转到处理查找第一个系统服804df7a4 //务表的例程804df7a6 8b0d18f0dfff mov ecx,dword ptr ds:[0FFDFF018h] //若要去查找第二个系统服务表，从这里走，不作详细804df7a6 //分析804df7ac 33db xor ebx,ebx804df7ae 0b99700f0000 or ebx,dword ptr [ecx+0F70h]804df7b4 740a je nt!KiFastCallEntry+0xcc (804df7c0)804df7b6 52 push edx804df7b7 50 push eax804df7b8 ff1564b25580 call dword ptr [nt!KeGdiFlushUserBatch (8055b264)]804df7be 58 pop eax804df7bf 5a pop edx804df7c0 ff0538f6dfff inc dword ptr ds:[0FFDFF638h] //如果查第一个表，会跳到这里来 [0xffdff638]804df7c0 //KPRCB结构的0x518偏移处，存的是KeSystemCalls804df7c0 //，这里自增1(具体用处到APC那块会讲到)804df7c6 8bf2 mov esi,edx //edx存着3环第一个参数的地址，赋给esi804df7c8 8b5f0c mov ebx,dword ptr [edi+0Ch] //ebx获取函数参数表地址804df7cb 33c9 xor ecx,ecx //清空ecx，之前用来判断寻找哪个系统服务表804df7cd 8a0c18 mov cl,byte ptr [eax+ebx] //cl获取函数参数个数804df7d0 8b3f mov edi,dword ptr [edi] //另edi直接指向函数地址表首地址804df7d2 8b1c87 mov ebx,dword ptr [edi+eax*4] //ebx获取到0环实现的内核函数804df7d5 2be1 sub esp,ecx //提升堆栈，ecx里存的是参数个数的总字节804df7d7 c1e902 shr ecx,2 //相当于运算ecx/4，方便rep movsd，因为rep804df7d7 //movsd是4字节运算804df7da 8bfc mov edi,esp //rep movsd指令用，Copy的目的地804df7dc 3b35d40b5680 cmp esi,dword ptr [nt!MmUserProbeAddress (80560bd4)]//检测三环参数地址范围是否越界804df7e2 0f83a8010000 jae nt!KiSystemCallExit2+0x9f (804df990) //若越界，进行异常处理804df7e8 f3a5 rep movs dword ptr es:[edi],dword ptr [esi] //将参数复制到堆栈804df7ea ffd3 call ebx //调用0环函数！804df7ec 8be5 mov esp,ebp804df7ee 8b0d24f1dfff mov ecx,dword ptr ds:[0FFDFF124h]804df7f4 8b553c mov edx,dword ptr [ebp+3Ch]804df7f7 899134010000 mov dword ptr [ecx+134h],edx 至此，这块KiFastCallEntry和KiSystemService最终都会执行的一段被我们称作SharedCode的代码段，就分析完了， SSDT前文提到了，我们可以通过fs找到KPCR，在通过KPCR找到KTHREAD，然后在KTHREAD+0xE0处找到系统服务表，这里再介绍另一种找到系统服务表的办法，通过SSDT。 SSDT&SSDT ShadowSSDT（System Services Descriptor Table）系统服务描述符表，在这个结构中包含4个成员，每个成员都是一个系统服务表的结构体，可以在Windbg中通过dd KeServiceDescriptorTable指令进行查看（在程序中可以直接声明全局变量KeServiceDescriptorTable，从而找到找到系统服务表。）： 我们可以看到第一个成员的ServiceTable，Count，ServiceLimit，ArgmentTable字段，Windows Xp只使用了2张表，所以第三个和第四个成员的位置是空的，此外，由于SSDT第二个成员是未导出的，所以第二个成员的位置也是空的。这里介绍一个新的指令，dd KeServiceDescriptorTableShadow，通过全局变量KeServiceDescriptorTableShadow可以查看两张完整的系统服务表。 但是，全局变量KeServiceDescriptorTableShadow也是未导出的，在实际写程序时，不能通过直接访问win32k.sys导出的第二张系统服务表的函数地址，因为里面的函数地址都是无效的。原因是，win32k.sys导出的第二张系统服务表只有在当前进程访问GDI相关的API时，里面的函数地址表才会挂载到物理页上。如果进程没有用到GDI相关的API，那么第二张系统服务表里面的函数地址表就不会挂载到物理内存，那么里面的函数也无效。 内核函数查找有了SSDT表，我们查找3环API对应的内核函数就很简单了，拿之前分析过的3环API函数ReadProcessMemory举例，在进入0环之前，给eax赋值了一个系统服务号0xba，那我们就用这个ba来查看这个这个函数在内核的实现。 通过这张图，可以很清晰的看出来，ReadProcessMemory所实现的功能，在底层是由一个叫做NtReadVirtualMemory完成的。 总结API函数的调用过程，从3环进入0环，再到找到对应的内核函数，这部分到这就差不多了，当然，真正的调用过程并没有到此结束，因为调用完0环的函数，总得返回3环呀！只是这部分需要用到APC的知识点，因此这里还不能完整实现。此外，在API函数调用这块，还有个小实验，在SSDT表中追加一个函数地址(NtReadVirtualMemory),自己编写API的3环部分调用这个新增的函数(注意：使用2-9-9-12分页，10-10-12会蓝屏)，就留到后面补上了 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=41 参考文章： https://www.cnblogs.com/joneyyana/p/12585469.html https://blog.csdn.net/qq_38474570/article/details/103674271 https://blog.csdn.net/qq_41988448/article/details/102994374","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（保存现场）","slug":"API函数的调用过程（保存现场）","date":"2020-03-26T01:30:03.000Z","updated":"2020-03-27T13:45:22.749Z","comments":true,"path":"2020/03/26/API函数的调用过程（保存现场）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/26/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA%EF%BC%89/","excerpt":"","text":"现在我们知道如何进入0环了，有两种方式，通过中断门或者快速调用。上一篇中最后留下了几个问题，其中一个就是关于如何保存那些3环寄存器原先的值（俗称保存现场），从而能够在执行完0环实现的功能后，顺利的返回到3环，今天我们就来探究一下这个问题，首先我们来认识几个结构：Trap_Frame，ETHREAD/KTHREAD，KPCR _Trap_Frame在Windbg中通过dt _KTrap_Frame进行查看 （0x7c~0x88）在保护模式下没有被使用，只在虚拟8086模式中用得到 （0x68~0x78）中断门进0环时，用于存储3环的CS，SS，ESP，EIP，EFLAGS （0x48~0x64）保存现场 （0x00~0x44）调式及其它作用 简要介绍完了Trap_Frame结构，了解了这是保存现场用到的结构，后面在分析KiSystemService时，会介绍保存现场的主要过程。 ETHREAD&KTHREADETHREAD（执行体线程块）是执行体层上的线程对象的数据结构。在Windows内核中，每个进程的每一个线程都对应着一个ETHREAD数据结构。 在Windbg中通过dt _ETHREAD进行查看 ETHREAD结构内嵌了一个KTHREAD对象作为第一个数据成员，因此一个指向ETHREAD对象的指针同时也是一个指向KTHREAD对象的指针。 在Windbg中通过dt _KTHREAD进行查看 大致先解下这些结构即可，后续在介绍到线程与进程处时，会慢慢分析各个字段。 KPCR描述： 全称为CPU控制区（Processor Control Region） 每一个CPU都有一个CPU控制区，跟TLB一样，一核一个KPCR 指令： dt _KPCR：查看KPCR结构 dd KeNumberProcessors：查看KPCR数量 dd KiProcessorBlock：查看KPCR位置 由于当前虚拟机只分配了一个核，所以数量是1 同理，因为单核，这里只显示了一个值，这个地址显示的是ffdff120，也就是KPCR偏移0x120的位置。KPCR偏移0x120的位置是 _KPRCB，可以理解为扩展的KPCR KiSystemService了解完上面介绍的结构，下面我们就可以分析一下0环函数KiSystemService，到底是如何保存现场的。 函数主体并不长，按照填充的结构不同我们来逐步分析。 0x1Code123456804df631 6a00 push 0 //ErrorCode804df633 55 push ebp804df634 53 push ebx804df635 56 push esi804df636 57 push edi804df637 0fa0 push fs 首先来看这一段，为什么要push 0起手呢？ 这里先回顾一下Trap_Frame结构。 这是一个结构，换句话说，就是进入0环后的堆栈将会像这种形式组织起来，在刚进0环是，esp是位于 (0x78) 的位置，我们知道，通过中断门进0环时，会将3环的寄存器压栈，包括CS，SS，EIP，ESP和EFLAGS。因此在进入0环后，ESP的位置是位于 (0x68) 处。虽然2E号中断只会压入5个值，但是有些情况会压入6个值，而第6个值，就是ErrCode，为了对齐，保持堆栈平衡，操作系统这里会自己补一个0，这也就解释了为什么第一步是push 0。 接下来，就是保存ebp，ebx，esi，esi，fs依次压栈，保存到Trap_Frame结构中描述的位置。 0x2Code1234567804df639 bb30000000 mov ebx,30h804df63e 8ee3 mov fs,bx //写入fs段寄存器804df640 ff3500f0dfff push dword ptr ds:[0FFDFF000h] //保存旧的异常链表(ExceptionList)804df646 c70500f0dfffffffffff mov dword ptr ds:[0FFDFF000h],0FFFFFFFFh //将新的异常链表赋值为-1804df650 8b3524f1dfff mov esi,dword ptr ds:[0FFDFF124h] //获取当前线程KTHREAD804df656 ffb640010000 push dword ptr [esi+140h] //将先前模式(PreviousMode)压栈804df65c 83ec48 sub esp,48h //提升堆栈（栈顶执行Trap_Frame头） 我们来看这部分做了什么事 首先是将段选择子0x30写入fs段寄存器 根据段选择子确定段描述符，然后可以发现fs指向的地方(0xffdff000)刚好是KPCR这个结构。 然后压栈了KPCR首地址位置的值 可以发现，KPCR首地址位置存的是异常链表(ExceptionList)，这里压栈了旧的异常链表，并将异常链表的值置为-1。至于异常链表的结构，留到后面再讲。 接着获取到KPCR + 0x124位置的值，并存入esi，然后将esi+0x140处的值压栈 可以发现KPCR+0x124处（赋给esi）的值，存的是当前线程（CurrentThread）的KTHREAD，我们再找到(esi)KTHREAD+0x140偏移，发现压栈的字段叫做先前模式（PerviousMode） 最后提升堆栈0x48个字节 经过这一部分的操作后，堆栈栈顶刚好指向_Trap_Frame的首地址，并完成了异常链表和先前模式的压栈操作。 0x3Code12345678804df65f 8b5c246c mov ebx,dword ptr [esp+6Ch] //取进入中断门压栈的CS804df663 83e301 and ebx,1 //计算出调用中断门前的权限804df666 889e40010000 mov byte ptr [esi+140h],bl //重新填写KTHREAD中的先前模式 804df66c 8bec mov ebp,esp //让ebp指向_Trap_Frame首地址804df66e 8b9e34010000 mov ebx,dword ptr [esi+134h] 804df674 895d3c mov dword ptr [ebp+3Ch],ebx //将旧的_Trap_Frame保存到edx中804df677 89ae34010000 mov dword ptr [esi+134h],ebp //更新_Trap_Frame804df67d fc cld 继续分析这一部分 我们来看前3行，它做了什么事呢，先取出_Trap_Frame 0x6C偏移处的值，即进入中断门前，程序CS的值，然后和1进行了与运算，并将bl的值，填入上面提到的先前模式 为什么和1进行与运算就可以算出先前模式呢？难道不直接填3吗？首先我们知道，Windows只用了0环和3环，其次，即使执行中断门，执行前的程序也可以是0环程序，所以保守起见，这里和CPL的最低位进行与运算；若结果为1，说明是3环程序执行了中断门，若为0，说明是0环程序执行的中断门。从而算出先前模式，并填入到当前线程KTHREAD的先前模式字段中。 上面3行更新了先前模式，接下来4行的作用就是更新了_Trap_Frame，我们知道栈顶指向Trap_Frame的首地址，现在让栈底也指向Trap_Frame的首地址，便于寻址。 由0x2的分析可知esi指向KTHREAD，KTHREAD+0x134则指向Trap_Frame，这里的Trap_Frame是旧的地址（这里则是Null），因此将它保存至堆栈，再将现在的Trap_Frame的地址写入，也就完成了更新。 cld指令修改了EFLAGS寄存器的DF位 0x4Code12345678910804df67e 8b5d60 mov ebx,dword ptr [ebp+60h] //取3环的ebp给ebx804df681 8b7d68 mov edi,dword ptr [ebp+68h] //取3环的eip给edi804df684 89550c mov dword ptr [ebp+0Ch],edx //edx存的是3环第一个参数的地址，赋到_Trap_Frame的DbgArgPointer的位置804df687 c74508000ddbba mov dword ptr [ebp+8],0BADB0D00h //将操作系统用的标志赋给DbgArgMark804df68e 895d00 mov dword ptr [ebp],ebx //将3环的ebp赋值到DbgEbp804df691 897d04 mov dword ptr [ebp+4],edi //将3环的eip赋值到DbgEip804df694 f6462cff test byte ptr [esi+2Ch],0FFh //判断DebugActive处的值是否为-1804df698 0f858efeffff jne nt!Dr_kss_a (804df52c) //跳转至调试寄存器保存函数804df69e fb sti804df69f e9dd000000 jmp nt!KiFastCallEntry+0x8d (804df781) 来看最后一部分 前6行，很好理解，主要是对_Trap_Frame调试部分的填充，一张图就可以概括 接下来的两行，会比较esi+0x2C的位置是否为-1 这个地方值如果不是-1，说明处于调试状态，紧接着会跳转到Dr_kss_a这个例程里，这个例程作用是将Dr0~Dr7这些调试寄存器的值保存到_Trap_Frame中，用于调试。同样的，了解了这个字段后，我们可以写一个程序，不断的修改这个值，将DebugActive这个值置为-1，这样程序就不会保存调试寄存器，也就无法调试，这是一种反调试的手段。 最后，程序会跳转到KiFastCallEntry+0x8D这个位置继续执行，而这个位置，也是KiFastCallEntry执行完后跳转的地方。之所以分了两种方式，是因为中断门进0环时，压栈了5个值（ESP，EIP，CS，SS，EFLAGS）而快速调用没有，导致它们在填写_Trap_Frame结构的方式不同，但是在填完后，保存现场以后，后面执行的函数就一样了。 KiFastCallEntryKiFastCallEntry保存现场的方式略微发杂，因为没有通过中断门对3环的5个寄存器进行压栈。由于分析的代码较多，这部分就不贴图了，可以参照KiSystemService的方法，在Windbg中找到对应结构进行分析。 KiFastCallEntry要分为两个部分来看，第一个部分，是和KiSystemService所做的一样，对_Trap_Frame结构的填充，进行保存现场。完了之后，第二个部分，从KiFastCallEntry+0x8D开始，这是KiSystemService执行完后跳转的地方，也是KiFastCallEntry顺序执行的地方，是双方都要执行的代码，这也意味着，从这个地方开始，两种进0环的方式就统一了。 本篇只介绍第一部分，看看KiFastCallEntry在填充_Trap_Frame时与KiSystemService有何不同吧。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849kd> u KiFastCallEntry L55nt!KiFastCallEntry:804df6f0 b923000000 mov ecx,23h804df6f5 6a30 push 30h804df6f7 0fa1 pop fs //令fs寄存器指向KPCR首地址804df6f9 8ed9 mov ds,cx //令ds=0x23804df6fb 8ec1 mov es,cx //令es=0x23804df6fd 8b0d40f0dfff mov ecx,dword ptr ds:[0FFDFF040h] //另ecx指向TSS 804df703 8b6104 mov esp,dword ptr [ecx+4] //取TSS中的esp0赋值给当前esp804df706 6a23 push 23h //将3环ss压栈(_Trap_Frame+0x78)804df708 52 push edx //将3环栈顶esp3压栈(+0x74)804df709 9c pushfd //将eflags寄存器压栈(+0x70)804df70a 6a02 push 2 804df70c 83c208 add edx,8 //获取外部第一个参数的位置(ReadProcessMemory共Call804df70c //了两次才到sysenter，因此压栈了2个返回地址，需要+8)804df70f 9d popfd //将2写入eflags寄存器804df710 804c240102 or byte ptr [esp+1],2 //没看懂有啥用804df715 6a1b push 1Bh //将3环cs压栈(+0x6c)804df717 ff350403dfff push dword ptr ds:[0FFDF0304h] //将3环eip压栈(+0x68)804df71d 6a00 push 0 //将Errcode压栈(+0x64)804df71f 55 push ebp //将3环ebp压栈(+0x60)804df720 53 push ebx //将3环ebx压栈(0x5c)804df721 56 push esi //将3环esi压栈(+0x58)804df722 57 push edi //将3环edi压栈(+0x54)804df723 8b1d1cf0dfff mov ebx,dword ptr ds:[0FFDFF01Ch] //将指向KPCR自己的指针存到ebx里804df729 6a3b push 3Bh //将3环fs压栈(+0x50)804df72b 8bb324010000 mov esi,dword ptr [ebx+124h] //将当前线程的KTHREAD存到esi804df731 ff33 push dword ptr [ebx] //将异常链表(ExceptionList)压栈(+0x4c)804df733 c703ffffffff mov dword ptr [ebx],0FFFFFFFFh //更新异常链表的值为-1804df739 8b6e18 mov ebp,dword ptr [esi+18h] //通过KTHREAD的InitialStack更新0环栈底804df73c 6a01 push 1 //将旧的先前模式(PreviousMode)压栈(+0x48)804df73e 83ec48 sub esp,48h //令esp指向_Trap_Frame首地址804df741 81ed9c020000 sub ebp,29Ch //这部分没看懂，舒默的分析是计算初试stack的Trap_Frame基址804df741 //这个0x29c的值等于：NPX_FRAME_LENGTH + TRAP_FRAME_LENGTH804df741 //其中NPX_FRAME_LENGTH = 0x210, TRAP_FRAME_LENGTH = 0x8c804df747 c6864001000001 mov byte ptr [esi+140h],1 //更新先前模式为1804df74e 3bec cmp ebp,esp //比较两个Trap_Frame基址，若不同则跳转去处理804df750 0f8572ffffff jne nt!KiFastCallEntry2+0x24 (804df6c8)804df756 83652c00 and dword ptr [ebp+2Ch],0 //将Dr7的值置0(+0x2c)804df75a f6462cff test byte ptr [esi+2Ch],0FFh //判断当前线程的DebugActive是否为-1804df75e 89ae34010000 mov dword ptr [esi+134h],ebp //更新当前线程的_Trap_Frame基址804df764 0f8546feffff jne nt!Dr_FastCallDrSave (804df5b0)//若DebugActive不为-1则跳转804df76a 8b5d60 mov ebx,dword ptr [ebp+60h] //将3环的Ebp赋值给当前ebx804df76d 8b7d68 mov edi,dword ptr [ebp+68h] //将3环的Eip赋值给当前edi804df770 89550c mov dword ptr [ebp+0Ch],edx //将第一个参数的地址存到DbgArgPointer804df773 c74508000ddbba mov dword ptr [ebp+8],0BADB0D00h //将0x0BADB0D00存到DbgArgMark804df77a 895d00 mov dword ptr [ebp],ebx //将3环ebp存到DbgEbp804df77d 897d04 mov dword ptr [ebp+4],edi //将3环eip存到DbgEip804df780 fb sti //设置EFLAGS的IF位，允许中断发生 这里就先分析到这，至于从KiFastCallEntry+0x8D开始的第二部分，由于是KiSystemService和KiFastCallEntry的公共代码，两种进0环的方式都会执行，就不再本篇中分析了，留到下一篇介绍系统服务表和SSDT时再介绍。 总结这一篇通过学习_Trap_Frame，KTHREAD，KPCR这些结构，分析KiSystemService&KiFastCallEntry了解了在进入0环后，保存现场的方式。尽管采用了两种不同的手段，但是思路总体来说是一样的，就是通过填充Trap_Frame结构完成3环寄存器的保存。在下一篇中，我们将继续探究，在保存完现场后，程序是如何找到想要执行的函数的。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=40 参考文章：https://blog.csdn.net/qq_41988448/article/details/102886413 ​ https://blog.csdn.net/qq_38474570/article/details/103652993","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（3环进0环）","slug":"API函数的调用过程（3环进0环）","date":"2020-03-25T12:40:57.000Z","updated":"2020-03-25T16:44:04.591Z","comments":true,"path":"2020/03/25/API函数的调用过程（3环进0环）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/25/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E8%BF%9B0%E7%8E%AF%EF%BC%89/","excerpt":"","text":"上一篇中分析了ReadProcessMemory函数的3环部分，它实际上没有做太多工作，只是提供了一个调用0环函数的接口，今天我们接着向下分析，看看函数是如何进入0环的。 _KUSER_SHARED_DATA_KUSER_SHARED_DATA结构 上一篇讲到了NtReadVirtualMemory这部分，调用了一个函数地址0x7FFE0300。那这个地址有什么用呢？这就要介绍一个新的结构_KUSER_SHARED_DATA： 在User层和Kernel层分别定义了一个_KUSER_SHARED_DATA结构区域，用于User层和Kernel层共享某些数据 它们使用固定的地址值映射，_KUSER_SHARED_DATA结构区域在User和Kernel层地址分别为： User层地址为：0x7FFE0000 Kernel层地址为：0xFFDF0000 虽然指向的是同一个物理页，但在User层是只读的，在Kernel层是可写的 SystemCall现在我们知道，0x7FFE0000处是_KUSER_SHARED_DATA结构，使用dt指令查看结构，查找0x300偏移处，也就是0x7FFE0300的位置，这个字段是SystemCall 那这个SystemCall有什么用呢？ SystemCall的作用是选择以什么方式进入0环。这要看CPU是否支持sysenter/sysexit 支持：ntdll.dll!KiFastSystemCall() 不支持：ntdll.dll!KiFastSystemCall() 那如何看CPU是否支持sysenter/sysexit指令呢？ （OD打开任一程序）将eax置1（参数） 将ecx，edx置0（方便查看） 执行指令cpuid 查看edx的SEP位（下标11的位置），若值为1，说明支持sysenter/sysexit FBFF -> 1111 1011 1111 1111 说明本机支持sysenter/sysexit KiIntSystemCall进0环在学过调用门，中断门后，我们知道，凡是提权（例如进0环），都伴随着寄存器中的值发生改变，包括CS，SS，EIP，ESP。所以我们分别分析一下两种进0环方式，看看他们是如何修改寄存器的值的，先从KiIntSystemCall开始。 获取提权后寄存器的值 KiIntSystemCall进0环的方式非常简单，就是我们最熟悉中断门。（这里第一条指令的作用是获取参数的首地址） 中断门就很熟悉了，进入IDT表看下0x2E对应的门描述符 根据中断门描述符，可以很快得到： CS = 0x8 EIP = 8053e481 至于SS，和ESP，会在程序提权时，由tr寄存器指向的TSS中的ESP0和SS0提供。 KiSystemService根据EIP的值，0x8053e481我们可以定位到一个内核函数KiSystemService 这样就说明进入0环了，所以KiIntSystemCall进0环非常好理解，就是中断门的知识，进入0环后，就跳转到KiSystemService继续执行，至于如何找到想要执行的函数，会在后面的文章中介绍。接下来我们来看支持sysenter/sysexit的KiFastSystemCall是如何进入0环的。 KiFastSystemCall进0环事实上，基本上现在的CPU都支持sysenter/sysexit，默认也是通过KiFastSystemCall进0环，为什么呢？顾名思义，因为快啊。因为KiFastSystemCall不需要像中断门进0环时，去查IDT表找CS，EIP，查TSS找ESP和SS，而是直接从寄存器里读取这些数据。 获取提权后寄存器的值 来看KiFastSystemCall，只有两行指令。sysenter指令，又称作快速调用，当CPU支持sysenter指令时，操作系统会提前将CS，SS，ESP，EIP写入到MSR寄存器中，当sysenter指令执行时，CPU直接从MSR中将这些值写入相应寄存器中，没有读取内存的过程，所以叫做快速调用。 MSR寄存器由于MSR寄存器非常大，这里不细讲，只列出用到的值 可以通过RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器） 这里读取ESP，EIP，CS的值（SS的值可以通过CS+8计算而得） 这样，在进入0环时，便能通过MSR寄存器切换4个寄存器的值了 KiFastCallEntry前面讲了KiIntSystemCall进入0环后执行KiSystemService，KiFastSystemCall当然也有，执行的是另一个函数，通过MSR得到的EIP我们可以找到函数KiFastCallEntry，同样是内核函数。 这样便成功进入0环了。 总结进0环的过程非常好理解，一种是咱们熟悉的中断门，另一种快速调用，也仅仅是利用了寄存器实现，不是很困难。但是有没有考虑一个问题，我们虽然成功的从3环进入到0环了，那该怎么出来呢？3环程序调用API实现功能，总该返回继续执行程序吧。既然要从0环返回3环，那就得恢复原来的寄存器的值，那么这些值又保存到了哪里呢？除此之外，现在进入了0环了，但又如何找到所要执行的函数呢？带着这些问题，我们继续学习下面的知识。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=39 参考文章：https://blog.csdn.net/qq_41988448/article/details/102825241","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"API函数的调用过程（3环部分）","slug":"API函数的调用过程（3环部分）","date":"2020-03-25T07:09:24.000Z","updated":"2020-03-25T10:15:51.746Z","comments":true,"path":"2020/03/25/API函数的调用过程（3环部分）/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/25/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E9%83%A8%E5%88%86%EF%BC%89/","excerpt":"","text":"保护模式暂时告一段落了，接下来开始API函数调用的学习，来一步步分析Windows在调用API的过程中到底做了些什么事，函数到底是如何实现的。 Windows API Application Programming Interface，简称API函数 Windows有多少个API？ 上万个，主要存放在 C:\\WINDOWS\\system32 下面所有的dll中 几个重要的DLL Kernel32.dll：最核心的功能模块， 比如管理内存、进程和线程相关的函数等。 User32.dll：是Windows用户界面相关应用程序接口，如创建窗口和发送消息等。 GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。例如，要显示一个程序窗口，就调用了其中的函数来画这个窗口。 Ntdll.dll：大多数API都会通过这个DLL进入内核（0环）。 分析ReadProcessMemory为了能够直观的了解API的调用过程，我们来分析一个Windows API函数，ReadProcessMemory，这个API函数位于Kernel32.dll，功能是读取指定进程的内存，打开IDA我们来看看它都做了些什么。 ReadProcessMemory在Kernel32.dll中选择导出函数，按下Ctrl+F，然后搜索ReadProcessMemory 找到后进入函数主体 我们可以看到，ReadProcessMemory函数总体分为3个部分，首先是参数的压栈，其次调用了一个函数NtReadVirtualMemory，接着就开始处理函数的返回值了，可以发现，真正读取内存的功能并不是在ReadProcessMemory中实现的，所以我们需要进一步去查看NtReadVirtualMemory。 把鼠标放在NtReadVirtualMemory上，发现该函数是外部函数，不属于Kernel32.dll，所以我们得去Kernel32.dll的导入函数中找一下这个函数属于哪个dll。 可以见得，NtReadVirtualMemory属于Ntdll.dll，接下来进入NtReadVirtualMemory继续分析。 NtReadVirtualMemory找到函数主体的步骤和上面一样，不再赘述。 NtReadVirtualMemory的函数主体部分只有4行，其中最关键的是前两行： mov eax, 0BAh：这一步给eax赋值了一个编号，这个编号的作用是在进入0环后，找到真正需要调用的函数。记住，这个编号存在eax中。 mov edx, 7FFE03000h：这一步同样关键，这是一个函数地址。它决定了进入0环的方式（具体在下一篇中会详细分析），同样，也要记住edx存了这个值。 经过简单的分析，可以发现，在3环层面上， 并没有真正实现函数的功能，API函数的实现，大部分都在0环（只有少部分函数是在3环实现）。拿ReadProcessMemory来说，只是相对于0环给上层提供的一个接口，通过这个接口，我们可以实现读取指定地址的内存 重写API函数现在我们知道，API函数的真正实现实际上是在底层（0环），3环上的API函数实际上只是起到一个接口的作用。那么我们可以自己重写3环的API，自己去调用0环函数，这样做的好处是，可以避免3环恶意挂钩（例如有黑客Hook了OpenFile函数，每次我们调用OpenFile时，黑客就知道我们打开了什么文件，如果重写API函数，黑客就无法通过Hook OpenFile函数来获取我们打开的文件内容，除非黑客在0环动手脚） 实现功能 实现的功能大致如此，读取变量a所在地址的内容，将内容改写后，再写入该地址，先用Windows API提供的ReadProcessMemory和WriteProcessMemory实现一遍。可以看到，原本变量a的值为0x123，随后被修改成了0x567 重写ReadProcessMemory这里以ReadProcessMemory为例，在先前的分析中， 我们知道ReadProcessMemory仅仅做了参数压栈的工作，而NtReadVirutalMemory先给eax赋值了一个编号，接着给edx赋了一个函数地址，并调用此函数，然后平衡堆栈。所以我们只需要将这些功能组合一下即可： c1234567891011121314151617181920212223void _stdcall MyReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead){ _asm { //ReadProcessMemory lea eax, [ebp+0x14] push eax //lpNumberOfBytesRead push [ebp+0x14] //nSize push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtReadVirtualMemory mov eax, 0xBA mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x14 }} 当然，仅仅这样做还不够，这样虽然编译能过，但是执行会报错。因为在ReadProcessMemory中调用NtReadVirutalMemory用了call语句，call语句的使用会导致返回地址压栈，也因此，我们重写的API函数在执行 Code1call dword ptr [edx] 这条语句时，esp处的值为hProcess，而Windows在执行这条语句时，[esp+4]处的值才是hProcess！如果这里不做修改，后面函数返回时，堆栈会不平衡，因此我们需要手动修改一下堆栈： 增加了这两行后，我们自己重写的ReadProcessMemory就算完成了。同理，WriteProcessMemory也是如此。 实验结果 可以看到，我们使用了自己重写的API函数，但是实现了同样的功能。同理，别的函数也可以通过重写，从而防止3环的恶意挂钩。 完整代码c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include \"stdafx.h\"#include void _stdcall MyReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead){ _asm { //ReadProcessMemory lea eax, [ebp+0x14] push eax //lpNumberOfBytesRead push [ebp+0x14] //nSize push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtReadVirtualMemory sub esp, 0x4 //Call NtReadVirtualMemory mov eax, 0xBA mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x18 }}void _stdcall MyWriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesWritten){ _asm { //WriteProcessMemory lea eax, [ebp+0x8] //hProcess push eax //lpNumberOfBytesRead push [ebp+0x14] //NumberOfBytesToWrite push [ebp+0x10] //lpBuffer push [ebp+0xC] //lpBaseAddress push [ebp+0x8] //hProcess //NtWriteVirtualMemory sub esp, 0x4 //Call NtWriteirtualMemory mov eax, 0x115 mov edx, 0x7FFE0300 call dword ptr [edx] add esp, 0x18 }}int main(int argc, char* argv[]){ int a = 0x123; int buffer = 0; printf(\"Before: a=%x\", a); MyReadProcessMemory(GetCurrentProcess(), &a, &buffer, 4, NULL);// printf(\"%x\", buffer); buffer = 0x567; getchar(); MyWriteProcessMemory(GetCurrentProcess(), &a, &buffer, 4, NULL); printf(\"After: a=%x\\n\", a); getchar(); return 0;} 总结对于API函数的调用过程，我们对三环的部分有了一定的了解，发现，大部分API的实现都是在0环，接下来的文章中，我们就跟进去，找找API函数在0环中的实现在哪。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=37 参考文章：https://blog.csdn.net/qq_41988448/article/details/102786700 参考资料：Joney的笔记，张嘉杰的笔记，XIAOYSHIJI的代码","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"TLB，控制寄存器","slug":"TLB，控制寄存器","date":"2020-03-24T01:14:36.000Z","updated":"2020-03-24T09:53:26.650Z","comments":true,"path":"2020/03/24/TLB，控制寄存器/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/24/TLB%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"","text":"保护模式的内容接近尾声，这一篇文章补充一下琐碎的知识点，下面先从TLB开始 TLB设计原因 假设我们通过一个线性地址访问一个物理页，想要去读取物理页上某个字节。但是实际过程中，并非只读了1个字节，我们需要先读取PDE，再读取PTE，最后再读取存放1个字节的物理页，读取的内容远远超过1个字节了。 在2-9-9-12分页下，会多读24个字节，如果读取的内容跨页了（存在两个不同的物理页上），那多读的字节会更多 为了提高效率，只能通过做记录来进行弥补。 因此CPU内部设计了一个表，用来做记录；由于位于CPU内部，速度和寄存器一样快，当然，表也不能做的过大。这个表叫做TLB（Translation Lookaside Buffer），用于地址解析 TLB结构 LA（线性地址） PA（物理地址） ATTR（属性） LRU（统计） xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 说明： ATTR（属性)：PAE分页，用PDPE&PDE&PTE。10-10-12分页则PDE&PTE 不同CPU的TLB表大小不一样 只要Cr3改变了（说明进程切换了），先前的TLB则会失效，换一套新的TLB，一核一套TLB 由于操作系统中的高2G映射基本不变，如果Cr3改了，直接刷新TLB，对于重建高2G以上的对应关系很浪费，所PDE和PTE中有个标志位G位，刷新TLB时将不会刷新PDE/PTE的G位为1的页。若TLB满了，则CPU会根据统计信息将不常用的地址废弃，保留最近最常用的 注意：只有当PDE的PS位为1时（即当前物理页为大页），G位才有效。 TLB种类TLB在x86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在x86的CPU里，一般都设有如下4组TLB： 缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB） 缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB） 缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB） 缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Instruction-TLB） TLB验证呵呵，这个破实验花了我一下午，我真是太菜了，一个原因是0地址挂物理页，踩了好几次坑，第二个是VC6很多强转不支持，耽误了很多时间。给0地址挂物理页的步骤就不赘述了，这里采用的10-10-12分页，只是采用了代码挂物理页的方式，具体可以参考基址小实验这一篇，这里就讲讲验证的过程。 我们先给0地址挂上第一个地址（0x425000，这是我随便选的，选错了可能蓝屏）的物理页，然后取0地址的处的置，发现值为0。 这时，我们注释掉给0地址挂第一个地址（0x425000）的物理页的代码，并给0地址挂第二个地址（0x426000）的物理页。这时再取0地址处的值，发现值为0x43，可以发现，这两个线性地址所对应的物理页上的值是不同的。 这时我们把上面的注释拿掉，先给0地址挂第一个地址的物理页，然后再给0地址挂第二个地址的物理页，按照道理，这时我们取到的值应该是第二个地址对应物理页上的值，我们来查看结果： 神奇的事情发生了，我们取到的仍然是第一个地址对应物理页上的值，这其实就是TLB的作用。 这时，我们增加一条语句 Code1invlpg dword ptr ds:[0] 再次运行程序发现，仅仅多了这一条语句，读取0地址的值，就变成了第二个地址对应物理页上的值，Invlpg是让指定页TLB无效化的指令，因此再次访问时，原先的TLB已经被废弃，就需要重新去物理页读取，此时0地址对应的物理页已经是第二个地址的物理页了。当然，除了使用Invlpg指令，修改Cr3也可以做到让TLB无效化。 下面附上完整代码 c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include \"stdafx.h\"#include DWORD phyAddr, phyAddr2, temp;__declspec(naked) Test() { _asm { pushad pushfd } phyAddr = (DWORD)(0xc0000000 + ((0x425000 >> 0xa) & 0x3ffffc)); phyAddr2 = (DWORD)(0xc0000000 + ((0x426000 >> 0xa) & 0x3ffffc)); _asm{ mov eax, phyAddr mov eax, [eax] mov dword ptr ds:[0xc0000000], eax mov eax, dword ptr ds:[0] mov temp, eax// invlpg dword ptr ds:[0] 无效化指定页的TLB// mov eax, cr3 切换Cr3来清空TLB// mov cr3, eax mov eax, phyAddr2 mov eax, [eax] mov dword ptr ds:[0xc0000000], eax mov eax, dword ptr ds:[0] mov temp, eax } _asm{ popfd popad retf }}int main(int argc, char* argv[]){ char buffer[] = {0, 0, 0, 0, 0x4B, 0}; _asm call fword ptr buffer printf(\"temp: %x\", temp); getchar(); return 0;} 控制寄存器说完了TLB，来说说控制寄存器。控制寄存器的作用主要是用于控制和确定CPU的操作模式。主要包括Cr0，Cr1，Cr2，Cr3，Cr4，其中Cr1保留。 Cr0寄存器Cr0寄存器，主要包括一些控制操作系统模式以及处理器状态的控制标志位。 这里介绍几个主要的标志位，其余位的描述可以参考Intel白皮书第三卷系统架构综述那章。 PE：Cr0下标为0的位是启用保护（Protection Enable）标志。PE=1保护模式，PE=0实地址模式，这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。 PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。 PG=0且PE=0：处理器工作在实地址模式下 PG=0且PE=1：处理器工作在没有开启分页机制的保护模式下（不存在这样的操作系统） PG=1且PE=0：在PE没有开启的情况下 无法开启PG PG=1且PE=1：处理器工作在开启了分页机制的保护模式下 WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志，当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作。 对于Ring0的特权级程序，如果WP=0，可以读写任意用户级物理页，只要线性地址有效 对于Ring0的特权级程序，如果 WP=1 可以读取任意用户级物理页，但对于只读的物理页，则不能写 Cr2寄存器Cr2寄存器，保存导致缺页异常的线性地址。 之前在中断与异常中，简要概括了缺页异常，当CPU访问某个无效页面，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在Cr2中，以便操作系统处理完缺页异常后，返回到原本执行的位置继续执行。 Cr3寄存器Cr3我们太熟悉了，在10-10-12分页是页目录表基址，在PAE分页下，则是页目录指针表基址 这里有两个属性，PWT和PCD之前在页的部分一直没有讲，在介绍之前，先来了解一个概念，叫做CPU缓存 CPU缓存 CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多，但是交换速度远快于内存。 CPU缓存可以做的很大，从几K，几十K，几百K，甚至上M。 CPU缓存与TLB的区别： TLB：线性地址 物理地址 CPU缓存： 物理地址 内存 有了CPU缓存和TLB的概念后，就可以来讲讲PWT和PCD这俩属性了。 PWT(Page Write Through) PWT = 1时，CPU向cache写入数据时，同时向memory也写一份，使cache和memory的数据保持一致。优点是简单，缺点是每次都要访问memory，速度比较慢，即Write Through。 PWT = 0时，CPU向cache写入数据时，不将数据写入内存中，分为两种情况： Post Write：CPU更新cache数据时，把更新的数据写入到一个更新缓冲器，在合适的时候才对memory进行更新。这样可以提高cache访问速度，但是，在数据连续被更新两次以上的时候，缓冲区将不够使用，被迫同时更新memory。 Write Back：CPU更新cache时，只是把更新的cache区标记一下，并不同步更新memory。只是在cache区要被新进入的数据取代时，才更新memory。这样做的原因是考虑到很多时候cache存入的是中间结果，没有必要同步更新memory。优点是CPU执行的效率提高，缺点是实现起来技术比较复杂。 PCD(Page Cache Disable) PCD = 1时，禁止某个页写入缓存，直接写入内存。例如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。 PCD = 0时，不限制页写入缓存，可以参考上面PWT的情况。 Cr4寄存器Cr2寄存器，保存了一组启用多种架构扩展的标志位 这里简单概括一下PAE位和PSE位： PAE：置1时，是PAE分页；置0时，是10-10-12分页。之前在boot.ini中设置execute/noexecute的作用就是修改PAE位 PSE：控制PDE中PS位的开关，当PSE置1时，PS位才有效。具体如下： 控制寄存器小节除了上述介绍的，还有一个Cr8寄存器，仅仅在64位下才存在，这里就不作介绍了，其余寄存器总览如下： 参考文章1：https://blog.csdn.net/wyzxg/article/details/7254458 参考文章2：https://blog.csdn.net/q1007729991/article/details/53000410 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=33","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"中断与异常","slug":"中断与异常","date":"2020-03-23T14:37:48.000Z","updated":"2020-03-24T12:48:08.406Z","comments":true,"path":"2020/03/23/中断与异常/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/23/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/","excerpt":"","text":"段和页的主要知识，差不多就告一段落了，这篇文章简单介绍一下中断与异常的相关概念，结合之前学习的IDT表，形成一个整体的框架，在后续文章中，会再详细解析中断和异常的处理过程。 中断什么是中断 中断通常是由CPU外部的输入输出设别（硬件）所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫做中断请求（IRQ-Interrupt Request） 中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程（中断处理程序在哪由IDT表决定） 80x86有两条中断请求线： 不可屏蔽中断线，称为NMI（NonMaskable Interrupt） 可屏蔽中断线，称为INTR（Interrupt Require） 不可屏蔽中断 （IDT表）中断号 NMI 说明 0x2 不可屏蔽中断 80x86中固定为0x2 说明： 当不可屏蔽中断产生时，CPU在执行完当前指令后会立即进入2号中断，执行相应中断处理程序 不可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理 可屏蔽中断在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求。为了便于标识各个中断请求，中断控制器通常用IRQ（Interrupt Request）后面加上数字来表示不同的中断。 例如：在Windows中，时钟中断的IRQ编号为0，也就是：IRQ0 （IDT表）中断号 IRQ 说明 0x30 IRQ0 时钟中断 0x31~0x3F IRQ1~IRQ15 其它硬件设备的中断 说明： 如果自己的程序执行时不希望CPU去处理这些中断，可以用CLI指令清空EFLAG寄存器中的IF位。与CLI指令相反，STI指令可以用来设置EFLAG寄存器中的IF位 硬件中断与IDT表中的对应关系并且固定不变的，参见APIC（高级可编程中断控制器） 异常聊完了中断，来看看异常。异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。 与中断的区别 中断来自于外部设备，是中断源（例如键盘）发起的，CPU是被动的。 异常来自于CPU本身，是CPU主动产生的。 INT N虽然被称为“软件中断”，但其本质是异常。因此不受EFLAG的IF位影响。 异常处理无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。 上图为IDT表中常见的中断向量号的相关描述，具体细节可以参考Intel白皮书第三卷（Exception And Interrupt Reference）这章 缺页异常（无时无刻不在发生）缺页异常产生： 当PDE/PTE的P=0时 当PDE/PTE的属性为只读，但程序试图写入时 一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统接管。 这里简单概括上述两种发生缺页异常的情况： 在操作系统中，物理页往往是紧缺的，若当前PTE指向的物理页的内容一段时间没有被访问，则会将这个物理页上的内容存到一个文件里，同时将这个物理页挂给有需要的PTE用，并将原PTE的P位置0。当程序再次访问这段内容时，发现P位为0，则会触发缺页异常，但是此时PTE下标为10,11的位置均为0，其余位置都是有值的，这种情况说明当前PTE指向的内容存到了文件中，并根据下标1~4指定的偏移，在文件中找到内容。这时再重新给这些内容挂上新的物理页，将P位改为1，这时访问便可正常执行。当然，缺页异常对于用户来说是透明的，用户只会觉得自己正常访问了某个内容，但实际上进行了很多操作，通过缺页异常，操作系统可以节省大量物理页。 当PDE/PTE属性为只读时，CPU不会进行处理，而是跳到E号中断交给操作系统来处理，操作系统发现程序正在尝试写一个只读的物理页，会返回一个C0000005错误。 异常小节当异常发生时，CPU会判断异常的种类，根据中断向量号，跳转到相应的异常处理程序，接着由操作系统接管并处理。 总结这篇简要介绍了中断与异常，在后续讲到中断章节时，会更加详细的分析过程原理。 参考教程：https://www.bilibili.com/video/BV1NJ411M7aE?p=32","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"2-9-9-12分页","slug":"2-9-9-12分页","date":"2020-03-22T06:53:29.000Z","updated":"2020-03-23T07:36:10.904Z","comments":true,"path":"2020/03/22/2-9-9-12分页/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/22/2-9-9-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"在前面的文章中主要介绍了10-10-12分页方式，在这种分页方式下，物理地址最多可达4GB。随着硬件发展，4GB的物理地址范围已经无法满足要求，于是Intel设计了一种新的分页方式：2-9-9-12分页（又称PAE）分页。下面就来了解一下这种分页方式是如何运作的吧。 PAE分页为什么是2-9-9-12PAE（Physical Address Extension，物理地址扩展）页，一定会涉及到2个结构，就是PDE和PTE。以PTE来说，它可以直接定位到某个物理页上的物理地址，在10-10-12分页下，由于PTE的大小是4字节(32位)，因此PTE能够寻址的范围仅有4GB。设想，若PTE有33位，那便可以寻址8GB；34位就能寻址16GB……以此类推。Intel考虑到对齐的因素，就干脆直接让PTE的长度达到64位了。这样一个PTE的大小就8字节，又因为一个PTT表的大小是4KB(4096字节)，因此原本一个PTT表里能装下1024个4字节的PTE，现在只能装下512个8字节的PTE了。2的9次方等于512，所以PTI的值为9。 同理，PDI的值也为9，这样2-9-9-12中还剩下最前面的2位。 设置PAE分页设置PAE分页比较简单，进入C盘打开boot.ini文件修改启动项，将execute改成noexecute即可，然后重启虚拟机即可进入PAE分页。 PDPTEPDPTE（Paga-Directory-Point-Table Entry）页目录指针表项，顾名思义，这是一个指向PDT表（在10-10-12分页下，Cr3指向PDT表的首地址）的元素，且位于PDPT表（PAE分页下Cr3指向PDPT表首地址）中。由于仅剩2位，所以PDPTE只有4个，同样PDPTE每项占8个字节，来看下这个结构。 Avail：下标9~11，共3位，这是留给操作系统使用的位，CPU本身并不使用 Base Address：下标12~35，寻址时，低12位补0，共36位（达到36位，与PTE保持一致，寻址空间达到64GB），即PDT基址 至于PCD和PWT，留到控制寄存器和TLB部分详解。 PDEPAE分页下，PDE扩展到了64位，其余属性变化不大。 PS = 1：大页，下标35-21是大页的物理地址，低21位填0，大页的大小为2MB（10-10-12的大页为4MB），按照2MB对齐。 PS = 0：下标35~12是页表（PTT）基址，低12位补0，共36位。 Avail：同PDPTE PTE与PDE一样，PAE分页下的PTE，也是扩展到了64位，其余变化不大 PTE中下标35-12是物理页基址，共24位（10-10-12分页下是下标31~12，共20位），低12位补0。 物理页基址+12位的页内偏移指向具体数据。 在了解这些结构后，来看一下PAE分页的大致模型 XD位在Intel新系列的CPU中，在下标63的地方多了一个属性位XD位（AMD中称为NX，即No Execetion） 我们知道段的属性有可读、可写和可执行，但是页的属性只有可读、可写。 当ret执行返回语句时，如果堆栈里的数据指向一个提前准备好的数据（把数据当作代码来执行，漏洞很多都是依赖这点，比如SQL注入），这个位的作用就是在硬件上实现一种保护，防止数据可执行的情况发生。 查找物理页PAE分页下查找对应的物理页和10-10-12差不多，拆分线性地址后，再根据PDPI、PDI、PTI偏移去找，由于每项均是8字节，所以在Windbg中使用dq指令进行查看。来看下面这个例子： 变量a的线性地址为：0x12ff7c。按照2-9-9-12进行拆分后得到0-0-12f-f7c。接着通过Cr3一步步查找，具体如下： 变量a的存的值为0x123，通过拆分线性地址，成功在找到变量a对应的物理地址。 0地址挂物理页在学习10-10-12分页时，通过0地址挂物理页的实验，加深对物理页的理解，这里我们通过这个实验进一步熟悉PAE分页。 先运行程序，发现访问违例，运行失败 查看0地址对应的物理页，发现物理页是空的。 然后查看局部变量a对应的物理页，并将a对应的物理页挂到0的位置（注意，挂物理页时，用两次!ed指令而不是!eq指令） 接着运行程序发现可以正确的打印出0地址上的内容 PAE分页下PDT/PTT的基址新增加的结构，PDPTE，并没有R/W位，US位等属性，真正决定物理页属性的还是PDE和PTE。相比10-10-12分页可以通过PDT/PTT基址修改物理页属性，在PAE分页下同样可以做到，这部分我们来研究下PAE分页下PDT和PTT的基址。 逆向分析MmIsAddressValid在前一篇文章中我们分析了10-10-12分页下的MmIsAddressValid函数，它在找到PDE/PTE后会判断下标为0(P位)和下标为7(PDE对应PS位，PTE对应PAT位)的位置的值，进行一些处理工作。而这个函数找到PDE/PTE的过程就使用了PDT/PTT的基址。这次通过分析PAE分页下的MmIsAddressValid函数，来找到PAE分页下PDT/PTT基址。 先分析查找PDE的部分 Code12345678910111213141580511987 8b4d08 mov ecx,dword ptr [ebp+8] //获取参数8051198a 56 push esi 8051198b 8bc1 mov eax,ecx8051198d c1e812 shr eax,12h //右移18位80511990 bef83f0000 mov esi,3FF8h 80511995 23c6 and eax,esi //进行与运算，余下11位有效位80511997 2d0000a03f sub eax,3FA00000h //相当于add eax, 0xC06000008051199c 8b10 mov edx,dword ptr [eax] //取PDE低四字节8051199e 8b4004 mov eax,dword ptr [eax+4] //取PDE高四字节805119a1 8945fc mov dword ptr [ebp-4],eax //高四字节保存到局部变量805119a4 8bc2 mov eax,edx805119a6 57 push edi //保存edi原本的值805119a7 83e001 and eax,1 //保留P位的值805119aa 33ff xor edi,edi805119ac 0bc7 or eax,edi 右移18位后，进行了一次与运算，保留的位相当于PDPI x 4KB + PDI x 8（看不明白的可以参考这篇） sub eax, 0x3FA00000和add eax, 0xC0600000，因此可以推测，PAE分页下PDT的基址为0xC0600000 接着分析查找PTE的部分 Code123456789101112805119c3 c1e909 shr ecx,9 //右移9位805119c6 81e1f8ff7f00 and ecx,7FFFF8h //进行与运算，余下20位有效位805119cc 8b81040000c0 mov eax,dword ptr [ecx-3FFFFFFCh] //相当于mov eax, [ecx+0xC0000004]805119d2 81e900000040 sub ecx,40000000h //相当于add ecx, 0xC0000000805119d8 8b11 mov edx,dword ptr [ecx] //取PTE低四字节805119da 8945fc mov dword ptr [ebp-4],eax //将PTE高四字节保存至局部变量805119dd 53 push ebx //保存ebx原本的值805119de 8bc2 mov eax,edx 805119e0 33db xor ebx,ebx 805119e2 83e001 and eax,1 //保留P位的值805119e5 0bc3 or eax,ebx805119e7 5b pop ebx 重点还是在与运算这，右移9位后跟0x7FFFF8进行与运算，相当于PDPI x 2MB + PDI x 4KB + PTI x 8 sub ecx，0x40000000相当于add ecx, 0xC0000000，可以推测，PAE分页下PTT的基址仍然为0xC0000000 公式总结根据MmIsAddressValid函数，可以得到PAE分页下PDT和PTT的基址分别为0xC0600000和0xC0000000。 我们可以采纳MmIsAddressValid的方法总结出找到任意一个PDE /PTE的公式： 利用MmIsAddressValid内的手法 c12pPDE = (int*)(0xc0600000 + ((addr >> 18) & 0x3ff8))pPTE = (int*)(0xc0000000 + ((addr >> 9) & 0x7ffff8)) 通过拆分线性地址 c12pPDE = (int*)(0xc0600000 + (PDPTI","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"逆向分析MmIsAddressValid(10-10-12)","slug":"逆向分析MmIsAddressValid","date":"2020-03-21T03:07:40.000Z","updated":"2020-03-21T08:36:14.300Z","comments":true,"path":"2020/03/21/逆向分析MmIsAddressValid/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/21/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid/","excerpt":"","text":"在对页表基址，页目录表基址熟练掌握后，今天来看逆向分析一个函数：MmIsAddressValid。这是一个系统函数，可以在ntoskrnl.exe的导出函数中找到它，也可以在Windbg中输入指令 Code1kd> u MmIsAddressValid 查看。 为什么要分析这个函数呢？因为即使是系统函数，也是无法直接使用物理页的，想要去访问PDE和PTE也就一定要通过基址来访问，而今天要分析的MmIsAddressValid函数，就利用了这么一个原理，相比前一篇的基址小实验，这里对于线性地址拆分的过程更为巧妙，让我们一起来看看吧！ 获取PDE属性 首先观察函数主体部分，发现代码并不长，但是有很多跳转，具体跳转内容就不作分析了，主要是分析函数主体： Code1234567891011121314804e4661 8bff mov edi,edi //hotpatch804e4663 55 push ebp804e4664 8bec mov ebp,esp804e4666 8b4d08 mov ecx,dword ptr [ebp+8] //取第一个参数（线性地址）804e4669 8bc1 mov eax,ecx //赋值到中间变量，方便运算804e466b c1e814 shr eax,14h //逻辑右移20位804e466e bafc0f0000 mov edx,0FFCh 804e4673 23c2 and eax,edx //和操作数进行与运算，同时清空最后2位；相当于做了一个乘4的运算，既左移2位804e4675 2d0000d03f sub eax,3FD00000h //进行减法运算，相当于eax+0xC0300000804e467a 8b00 mov eax,dword ptr [eax] //取PDE的值804e467c a801 test al,1 //判断PDE属性P位是否为1804e467e 0f84d2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e4684 84c0 test al,al //判断下标为7的位(PS位)值是否为1804e4686 7824 js nt!MmIsAddressValid+0x53 (804e46ac) 巧妙的与运算： 首先将线性地址逻辑右移20位，此时还余下12位 将这12位和操作数0xFFC做一个与运算，0xFFC换算成2进制就是1111 1111 1100。因此做完与运算后，刚刚经过第一步操作还剩下12位的数的低2位，置0了。熟悉移位运算的朋友们知道，这个12位的数，相当于1个10位的数逻辑左移2位得到，换句话说就是将这个10位的数乘4。而这个10位，就是PDI，因此这步操作完了以后，相当于我们获得了PDI*4的值。 接下来，与0x3FD00000做减法运算，作用相当于加上0xC0300000，两种方法的结果是一样的。因此，我们得到了0xC0300000 + PDI*4的值，而这个值，恰恰就是我们要找的PDE，接着只需要取出里面的值，就可以获取PDE的属性了 后续跳转再获取PDE的属性后，会遇到两个跳转，简单的概括下： 首先会判断PDE下标为0的位置的值，也就是P位，当P位为0时，说明物理页无效，会跳转到一个相应的处理函数，这里就不再跟进分析 若物理页P位为1，就会来到第二个跳转，这里test al, al指令会修改标志寄存器，当al的最高位，也就是下标为7的位置值为1时，会被认为是负数，此时会修改EFLAG寄存器的SF位。这时，在第二个跳转的位置，js判断的就是SF的值是否为1，若为1，也就是al下标为7的位置值为1，这是对应的PDE属性PS位，说明这是一个4MB的大页，进而会跳转执行相应的处理函数。 获取PTE属性Code123456789101112804e4688 c1e90a shr ecx,0Ah //逻辑右移10位804e468b 81e1fcff3f00 and ecx,3FFFFCh //和操作数进行与运算，同时清空最后2位，相当于PDI左移12位+PTI左移2位804e4691 81e900000040 sub ecx,40000000h //进行减法运算，相当于eax+0xC0000000804e4697 8bc1 mov eax,ecx804e4699 8b08 mov ecx,dword ptr [eax] //获取PTE属性804e469b f6c101 test cl,1 //判断P位的值是否为0804e469e 0f84b2f10000 je nt!MmIsAddressValid+0x4f (804f3856)804e46a4 84c9 test cl,cl //判断PAT是值是否为1804e46a6 0f88b6de0300 js nt!MmIsAddressValid+0x3f (80522562)804e46ac b001 mov al,1804e46ae 5d pop ebp804e46af c20400 ret 4 巧妙的与运算Code1and ecx, 3FFFFCh 假设线性地址右移10位后的值为 0000 0000 00aa aaaa aaaa bbbb bbbb bbxx（a, b的值为0或者1，这里只是为了区分PDI和PTI） 然后我们来拆分0x3FFFFC的值：0000 0000 0011 1111 1111 1111 1111 1100 将两者进行与运算后得到结果为 0000 0000 00aa aaaa aaaa bbbb bbbb bb00 我们知道，aa aaaa aaaa应为PDI，而bb bbbb bbbb应为PTI，因此可以把得到的结果看作是这样的一个运算：$$aa aaaa aaaa","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"},{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"基址小实验（10-10-12）","slug":"基址小实验","date":"2020-03-20T15:14:53.000Z","updated":"2020-03-22T16:36:37.983Z","comments":true,"path":"2020/03/20/基址小实验/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/20/%E5%9F%BA%E5%9D%80%E5%B0%8F%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"在学习完页目录表基址，页表基址后，我们知道通过C0300000和C0000000这两个地址，可以访问相应的PDE和PTE，今天就来实践一下。 之前在介绍PDE/PTE属性R/W位时有过一个实验，是对位于常量区的内容进行修改，当时通过Windbg修改了所在PDE/PTE的R/W位。这次实验，我们利用页目录表/页表基址来进行修改。 测试原始代码 首先测试原始代码，发现直接修改常量区的字符串，是会失败的 提权进入0环提权这里还是会用到Windbg，根据调用函数的地址，填入段选择子，并通过调用门进行提权（就当复习调用门知识了） 修改R/W位提权进入0环后（为啥要提权呢？因为C0300000/C0000000都属于高2G的线性地址，3环没法直接访问），就到了我们最关键的步骤了，修改R/W位。 c123456temp = *(int*)0xC0300004;temp = temp|0x2;*(int*)0xC0300004 = temp;temp = *(int*)0xC000108C;temp = temp|0x2;*(int*)0xC000108C = temp; 在这之前声明了一个中间变量temp（int类型）。 具体步骤： 打印出字符串所在常量区的地址0x423fb0，进行拆分：10-10-12 -> 0x1-0x23-0xfb0 PDI = 0x1，带入公式：PDE = C0300000 + 0x1 x 4 PTI = 0x23，带入公式：PTE = C0000000 + 0x1 x 1000 + 0x23 x 4 分别取PDE和PTE处的值，并和0x2进行或运算（将R/W位置1） 这样就完成了对R/W位的修改，在接下来再次对常量区的值进行修改操作时，便可以成功。 完整代码c123456789101112131415161718192021222324252627282930313233343536373839#include \"stdafx.h\"int temp;__declspec(naked) void ModifyRW() { __asm { pushad pushfd } temp = *(int*)0xC0300004; temp = temp|0x2; *(int*)0xC0300004 = temp; temp = *(int*)0xC000108C; temp = temp|0x2; *(int*)0xC000108C = temp; __asm { popfd popad retf }}int main(int argc, char* argv[]){ char* str = \"hello\"; char buffer[6] = {0, 0, 0, 0, 0x4B, 0}; printf(\"addr: %x, str: %s\", str, str); getchar(); _asm { call fword ptr buffer } *str = 'a'; printf(\"str: %s\", str); getchar(); return 0;}","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"页目录表、页表基址","slug":"页目录表、页表基址","date":"2020-03-20T07:11:51.000Z","updated":"2020-03-20T14:22:35.004Z","comments":true,"path":"2020/03/20/页目录表、页表基址/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/20/%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E3%80%81%E9%A1%B5%E8%A1%A8%E5%9F%BA%E5%9D%80/","excerpt":"","text":"考虑这样一个问题，我们现在可以通过在Windbg里找到线性地址所在的物理页，通过修改物理页的属性，就可以实现一些原本受限的功能。例如将常量区对应的物理页R/W属性修改为1，便可以修改位于常量区的元素。 但是，以上操作都是基于Windbg在双击调试的环境中实现的，那么一旦脱离了调试器，该如何通过代码来实现对物理页属性的修改呢？这就需要借助于页目录表基址和页表基址了。 页目录表基址结论：C0300000就是页目录表基址，接下来我们来验证这个结论。 C0300000拆分C0300000： 1100 0000 0011 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 11 0000 0000 300 12 0000 0000 0000 0 Cr3这里以记事本(notepad.exe)为例，来验证一下，C0300000就是页目录表基址，首先查看记事本对应的Cr3指向的物理地址。 我们知道，Cr3指向的是PDT的首地址，这里可以看到4个PDE有值。 查看C0300000物理页接下来的步骤就是比较熟悉的，根据拆分后的线性地址，寻找物理页的过程了。但是这一次，要慢点看。 这一步很容易理解，Cr3.base + 300*4，通过Cr3和线性地址的前10位，我们找到了PDE的值：7ea49063 什么？又重复了一遍？实际上不是，由于PDE的值为7ea49063，后12位是属性位，因此，7ea49000是我们要找的PTT的首地址，然后通过PTT.base + 300*4，就得到了PTE的值：7ea49063。 有了PTE的值，加上最后12位的偏移（此处为0），就可以找到物理页。 得到结果后，是不是很惊讶？C0300000这个线性地址对应的物理页上的物理地址，竟然和Cr3指向的物理地址完全一样！也就是说，以后不需要Cr3，只需在当前程序内，通过C0300000这个线性地址就可以得到当前程序PDT的首地址了 如何利用是啊，C0300000这个地址有啥用呢？当然有用，而且非常有用。回到文章开头的问题，我们该如何在不使用Windbg的情况下，修改物理页的属性呢？ 我们知道，想要修改物理页的属性，需要先修改物理页对应的PDE和PTE，那要如何找到PDE和PTE呢，由于在编写代码时，用到的都是线性地址，而C0300000这个线性地址刚好就可以找到PDT的首地址，这样我们拆分想要修改的物理页属性的线性地址，将前10位加上C0300000即可找到对应的PDE。 既然PDE找到了，那不就有了PTT的首地址，这样PTE不也就可以找到了吗？并不是这样，尽管找到了PDE，但是由于PDE里面存着的是物理地址，如果直接访问PDE里面存的那个地址，在代码中会转变为一个线性地址，因此并不能通过PDE获取PTT的首地址，也就不能获取到PTE了，想要找到PTE，还得需要用到另外一个基地址，就是页表基址。 页表基址还是直接上结论，页表基址：C0000000 接下来我们来验证。 C0000000拆分C0000000： 1100 0000 0000 0000 0000 0000 0000 0000 每部分位数 二进制 十六进制 10 11 0000 0000 300 10 00 0000 0000 0 12 0000 0000 0000 0 Cr3这里还是以记事本(notepad.exe)为例： 我们查看Cr3指向的物理地址，当前共有4个PDE的有值的，而PDE的值，就是PTT的首地址，以第一个PDE（36c24067）为例，其中PTT的首地址为36c24000。 查看C0000000物理页步骤和之前一样，就直接看结果好了。 发现，C0000000这个线性地址所对应的物理页，刚好是36c24000，也就是第一个PDE对应的PTT的首地址。由此可以进一步推断，C0001000则是第二个PDE对应的PTT的首地址，以此类推。 再看10-10-12分页现在再来看10-10-12分页时，看法就会有所不一样了。 实际上页表（PTT）被映射到了从0xC0000000到0xC03FFFFF的4M地址空间 在这1024个表中有一张特殊的表：页目录表（PDT） 页目录表（PDT）被映射到了0xC030000开始处的4KB大小的地址空间 总结有了0xC0300000和0xC0000000能做什么？掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。 公式总结： 什么是PDI和PTI？ 将32位线性地址拆分位10(PDI)-10(PTI)-12 访问页目录表(PDT)的公式：0xC0300000 + PDI x 4 访问页表(PTT)的公式：0xC0000000 + PDI x 1000 + PTI x 4（不用*号因为会被转义） 其它关于页的细节 高2G有一些大页，即4MB页 两个进程低2G几乎不同，高2G几乎相同 一个进程低2G的内存空间，前64K与后64K是没有使用的（线性地址0 - 00010000 与 7FFF0000 - 7FFFFFFFF） 谁填充了这些表呢进程本身可以通过0xC0300000和0xC0000000访问修改任意物理页，那么是谁为我们填充0xC0300000和0xC0000000的PDE与PTE呢？ 进程的创建过程：当创建B进程时，先在A进程中将B进程所有信息全部构建好，然后切换Cr3即可。也就是说，最开始的这张表是由A进程填充的。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"PDE_PTE属性（部分）","slug":"PDE-PTE属性","date":"2020-03-19T12:37:33.000Z","updated":"2020-03-19T15:51:12.795Z","comments":true,"path":"2020/03/19/PDE-PTE属性/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/19/PDE-PTE%E5%B1%9E%E6%80%A7/","excerpt":"","text":"上一篇文章中了解了PDE和PTE，这一篇就来了解一下PDE和PTE的属性。 物理页的属性 一上来看这张图，肯定是一脸懵逼的。先从行开始看，第一行是关于CR3寄存器的，这部分留到控制寄存器的章节再分析。接下来三行是不同类型PDE的，最后两行是PTE的。其中PDE和PTE有很多属性是重合的。而物理页的属性，就是有PDE和PTE共同决定的。计算方法是将相同属性位的值进行与运算。 物理页的属性 = PDE属性 & PTE属性 P位 首先来看P（Present）位：存在位。PDE与PTE的P位均位1时，物理页有效；其余情况，物理页不存在。这也解释了为什么PDE的第三行和PTE的第二行可以直接忽略。 在上一篇文章中，有一个关于0地址赋值的实验。0地址之所以不能赋值是因为它的PTE的P位为0，在我们修改了PTE的P位，并给它挂上一个物理页后，0地址遍可以赋值了。 R/W位 R/W = 0 只读 R/W = 1 可读可写 R/W很好理解，控制写的权限呗，这个位有何用呢？来看一个小实验。 c123456789101112131415#include \"stdafx.h\"int main(int argc, char* argv[]){ char* str = \"hello\"; printf(\"%x\", str); getchar(); *str = 'a'; printf(\"%s\", str); getchar(); return 0;} 来看这个代码，很明显，执行会是失败的，因为用char*定义的字符串，是会存储在常量区，而不是堆栈中了，又因为常量区的值是不允许修改的，因此 c1*str = 'a'; 这条语句会执行失败并报错。 那为什么常量区的内容就不可修改呢？其实，说白了，就是常量区挂着的物理页的R/W属性为0，因此只能读，不可写，既然知道了原因，我们只要修改了常量区所在物理页的属性，将R/W位置1即可。 通过printf语句先打印出所在常量区的线性地址，接着拆分跟进PDE和PTE中（具体步骤省略） 可以发现，PTE的R/W位值为0，因此将其修改为1写入，随后运行程序发现，可以成功修改字符串首地址出的字符！ P/S位 P/S（PageSize）位，只对PDE有意义，位于PDE的第7位。 PS = 1 PDE直接指向物理页，无PTE，低22位为页内偏移。线性地址只能拆成两段（10-22）：页的大小为2的22次方，也就是4MB，俗称“大页”，大页比较少，一般出现在高2G中 PS = 0 就是我们比较熟悉的10-10-12分页，页的大小为4KB U/S位 U/S（User/System）位，位于PDE/PTE的第2位。 U/S = 0：特权用户 U/S = 1：普通用户 三环程序是不能读写高2G内存的，原因在于高2G内存对应的物理页U/S位被置0了，也就是说只有特权用户才能读写高2G的内存。所以，当普通用户想要读取高2G内存时，就可以把U/S置1，这样就可以访问高2G内存了。 当然，理论如此，不过除了U/S位外，影响高2G内存读写的还有PCD位和PWT位，这部分内容也要到控制寄存器部分才能讲，所以第二种3环程序读写高2G实验（第一种是通过门提权），就要放到后面实现了，这里只要先记住，U/S位是影响访问读写权限的。 与R/W的区别这里需要注意一下U/S位与R/W位的区别，U/S位的读写控制是根据用户的级别，而R/W位的控制是直接控制读写，不管你是不是特权用户。 A位 A（Accessed）位于PDE/PTE的第5位：表示该物理页是否被访问（读或者写）过，访问过置1，即使只访问一个字节也会导致PDE，PTE置1。 D位 D（Dirty），脏位，是否被写过。0表示没有被写过，1表示被写过 总结以上是关于PDE/PTE部分属性的含义，还有一部分位没有涉及到，例如G位，PWT位，PCD位，这些需要讲到控制寄存器和TLB相关概念时再细讲。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"10-10-12分页","slug":"10-10-12分页","date":"2020-03-18T12:55:20.000Z","updated":"2020-03-19T13:43:58.205Z","comments":true,"path":"2020/03/18/10-10-12分页/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/18/10-10-12%E5%88%86%E9%A1%B5/","excerpt":"","text":"保护模式下内存管理方式分为两种，段与页。前面的篇章中，简要介绍了段的知识，今天就来和大家聊聊页的知识，页是保护模式中更为重要的一环，随着系统进入32-Bit，段的作用明显降低了，取而代之的则是在段的基础上，更为细分的页。 段与页 这是Intel白皮书中介绍关于段与页的概要图，经过段的学习，可以很容易的理解左半部分，这是一个根据所提供的有效地址（图中Offset）以及段寄存器中确定的基址，锁定线性地址空间中的某个线性地址（图中Lin.Addr.）的过程。而右半部分，则是利用了页的功能，通过拆分线性地址，一步步转化成了物理地址。 上述提到了3个概念，有效地址，线性地址以及物理地址，文字叙述会让人混淆，我们来看一条语句： Code1mov dword ptr ds:[0x12345678], 0x123 其中，0x12345678是有效地址 ds.Base + 0x12345678是线性地址 这都非常好理解，那什么是物理地址呢？考虑这样一个问题，掌握3环知识的小伙伴们知道每个进程都有4GB的内存空间，这时如果有一个进程A，给会进行一个操作，给ds.Base + 0x12345678赋值0x123，还有一个进程B，同样会给ds.Base + 0x12345678赋值0x123，那么ds.Base + 0x12345678处的位置到底是哪个值呢？还是两者都不是呢？这就涉及到了物理地址的概念。 PDT与PTT每个进程都有一个CR3的值，这很突兀，CR3是什么？实际之前在TSS切换时也用到了，具体等到了控制寄存器那会详细分析。简单来说，CR3被用来切换和定位当前正在使用的页表，它是一个32位的寄存器，其中高20位指向一个物理页（Windows系统上，一个页的大小是4KB，也就是4096个字节），如下图所示： 这图该怎么看呢？首先CR3会指向一个物理页，这个物理页又叫做页目录表（PDT），页目录表每个元素叫做页目录表项（PDE），页目录表项，每个4字节，所以一共有1024个页目录表项，CR3就好比一本书，PDT就是这本书的目录，PDE就是章节，这是一本有1024个章节的书（哇塞，真厚啊U•ェ•*U），这样就好理解多了。这是第一级。 页目录表项又指向一个第二级的表，叫做页表（PTT），页表的大小也是4KB，页表中的每个元素叫做页表项（PTE）。页表项可以理解为书中章节的每个小节，就好比第一章里面有1024个小节，这个小节就是PTE，这1024个小节加起来，构成一个小节表，就是PTT。 第二级介绍完了，第三级也就好理解了，既然书中每个章节的每个小节理解了，接下来就是页码了，每个小节都会对应书中的某个页码。而这个页码，就是相当于的物理页了。这样就可以理解这张图了，就是一部部找到物理页。 10-10-12分页Windows采用三种分页方式，在32位系统上主要有10-10-12分页和2-9-9-12分页这两种方式，在64位系统上增加了9-9-9-9-12这种分页方式，后面的文章会依次介绍32位下的两种分页方式。首先从10-10-12开始。 首先修改C盘的boot.ini文件，将noexecute改成execute，重启虚拟机，即可使用10-10-12分页方式 10-10-12分页是如何工作的呢？来看一个简单的程序： c123456789#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); return 0;} 这个程序很简单，给a赋值0x123，并查看a的地址 而这个地址0x12ff7c，实际上就是前文提到的线性地址，接下来我们将这个32位的地址按照10-10-12的方式进行拆分： 1.将0x12ff7c拆分成二进制：0000 0000 0001 0010 1111 1111 0111 1100 2.将这32位二进制数，按照10-10-12的方式组合： 每部分位数 二进制 十六进制 10 0000 0000 00 0 10 01 0010 1111 12f 12 1111 0111 1100 f7c 3.根据Cr3找到页目录表（PDT）中的页目录表项（PDE）： 首先在Windbg中执行!process 0 0指令，找到当前程序的Cr3，Cr3的值指向的就是页目录表的首地址。由于第一部分值为0，所以要查找的PDE，需要用Cr3+0*4(乘4是因为每个PDE大小是4字节)，这里注意一下，由于查找的是物理地址，所以使用的是!dd指令。 4.根据PDE找到页表（PTT）中的页表项（PTE）： 上一步已经找到了PDE，PDE的值指向的是某个PTT的首地址，方法和上一步一样，用PDE中的值+12f(拆分完的第二部分)x4，就可以得到PTE，这里要注意一点，将PDE中的值代入时，后12位置0，由于后12位为属性位，在查找的过程中不起作用 5.根据PTE确定物理地址： 确定PTE后，就剩最后一步了。由于一个物理页的大小本身就是4KB，也就是2的12次方，所以当确定了前20位后也就确定了物理页，因此我们要找的内容就在219da000这个物理页上的某个物理地址。这个物理页的范围是219da000~219dafff。现在可以理解，PTE指向的是一个物理页的首地址，根据最后12位的来确定，我们要寻找的值在物理页上的偏移，也就真正的找到了这个物理地址。 根据实验截图，发现我们一开始存在变量a里面的0x123，真正存的地方在0x219daf7c这个物理地址的位置，这就是通过线性地址一步步的找过来的，这些工作都是CPU做的，比如当我们读取a这个地址上的值是，CPU会通过分页机制读取该物理地址的值，然后再显示出来。 有趣的实验读错值了？有了10-10-12分页的知识，来做一个有趣的小实验 c1234567891011#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 0x123; printf(\"%x\", &a); getchar(); printf(\"%x\", *(&a)); getchar(); return 0;} 这个代码非常简单，一般人认为，会先输出a的地址，然后再输出0x123。但有了物理页的知识，我们就可以做一些手脚了。 很奇怪吧？为什么输出不是0x123，而却输出0x456呢？原因就在于，我们偷偷修改了变量的物理地址上的值，将原本的0x123改成了0x456，因此，CPU再次去物理页读取时，值已经发生了变化，读到了修改后的值。 0地址也能存值？c1234567891011121314#include \"stdafx.h\"int main(int argc, char* argv[]){ int a = 1; printf(\"%x\", &a); getchar(); *(int*)0 = 0x123; printf(\"address0: %x\", *(int*)0); getchar(); return 0;} 这是个显而易见运行会失败的程序，为什么？因为你给0地址赋值了，有点C/C++开发经验的人都知道，0地址是不能存值的，为什么？因为运行不过去啊！这不扯淡嘛！你看我就运行过去了！ 这又是为什么呢？其实0地址不能存值的原因是，没有给它挂物理页，既然没有物理页，那CPU按照分页去查的时候，就查不到了；那么只要给他挂个物理页，就可以给这个线性地址存值了，具体操作如下。 总结 一张页表能包含的物理页：1024*KB = 4MB 10-10-12分页共有1024张页表：1024*4MB = 4GB 前20位的值如果相同，那么一定在同一个物理页 一个PTE最多可以指向一个物理页；PTE可以没有物理页；多个PTE可以指向同一个物理页 参考资料：《Intel白皮书第三卷第四章》 参考教程：https://www.bilibili.com/video/av68700135?p=24","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务门","slug":"任务门","date":"2020-03-17T01:10:51.000Z","updated":"2020-03-17T03:46:00.956Z","comments":true,"path":"2020/03/17/任务门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/17/%E4%BB%BB%E5%8A%A1%E9%97%A8/","excerpt":"","text":"为何使用任务门之前任务段中提到，进行任何切换时可以还可以使用任务门。那么既然存在TSS段描述符了，为何还需要任务门呢？ 简要概括，任务门有如下优势： 任务门可以放在GDT表中，也可以放在IDT表中，还能放在当前线程的LDT表中，而TSS段描述符只能在GDT表中 任务门可以让低权限的线程进行任何切换，任务门的结构中也有DPL属性，当通过任务门去访问TSS描述符时，一旦通过任务门，TSS段描述符就不再进行检查了，即使你是个CPL=3的程序，而TSS段描述符的DPL=0，只要任务门DPL=3，就可以通过任务门完成任务切换，稍后会做这个实验。 由于任务门可以位于IDT表中，所以当遇到中断或者异常时，可以切换到独立的任务去处理异常 下面为不同表中，任务门进行任务切换的过程： 任务门描述符 任务门描述符的结构非常简单，真正用到的只有24位，属性位里：DPL一般设置为3，方便应用程序访问，Type则是固定的0101，TSS段选择子，顾名思义，就是一个段选择子，指向位于GDT表中TSS段描述符的位置。其余位均为保留位，置0即可。 任务门实现任务切换这一步十分简单，仅仅比使用TSS多了一个步骤而已，这里也不细讲了，直接上步骤。 首先，编译源文件，下断点，确定TSS的地址，根据地址构造TSS段描述符： 第二步，根据GDT表中构造好的TSS段描述符位置，在IDT表中构造任务门： 第三步，在Windbg中使用!process 0 0指令确定CR3的值，并填入自己的TSS中： 执行程序，获取到自己构造的TSS表数据，任务切换成功： 总结任务门总体还是比较简单，由于是通过int 0x20中断进入，因此iretd作为中断返回出来，比起JMP FAR还需要手动修改EFLAGS的NT位和previous task link容易的多。比较遗憾的是，这一部分的小作业，通过任务门进1环，还是失败了。这里稍微说一下我的思路，由于是进入1环（虽然windows没用1环），但我们让他进入1环，就替换1环的寄存器，ESP1和SS1，当然SS1和CS都需要设置CPL值为1，但是原本0环这两个段寄存器控制的都是DPL=0的段，因此我们需要构造一个1环的段描述符，我实验的时候构造了一个1环的非一致代码段描述符和一个1环的数据段描述符，让任务切换后的CS，SS载入段描述符信息用。同时还需要把TSS段描述符的DPL设置为1，其余值保持不变。可惜，几次都死掉了，实验没能成功，群内也没人这个进入1环的实验，以后有人讨论的话会考虑再试试。 任务段任务门这里有些遗憾吧，的确有点复杂，没理解透彻，感觉任务段那讲的也不是很清晰，希望以后我还能看得懂吧，接下来进入页的内容了，保护模式的关键来了，得掌握好。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"任务段","slug":"任务段","date":"2020-03-16T12:41:30.000Z","updated":"2020-03-16T17:07:35.399Z","comments":true,"path":"2020/03/16/任务段/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/16/%E4%BB%BB%E5%8A%A1%E6%AE%B5/","excerpt":"","text":"要点回顾在调用门、中断门与陷阱门中，一旦发生权限切换，那么就必有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。这时问题来了，我们知道EIP和CS的值都可以通过门描述符获得，那么ESP和SS是哪来的？这就是引出了今天的内容：TSS（Task-state segment），任务状态段。 TSS设计初衷想要学习一类知识，首先要了解它被设计出来的目的，这样就能找到方向，更好的了解它。CPU在运行时会频繁的切换任务，每次切换任务时，还没执行完的任务怎么办？总不能下次重新执行吧，于是需要保存上一个任务的上下文环境，于是，TSS诞生了，TSS是一块大小为104(0x68)个字节的内存，没错，TSS不是什么寄存器，就是一段内存，或者说是一个段，这段内存可以保存32-Bit下所有通用寄存器以及段寄存器的值，这样CPU就可以切换到新任务时，仍然保留上一个任务的环境，方便新任务执行完后，能够完好的回到先前的任务继续执行。 注意，TSS是一个段，有段就有段寄存器和段描述符哟！比如我们熟悉的CS，CS就是段寄存器，它描述的是代码段，同时，它会通过段选择子从GDT表的代码段描述符中载入段的相关信息，通常情况下，代码段的范围是0~FFFFFFFF（大小是4GB）；这样一对比，就可以理解了，TSS也是如此，因为TSS也是一个段（大小是104字节），所以应该存在一个描述TSS的段寄存器从一个段描述符里加载TSS相关信息。这就是今天会依次介绍的TR寄存器和TSS段描述符。 这里补充一点知识，尽管Intel设计TSS的初衷的为了方便任务切换（CPU层面叫做任务切换，操作系统层面叫做线程切换），但是Windows认为这个TSS设计的不好，因此并没有采用这个结构进行线程切换，并且Linux也没有采用TSS进行线程切换，这俩操作系统用的都是堆栈进行线程切换的。那么Windows用到了这个结构没有，当然是用到了，但仅仅用到了ESP0和SS0这两个值。 TSS结构先来看看TSS的结构 大部分都应该比较熟悉，这里介绍几个较为陌生的字段： Previous Task Link：这里保存的是上一个TSS的段选择子，比如任务发生了切换，新任务执行完后，如何才能找到先前未能执行完的任务呢？就得依靠这个值了（前面不是说了Windows不用TSS进行线程切换嘛，是呀，但是这里讲解的这个字段的作用，设计初衷就是为了任务切换） ESP0/SS0：当发生提权时，0环的ESP和SS的值就是从这里取的 CR3：有人会问，我哪知道取哪个TSS的ESP0和SS0呢？就是这个值的作用了，这个值帮我们确定当前位于哪个线程，之后在页的篇章中会学到CR3的相关内容。 LDT：这个值通常都是0，Windows没有用到LDT表，因为LDT表只对当前的线程有用 I/O Map：这个位置涉及到硬件IO了，值一般是固定的 TSS段描述符 TSS段描述符只能存在GDT表中，不能存到LDT或者IDT中，所以它的结构和之前介绍的段描述符是类似的，区别在于个别位的不同 G位：在代码段/数据段描述符中，这个位置通常位1，因为这两个段的范围通常是4GB，而TSS的大小是104字节，单位是字节，因此这个值为0 Type域：这个值为1011或1001，其中B位是Busy位，置1时说明该TSS是否被载入或者嵌套，载入说明CPU正在执行该任务；嵌套则表明该任务处理了一半，切换到了另一个任务中去，但该任务并未执行完。 Base/Limit：Base确定TSS段的起始位置，Limit确定TSS段的大小，Base~Base+Limit就是TSS段的范围。 TR寄存器在一开始的探究段寄存器的文章中提过，CPU共有8个段寄存器，TR就是其中之一。先前提到过，TR寄存器的工作原理和其它段寄存器一样，通过段选择子加载GDT表的TSS段描述符中的信息，方便CPU找到TSS的位置，具体工作原理如下： 这里介绍两个操作TR段寄存器的指令LTR和STR： LTR：这是一个特权指令，只有0环的程序才能调用；作用是将段选择子写入TR寄存器 STR：STR不是特权指令，这个指令3环程序也可以调用，所用是读取TR寄存器的值 需要注意的一点，修改TR寄存器的值，只是会载入新的TSS段描述符信息，并不会对修改前的TSS段造成影响。 实现任务切换虽然说了Windows并没有将TSS用来进行线程切换，但是我们仍然可以手动实现任务的切换。 直接修改TR寄存器是不能做到任务切换的，但是可以通过JMP FAR或者CALL FAR来加载TSS段描述符来实现。下面分别使用两种方法来实现（两种实现方法细节有很多差别） 一般情况下，任务切换发生在下列四种情况之一： 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表中的TSS段描述符 当前程序，任务或者进程执行JMP/CALL语句，且参数是位于GDT表或者当前LDT表中的任务门描述符 一个中断或者异常触发了在IDT表中的任务门描述符 当前任务执行IRET指令，且EFLAGS寄存器的NT位为1时 CALL FAR实现本次CALL FAR实现采用第一种任务切换的情况。 设计一个TSS，存储任务切换时必要的信息，其中包括ESP0，SS0，CR3，EIP，ESP，段寄存器，位图控制。 ESP0：也就是任务切换后的堆栈，可以自己创一个空数组，然后写入数组的首地址，就可以作为堆栈使用。 段寄存器及SS0：这些值，在0环通常都一样，可以进入Windbg参考其它TSS的值，这里使用的是SS/SS0 = 0x10，ES/DS = 0x23，CS = 0x8，FS = 0x30，GS = 0x0 EIP：这就是要跳转后执行的地方，可以写一个裸函数来验证是否切换成功，直接取裸函数地址即可，我这里的值为0x401020（每个人机器可能不一样） CR3：这个值，需要在执行前，中断到Windbg寄存器中，通过!process 0 0指令获取。 位图控制：这是一个默认值为0x20AC0000 构造完的TSS如下： c12345678910111213141516171819202122232425262728DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; 然后我们需要根据这个TSS的地址，来构造我们的TSS段描述符 地址为0x12fd70 因此TSS段描述符为：0000e912`fd700068，e->DPL=3：是为了3环的程序可以访问这个段描述符，0x68就是104字节，9说明未被载入。然后让我们填入段描述符 接着运行程序，需要采集Cr3的值，先中断到Windbg，再通过!process 0 0指令获取，取最后的一个值 在程序中填入cr3的值后回车，发现可以成功取到任务切换后ESP，CS，SS，并且均为我们设定的值，实验成功。 完整代码如下： c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include \"stdafx.h\"#include int saveEax, newESP;short newCS, newSS;__declspec(naked) void Get_Value() { __asm { mov saveEax, eax mov newESP, esp mov ax, cs mov newCS, ax mov ax, ss mov newSS, ax mov eax, saveEax iret }}int main(int argc, char* argv[]){ char stack[100] = {0}; char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; int Cr3 = 0; printf(\"Input: \"); scanf(\"%x\", &Cr3); getchar(); DWORD tss[0x68] = { 0x00000000, //Previous Task Link (DWORD)stack, //ESP0 0x00000010, //SS0 0x00000000, //ESP1 0x00000000, //SS1 0x00000000, //ESP2 0x00000000, //SS2 (DWORD)Cr3, //Cr3 0x00401020, //EIP 0x00000000, //EFLAGS 0x00000000, //EAX 0x00000000, //ECX 0x00000000, //EDX 0x00000000, //EBX (DWORD)stack, //ESP 0x00000000, //EBP 0x00000000, //ESI 0x00000000, //EDI 0x00000023, //ES 0x00000008, //CS 0x00000010, //SS 0x00000023, //DS 0x00000030, //FS 0x00000000, //GS 0x00000000, //LDT 0x20ac0000 //IO_MAP }; _asm { call fword ptr buffer } printf(\"ESP: %x, cs: %x, ss: %x\", newESP, newCS, newSS); getchar(); return 0;} 以上是通过Call Far实现的任务切换。还有另一种方法，是通过JMP FAR来实现，而且JMP FAR实现会更加困难一些。这里简要概括一下，当使用CALL FAR时，CPU会自动帮你用当前任务的段选择子填写你TSS的Previous Task Link字段，同时给你的Eflags的NT位置1，这个NT位有什么用呢，就是关系到iret这个指令的意义，当Elfags的NT为1时，iret表示根据Previous Task Link的值，从当前任务返回到前一个任务中去，当NT为0时，这是一个中断返回指令。而当你使用JMP FAR实现时，你需要手动给Pervious Task Link字段赋上前一个任务的段选择子，此外你需要手动给Eflags的NT位置1，当然这可以通过 Code12345pushfdmov eax, [esp]or eax, 0x4000mov [esp], eaxpopfd 来实现，此外，还需要确保前一个TSS段的段描述符Busy位的值为1，这样才能确保该任务处在嵌入的状态。 总结这是开博客以来，最艰难的一篇了，看视频楞是没看明白，然后又去翻Intel白皮书，看明白了然后开始代码实现，CALL FAR的任务切换实现的还算顺利，但是JMP FAR的问题就比较大了，一下午都没整出来，蛋疼啊~ 不想再弄了，看了群友的代码，感觉自己好像也没写错，就是一直死。明天打算整一整任务门吧，完了就到页的知识了，那边掌握的还算不错，可以轻松一阵子了，坚持呀！ 参考资料：《Intel白皮书卷3-第七章》","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"陷阱门","slug":"陷阱门","date":"2020-03-15T08:31:07.000Z","updated":"2020-03-15T10:56:29.726Z","comments":true,"path":"2020/03/15/陷阱门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/15/%E9%99%B7%E9%98%B1%E9%97%A8/","excerpt":"","text":"这一篇来说陷阱门，陷阱门这东西，就没什么好讲的，应该Windows几乎没怎么用，陷阱门也是位于IDT表里的，列出前48个描述符，就没有陷阱门。。。 陷阱门描述符 看图，陷阱门描述符，和中断门描述符，就1个位不一样，中断门的Type域是1110，陷阱门是1111 代码实现代码实现也和中断门的完全一样，搬过来就行了。 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 与中断门的差别那可能有人要问了，既然陷阱门和中断门完全一样，有什么存在的意义。那还是有一点不同的，来看两次执行的结果： 同样的代码，执行结果不同，可以发现，陷阱门和中断门的区别在于，中断门执行后EFLAG寄存器的值发生了改变，而陷阱门不会改变EFLAG，这就是陷阱门和中断门的差别。 EFLAG寄存器结构 根据EFLAG寄存器的结构可以得知，中断门执行后，将IF位置0了，但陷阱门不会，这就是中断门和陷阱门的唯一区别。 那么这个IF位有什么用呢？为什么陷阱门要将IF位置0呢？ 稍查资料，可以了解到IF标志是用于控制处理器对可屏蔽中断请求的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。IF标志对不可屏蔽中断没有影响。 这里举个简单的例子说明下什么是可屏蔽中断，什么是不可屏蔽中断。打开任务管理器，可以看到有很多进程正在运行，这时候，你想把电脑锁屏，于是按下Win+L，这个时候键盘会向CPU发送一个可屏蔽中断，告诉CPU，用户按下了Win+L键，需要执行锁屏功能，如果此时EFLAG的IF位为1，这是CPU会短暂放下手上的任务，先去处理你的锁屏任务，处理完后，你的电脑锁屏了，CPU会继续运行刚刚处理的进程；如果此时ELFAG的IF位为0，那么CPU就和没听到一样，继续做它自己的事。如果遇到意外状况，电脑的电源线拔了下来，断电了，这时电源会向CPU发送一个不可屏蔽中断，这个中断不受IF位影响，CPU一定会去处理。这时有人会问了，断电后CPU还怎么工作？其实在主板上，是有电容的，可以在断电后让CPU再去做一些清理工作，这就是不可屏蔽中断。 总结中断门和陷阱门的唯一区别：中断门执行时，将IF位清零，但陷阱门不会。 参考教程：https://www.bilibili.com/video/av68700135?p=20","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"中断门","slug":"中断门","date":"2020-03-15T06:26:54.000Z","updated":"2020-03-15T08:13:54.134Z","comments":true,"path":"2020/03/15/中断门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/15/%E4%B8%AD%E6%96%AD%E9%97%A8/","excerpt":"","text":"上一篇提到过，Windows是不使用调用门的，所以在GDT表里没有找到调用门，那么Windows如何实现代码跨段，提权等行为呢？这里用的较多的是中断门，接下来就来介绍一下中断门。 IDT表与GDT的区别首先要提到IDT表（中断描述符表），在上一篇提到的调用门的门描述符，都在GDT表里，而中断门的门描述符在另一张叫做IDT的表里面。同GDT一样，IDT也是由一系列描述符组成的，每个描述符占８个字节。但需要注意的是，IDT表中的第一个元素不是NULL。 在Windbg中查看IDT表的基址和长度： IDT的构成IDT表可以包含3种门描述符： 任务门描述符 中断门描述符 陷阱门描述符 中断门执行流程有了IDT表的概念后，咱们就可以开始讲讲中断门的执行流程，实际上和调用门差别不是很大，可以类比的来看： 执行调用门的指令：CALL CS:EIP，其中CS是段选择子，包含了查找GDT表的是一个索引. 执行中断门的指令：INT N，其中N是IDT表的一个索引 执行流程就只有这个差别，当CPU通过N这个索引在IDT表中找到了中断门描述符后，执行的步骤就和调用门的步骤完全一样了，可以参考调用们的执行流程。这里要注意一点，当找到中断门描述符后，还是会通过描述符里的段选择子，去GDT表中找需要跳转的代码段。所以说中断门的执行会查找两张表，先查找IDT表，再查找GDT表。 中断门描述符简要说完了IDT表（实际上和GDT表没啥差别）来看看中断门描述符的结构： 粗略一看，和调用门描述符没差呀。这不就是无参调用门描述符换了个Type域嘛。没错，的确是这样（这里解释下D位，可以理解为段描述符的DB位，置0时为16位中断门，置1时为32位中断门）。当你发现这点时，说明调用门的结构你理解清楚了。因此结构不再赘述，可以参考调用门 中断返回与调用门使用长返回RETF不同，中断门使用中断返回指令：IRET/IRETD INT N指令： 在没有权限切换时，会向堆栈压入3个值，分别是CS，EFLAG，返回地址 在有权限切换时，会向堆栈压入5个值，分别是SS，ESP，EFLAG，CS，返回地址 这也是与调用门不同的地方，中断门会多压入一个值。于是有小盆友就要问啦，“死肥宅哥哥，为什么中断门会多压入一个参数呢？” 这还不明显吗，你想想人家调用门为什么要压入值进入堆栈啊？肯定是这些值会改变啊，所以要用堆栈保存一下，等长返回的时候，再还原状态；中断门多压入了一个EFLAG说明通过中断门跨段时，EFLAG的值会变啊！ 所以，在中断门中，不能通过RETF返回，而应通过IRET/IRETD返回，其实只要改改堆栈，就可以通过RETF返回中断门，IRETD返回调用门。 代码实现中断门比较简单，这里演示一个实现的范例 c123456789101112131415161718192021222324252627282930313233343536#include \"stdafx.h\"int saveEax = 0;short cs3, ss3;int eflags3, eflags0, esp3;__declspec(naked) void GetValue() { _asm { mov saveEax, eax pushfd mov eax, [esp] mov eflags0, eax popfd mov eax, [esp+4] mov cs3, ax mov eax, [esp+8] mov eflags3, eax mov eax, [esp+0xc] mov esp3, eax mov eax, [esp+0x10] mov ss3, ax mov eax, saveEax iretd }}int main(int argc, char* argv[]){ _asm { int 0x20 } printf(\"cs3: %x, eflags3: %x, esp3: %x, ss3: %x\\n \\teflags0: %x\", cs3, eflags3, esp3, ss3, eflags0); getchar(); return 0;} 根据GetValue函数的地址构造中断门描述符，然后填入中断门里即可 执行结果如下： 然后我们用int 3中断到Windbg里验证一下 验证成功。 总结通过调用门与中断门的对比，来总结一下中断门： 调用门通过CALL FAR指令执行，但中断门通过INT指令 调用门查询GDT表，中断门查询IDT表（后续也会再查询GDT表） CALL CS:EIP中的CS是段选择子，由3部分组成，而INT N指令中的N只是索引，中断门不检查RPL，只检查CPL 调用门可以有参数，但中断门没有参数 参考教程：https://www.bilibili.com/video/av68700135?p=19","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"调用门","slug":"调用门","date":"2020-03-14T06:34:21.000Z","updated":"2020-03-15T08:09:52.571Z","comments":true,"path":"2020/03/14/调用门/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/14/%E8%B0%83%E7%94%A8%E9%97%A8/","excerpt":"","text":"前一篇中提到CALL FAR指令最终跳转的地址是调用门里，今天就要分析一下调用门。首先从调用门的执行流程开始 调用门执行流程指令格式：CALL CS:EIP(EIP是废弃的) 执行步骤： 根据CS的值查GDT表，找到对应的段描述符，这个描述符是一个调用门。 在调用门描述符中存储另一个代码段的选择子 选择子指向的段的Base+调用门里的Offset，就是真正要执行的地址 光看描述，的确很难懂，结合调用门描述符来分析，会好理解很多 调用门描述符 高4字节8~15位：这是和普通段描述符完全一样的8位，其中第12位是判断该描述符是系统段还是数据段或代码段的位置，调用门描述符是系统段，所以此处值一定是0。接下来的Type域，这个根据段描述符那章中也能找到，32位的调用门描述符，Type域为1100，这也是确定的。 高4字节的高16位+低4字节的低16位：这两块区域加起来刚好是32位，构成一个Offset，也就是调用门执行流程第三步里Base加上的Offset，那么Base哪里拿呢？ 低4字节的高16位：这16位是一个段选择子，有段选择子，就可以拆分，于是RPL，TI，Index都能解析出来，这时候就可以根据Index去GDT表里找到段描述符，而这个段，就是调用门跳转的段，因此要用这个段的Base+Offset便可获得真正要执行的地址。 高4字节的低5位(第5~7位均为0)：这5位的作用是描述调用门传进去的参数，调用门是可以传参的，而参数的个数，决定了这个位置的值 下面，通过代码来验证调用门的执行流程。 无参调用门调用门分为无参和有参（示例默认都提权）两种情况，这里先用无参调用门进行实验： 构造调用门因为Windows是不使用调用门的，所以需要自己构造一个调用门：0040EC00 00081010 为什么要这样构造呢？先看最熟悉的那8位，EC = 11101100，P=1，S=1，调用门=1100，DPL为啥选取3呢。首先，调用门的提权在于通过调用门后，新的段选择子会修改CS达到CPL的提权，但是访问调用门描述符还是需要保证CPL=DPL，因此，DPL需要设置为3。由于无参调用门，也就没参数，因此参数位为0，EC00也就解释清了。 接下来看0008，这个也很好理解，段选择子嘛，拆分一下，RPL=0，Index=1，我们去Windbg里看一下就好了 这下就清晰了，指向00cf9b00 0000ffff这个段描述符，拆分一下，Limit=FFFFFFFF，G=1，Base=00000000，是个非一致代码段。看来想要跳转成功，也得是0环的代码段才行。 由于Base为0，那么跳转到的地方就是0+401010，那这个401010是哪来的呢？这得看代码才能说清。 代码实现c12345678910111213141516171819202122232425262728293031323334353637383940#include \"stdafx.h\"int saveEax = 0;short oldCS = 0;short newCS = 0;short oldSS = 0;short newSS = 0;int oldESP = 0;int newESP = 0;__declspec(naked) void GetValue() { __asm { mov saveEax, eax lea eax, [esp] //new esp mov newESP, eax mov eax, [esp+8] //old esp mov oldESP, eax mov eax, [esp+4] //old cs mov oldCS, ax mov ax, cs mov newCS, ax mov eax, [esp+0xc] //old ss mov oldSS, ax mov ax, ss mov newSS, ax mov eax, saveEax retf }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { call fword ptr [buffer] } printf(\"%x, %x, %x, %x, %x, %x\", oldCS, newCS, oldSS, newSS, oldESP, newESP); getchar(); return 0;} 来看一下代码，从main函数开始看起，我们自己构造一个CS:EIP（EIP已废弃）的6字节char型数组，然后在汇编中执行CALL FAR调用我们构造的CS:EIP，接着打印部分内容。 可以看出执行调用门的语句嵌入了汇编里，根据上方在构造调用门时的分析可以得出，最终调用门跳转的地址会是401010，那么这个401010是怎么来的呢？其实就是GetValue函数的地址，我们知道通过调用门后会跳转到一个地址，但是如何才能检测成功跳转并提权呢？就得有一个函数来收集这些信息并将其打印出来，也就有了GetValue函数（GetValue地址通过VC下断点查看，然后写入构造的调用门描述符中）GetValue要声明成裸函数，这样堆栈只需自己平衡，可以避免元素访问的位置过远。 根据前一篇文章的内容，如果跨段并提权，堆栈内部大致情况如下 因此，这里采用通过全局变量，来依次读取堆栈不同位置的值，并打印查看结果。 由结果看，ESP，CS，SS均发生了切换，且CPL变为0，ESP的值也变为了一个高2G的数 为了验证结果的正确性，我们可以通过中断再看一下0环的堆栈结构，将裸函数中的汇编代码清除，只留下int 3和长返回语句如下： Code1234_asm { int 3 retf} 然后重新执行，会中断到Windbg（为什么会从虚拟机中断到Windbg，这个到后面中断部分会详细讲解）查看栈顶部分内存 注意：这里的栈顶esp的值和刚刚不一样是因为程序重新执行了，进入0环时，ESP和SS是TSS给的，而TSS内的值是当前线程给的，因为代码修改了，所以重新执行程序时，线程不一样了，所以0环的堆栈也就不一样了。但是3环的数据是没有变的（理论上也是会变的，这里没变是因为编译器的优化），对比刚刚手动读取的结果来看，3环的ESP，CS，SS完全一致，说明刚刚调用门的实验成功提权进入0环。 有参调用门无参说完了，接下来是有参调用门，有参调用们和无参的区别在于仅仅是参数位的值会有所变动，栈里多了push进去的参数，其余和无参基本上相同。 构造调用门 这里构造的调用门描述符是：0040EC03 00081020，（地址变成了401020，是因为我重启了下虚拟机所以GetValue函数地址变了，并不影响），需要注意的是参数位设置成了3，因为这次计划传入3个参数进去。 代码实现由于Push了参数进去，所以不确定参数在0环堆栈中位于什么位置，于是先用int 3的方法，在Windbg中查看一下堆栈的情况 图中可以发现，在压入参数的调用门进入0环后，参数位于3环ESP和3环CS中间的位置，堆栈表示大致如下： 这样，就可以来编写代码了，总体和无参的差距不大。 c1234567891011121314151617181920212223242526272829303132#include \"stdafx.h\"int saveEax = 0;int para1, para2, para3;__declspec(naked) void GetValue() { __asm { mov saveEax, eax mov eax, [esp+8] mov para3, eax mov eax, [esp+0xc] mov para2, eax mov eax, [esp+0x10] mov para1, eax mov eax, saveEax retf 0xc }}int main(int argc, char* argv[]){ char buffer[6] = {0x0, 0x0, 0x0, 0x0, 0x4B, 0x0}; __asm { push 1 push 2 push 3 call fword ptr [buffer] } printf(\"%x, %x, %x\", para1, para2, para3); getchar(); return 0;} 需要注意一点，这里由于push了3个参数，所以长返回的时候要用RETF 0xc来平衡堆栈，否则直接中断到Windbg，要是不处理的话就蓝屏了。 代码执行效果如下，成功在0环堆栈取到了push进入的参数。 总结 当通过门，权限不变时，只会PUSH两个值：CS和返回地址，新的CS的值由调用门决定 当通过门，权限改变的时候，会PUSH四个值：SS，ESP，CS，返回地址，新的CS由调用门决定，新的SS和ESP由TSS提供 通过门调用时，要执行哪行代码由调用门决定，但使用RETF返回时，由堆栈中压入的值决定，也就是说，进门时，只能按指定路线走，出门时，可以翻墙（只要改变堆栈里面的值就可以想去哪去哪） 可不可以再建个门出去呢？也就是用Call，当然可以。 参考教程：https://www.bilibili.com/video/av68700135?p=17","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"长调用与短调用","slug":"长调用与短调用","date":"2020-03-14T01:29:45.000Z","updated":"2020-03-14T06:15:50.000Z","comments":true,"path":"2020/03/14/长调用与短调用/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/14/%E9%95%BF%E8%B0%83%E7%94%A8%E4%B8%8E%E7%9F%AD%E8%B0%83%E7%94%A8/","excerpt":"","text":"在上一篇章中提过，实现跨段的跳转，可以使用JMP FAR指令，但是想要实现跨段的调用，就需要学习一个新的指令CALL FAR；CALL FAR指令要更为复杂一些，原因是JMP指令是不影响堆栈的，而CALL指令会影响堆栈。 短调用首先来回顾下短调用，短调用其实就是普通的CALL调用，是相对于CALL FAR而言，所以叫做短调用。短调用会影响EIP寄存器和ESP寄存器，因此在返回时需要额外去平衡一下堆栈；短调用属于三环知识，这里不再赘述，具体的调用和返回时的堆栈变化如下图所示： 长调用（跨段不提权）长调用分为提权和不提权两种，这里先讲不提权的情况。 这图看不明白没关系，一个个分析。首先，EIP为什么是废弃的？因为，这个长调用指令，压根不会跳转到你给的EIP的位置，而是会跳转到调用门里提供的地址。那什么是调用门呢?下一篇会具体提到， 这里简单概括调用门就是一种位于GDT表里特殊的描述符。 回到长调用这里，当CALL执行后，与一般的调用指令不同，长调用使得堆栈提升了8个字节，除了返回地址外，还压入了调用者的CS，以便在调用返回至原来程序时，CS也能得到恢复。其中返回地址依然是位于[esp]处，调用者的CS位于[esp+4]处。 长调用返回也与普通调用不同，普通调用使用ret指令即可返回到原来程序的位置，而长调用返回时需要使用长返回指令RETF，长返回指令除了会将返回地址送入EIP寄存器，还会将CS恢复至执行前的状态，同时平衡堆栈。 长调用（跨段并提权）不提权的长调用还稍微好理解一点，提权的长调用，就稍微有些复杂了，由于发生了提权，CS的CPL发生了改变，根据Intel的规定，CS和SS的CPL一定要保持一致，所以此时SS的值也会发生改变，除此之外，因为发生了提权，堆栈从3环的堆栈变为了0环的堆栈，因此ESP也会发生改变。所以提权的长调用会4个寄存器的值发生改变，分别是EIP，CS，ESP，SS，来看一下执行前后的变化 提权后，分别将返回地址，调用者CS，ESP，SS压入了0环的堆栈中，这样在返回3环时，可以确保这些寄存器恢复到原本的状态。 同样，提权后返回用的也是RETF，长返回指令，分别将返回地址，调用者的CS，ESP，SS压入相应的寄存器中，大致如下： 总结长调用相较长跳转更为复杂，这篇只是做个简单的介绍，在后面的篇章中，将通过分析调用门的实现过程来详细讲解长调用，这里对本篇提到的几个特点做些总结。 跨段调用时，一旦有权限切换，就会切换堆栈 CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样 JMP FAR只能跳转到同级非一致代码段或者共享段，但CALL FAR可以通过调用门提权，提升CPL的权限 参考课程 : https://www.bilibili.com/video/av68700135?p=16","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"代码跨段跳转（不提权）","slug":"代码跨段跳转","date":"2020-03-13T02:24:36.000Z","updated":"2020-03-13T15:47:09.308Z","comments":true,"path":"2020/03/13/代码跨段跳转/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/13/%E4%BB%A3%E7%A0%81%E8%B7%A8%E6%AE%B5%E8%B7%B3%E8%BD%AC/","excerpt":"","text":"之前的篇章中提到过，除了CS段寄存器外，均可使用MOV或LES,LSS,LDS,LFS,LGS指令进行修改；为什么CS不可以直接被修改呢？ CS是代码段的段寄存器，CS的改变意味着EIP的改变，所以无法使用上述指令进行修改 代码跳转指令代码的跳转指令分为2种，一种是同时修改CS和EIP的指令，另一种，只修改EIP指令，具体如下： 同时修改CS和EIP：JMP FAR/ CALL FAR / RETF / INT / IRETD 只修改EIP：JMP / CALL / JCC / RET 本篇用到的是JMP FAR指令。 JMP FAR指令：和普通的JMP指令不同，JMP FAR实际是在JMP指令后写上6个字节，例如 JMP 0x4B: 0x00401456的形式。 其中0x4B是段选择子，0x00401456是跳转地址。 若能成功执行，0x4B会写入CS中，0x00401456会写入EIP中，代码发生跳转。 代码跳转流程JMP 0x20:0x004183D7 CPU如何执行这行代码? 段选择子拆分0x20 对应二进制 0x0000 0000 0010 0000 RPL：00 TI：0 Index：4 查表得到段描述符 TI = 0 所以查GDT表 根据Index = 4 找到对应的段描述符 四种情况可以跳转：代码段、调用门、TSS任务段、任务门（其中调用门，TSS任务段以及任务门，都属于系统段） 之前段描述符的篇章提到过，可以根据段描述符的属性判断属于哪个段，通过看属性的那16位：由于代码段和数据段的S位值为1，所以一般第12-15位为字节9/F，而代码段的Type域的第1位为1，所以代码段的Type域一定大于等于8。因而判断代码段描述符的第8-15位通常在98-9F或者F8-FF这个范围内。 权限检查权限检查分为非一致代码段和一致代码段两种情况，下面我们分别来看 非一致代码段非一致代码段，要求：CPL == DPL 并且 RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（下）","slug":"一次简单的Hook-下","date":"2020-03-12T07:38:30.000Z","updated":"2020-03-12T15:23:43.627Z","comments":true,"path":"2020/03/12/一次简单的Hook-下/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/12/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8B/","excerpt":"","text":"前一篇已经完成了对GetMsgAbstract函数的分析，发现，当执行到GetMsgAbstactByElement这一步时，已经可以根据寄存器用来传递的参数获取聊天内容，这篇来根据分析的内容编写用来Hook的dll。 Inline Hook这里先对Inline Hook做个简要概述，它是一种通过修改指令的方法，转移程序的执行流程，在程序执行某函数前或者某函数后，先执行你定义的Hook函数，拿到需要的参数信息，再根据需要对参数信息进行加工，从而完成Hook。常见的手法如下： Code11. jmp xxxxxxxx (5字节) Code12. push xxxxxxxx/retn (6字节) Code13. mov eax, xxxxxxxx/jmp eax (7字节) Code14. call Hook 根据需求不同，替换掉原本的指令长度不同，从而选择的手段也不同；本篇中采用6字节的方式 构建DLL一般构建一个dll要分别去编写头文件，C/C++源文件以及入口点函数。首先我们先从头文件开始。 头文件 打开Visual Studio，新建一个动态链接库(DLL)项目，VS会自动帮忙生成头文件和源文件，点击头文件stdafx.h开始编写 其实VS已经帮忙生成好了大部分，只需要定义自己需要实现的函数和方便自己使用的宏即可 这里为什么不写成下面这种形式呢？ c1__declspec(dllexport) BOOL WINAPI Msg_Hook(); 因为这个dll的主要作用是hook，并不需要有导出函数，即使有了被我们hook的程序也不会主动去调用（因为它的代码里面根本没有调用我的dll的代码），所以干脆就不写了，没什么影响。 入口点函数VS帮我们生成好的入口点函数如下： 在这里其实只需要把刚刚定义的函数，写在DLL_PROCESS_ATTACH的地方即可，因为在dll加载到进程时，会先调用入口点函数，传入的参数则是DLL_PROCESS_ATTACH，这样就可以调用我们的Hook函数了。 源文件源文件的编写是比较关键的一步，主要功能的实现都在这里。首先，我们需要实现Hook用的函数。 Hook函数 首先编写一个大致的框架，来分析一下都做了些什么，还缺一些什么。 Inline Hook的核心在于修改指令，从而实现程序流程的转移。具体的流程就是，找到需要修改的位置，修改当前位置的指令。 修改指令的大小这里采用的是push xxxxxxxx/retn的手法，所以需要创建一个6个字节的char型数组。 修改的位置修改的位置如何确定？之前在OD分析反汇编程序时，确定在调用GetMsgAbstractByElement之前就可获取到消息内容，发现，调用这个函数的call语句加上之前的push eax，刚好6个字节，这就是Hook点了 这个位置位于KernelUtil.dll中，所以我们可以补充第三条语句改成如下： Code1DWORD modify_addr = (PROC)GetModuleHandle(\"KernelUtil.dll\") + EntryOFFSET; 同时也可以根据基址确定EntryOFFSET并写在开头。 如何修改？这里采用Windows提供的ReadProcessMemory和WriteProcessMemory这两个函数，参数非常好理解，当前进程，需要修改的地址位置，修改的字节，修改字节的长度以及一个可以忽略的参数。在读的时候，指定位置的指定大小的字节会被保存进定义的char型数组里，写的时候就是把修改后的字节写回原来的地址。那我们要如何确定该写什么呢？ 根据push xxxxxxxx/retn指令，可以确定第一个字节和最后一个字节分别为0x68和0xC3。中间的4个字节填什么？就是执行我们做手脚的函数地址了。Hook函数的作用就是转移程序执行的流程，将程序转移到我们自己定义的函数，我们自己的函数就可以对当前的程序做些手脚，比如读取函数接收的参数，并将其传递出来。 目前为止，经过分析，可以进一步完善源程序。 接下来，就来编写自己的函数，将消息内容传递出来。 功能函数功能函数其实就是用汇编写一个裸函数，为啥要用裸函数？这样的话，编译器就不会自动帮我们生成如下这三行指令： Code123push ebpmov ebp, espsub esp, 0x20 而是我们自己平衡堆栈，所以就可以避免很多额外的偏移造成的麻烦，经过上一篇的分析已知，当函数到达GetMsgAbstractByElement的位置处时，可以通过[[ebx+0x28]]+0x18获取消息内容。那就可以采用一下方式： Code123456pushadpushfdmov eax, [ebx+0x28]mov eax, [eax]mov eax, [eax+0x18]mov Msg, eax 这样只要在外部定义一个变量Msg，即可将消息取到，然后可以利用OutputDebugString将消息内容输出到DbgView里观察。 但这还没有结束，因为之前覆盖掉了GetMsgAbstractByElement，所以这次需要重新再调用一遍。所以我们需要获取GetMsgAbstractByElement的地址，先通过当前地址和基址相减算出偏移0xBE0B0，然后通过KernelUtil.base+Offset确定函数的地址。这时只需要在平衡堆栈后的地方，补上之前替换掉的6个字节即可。 最终功能函数实现如下： 实验结果我们使用OD，将编写的dll注入进去 注入后此处代码发生了变化 观察DbgView，发现成功拿到消息内容","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"第一周","slug":"第一周","date":"2020-03-11T12:40:24.000Z","updated":"2020-03-11T12:49:59.321Z","comments":true,"path":"2020/03/11/第一周/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/11/%E7%AC%AC%E4%B8%80%E5%91%A8/","excerpt":"","text":"今天是开博客的第七天，说满意其实也不是很满意，进度还是很慢的，当然计划也是长远的。一个是希望能坚持下来，也很久没坚持做一件事了；另一个是希望能够在4个月左右的时间，将所涉及的三个领域的基础知识，真正的掌握了，希望自己能真正尽力。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://cataloc.gitee.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"段权限检查（数据段）","slug":"段权限检查","date":"2020-03-11T01:55:19.000Z","updated":"2020-03-11T07:54:44.536Z","comments":true,"path":"2020/03/11/段权限检查/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/11/%E6%AE%B5%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5/","excerpt":"","text":"访问违例问题在介绍内容前，先看两个程序 两个程序的差异仅仅在于段选择子的不同，结果则是一个访问成功另一个访问违例了。分别对两个段选择子进行拆分： Code10023 = 0000 0000 00100 0 11 RPL：3 Index : 4 Code1002B = 0000 0000 00101 0 11 RPL：3 Index : 5 可以看出，两个段选择子的差别仅在Index的不同，也就是指向的段描述符不同，再来看看两个段选择子对应的段描述符 注意：由于Index是从0开始算的（和数组一样），所以对应的实际上是表中第五个和第六个段描述符。 根据之前段描述符属性的内容，来查看属性位，分别为： Code1Attr: CFF3 DPL:3 Code1Attr: 008B DPL:0 可以发现，两个段描述符的DPL不同，之前在段选择子的篇章中提到过，在将段选择子指向的段描述符加载到段寄存器时，一定要保证数值上（RPLDPL。那为什么RPL>DPL就会出错呢？下面来逐步解析。 CPU分级先来了解一下CPU分级 CPU共划分了4个等级，Ring0~Ring3，其中Ring3级别最低，Ring0级别最高。这个分级是CPU划分的，并不是操作系统所划分的，操作系统只是使用了这个分级，其中Windows系统只用了Ring3和Ring0两个等级，分别表示应用级和系统级。应用级的程序往往不能访问系统级，所以保护模式不仅仅是防止段的胡乱访问，还保证了程序在相应的级别稳定的运行。 CPLCurrent Privilege Level，当前特权级，之前段选择子篇章中讲过，段选择子的后2位的值为RPL，而CPL指的CS或SS中的段选择子的后2位（CS/SS的后两位一定是相同的，所以无论用哪个作为CPL都一样），也就是说CS或SS的RPL就是当前程序的CPL。 下面来查看两个CPL： 随便拖一个程序进入OD，根据CS/SS可以算出当前程序的CPL为3。因为这些程序都是Ring3的程序。 按Ctrl+Break在Windbg中断下，查看寄存器，可以发现当前CPL为0。因为Windbg在调试系统时执行的都是内核函数，所以处在Ring0。 DPL Descriptor Privilege Level：描述符特权级别。在段描述符属性那一篇中解析DPL时提到过，在段描述符高4字节的第13~14位就是DPL，那么DPL到底有什么用呢？和CPL有什么关系呢？ DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么。 通俗的理解：如果你想访问我，那么你应该具备什么特权。例如： Code1mov ds, ax 如果ax指向的段DPL = 0 但当前程序的CPL = 3 这行指令是不会成功的，因为CPL = 3是应用层，权限较低，是不能访问DPL = 0的系统层的；这也是为什么之前的例子中会出现访问违例。 RPLRequest Privilege Level：请求特权级别 有小盆友可能会问了，既然已经有CPL和DPL，那只要CPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"一次简单的Hook（上）","slug":"一次简单的Hook-上","date":"2020-03-10T01:36:42.000Z","updated":"2020-03-10T09:48:23.338Z","comments":true,"path":"2020/03/10/一次简单的Hook-上/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/10/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Hook-%E4%B8%8A/","excerpt":"","text":"这一次hook小实验的目标是hook出某社交软件中的实时聊天内容，主要目的是了解hook的原理以及在hook之前对程序的分析流程及其他准备工作，从而对于hook有个完整的认识。 准备工具 OllyDbg调试器：用于单步跟踪，动态调试等。 IDA pro调试器：用于静态分析函数代码结构等。 Mircosoft Visual Studio 201*(版本随意)：用于dll代码编写 DbgView：捕获并查看程序中由OutputDebugString输出的信息。 Hook的分类Hook无非只有两种类型，一种是通过修改数据（通常是引用的函数地址）进行的Hook，这如何理解，简单而言，很多大型程序，都需要通过调用各式各样的函数库来实现一些功能，而这种Hook就是通过修改程序调用的函数地址，改成自己写的函数，从而额外实现一些功能，实现对程序的Hook，例如IAT Hook；另一种是直接修改函数内的指令进行Hook，通过控制函数内的跳转，在函数执行时，实现一些自己的功能，然后再返回到函数使之正常运行，例如Inline Hook。这次Hook实验，采用的就是Inline Hook的手法实现。 基址与偏移在逆向分析中，通过基址和偏移定位一个函数，会非常方便，同时可以对IDA的代码进行基址重定位，从而达到和OD的同步分析。 如何确定基址呢，一个程序需要调用一个外部的库函数，或者加载dll来实现某些功能，当dll被加载进程序时，会根据默认基址0x10000000进行载入dll，但是一个程序往往会加载多个dll，此时dll会根据重定位表来对dll进行重定位，基址也会有所变化。由于dll中的导出函数，距离基址的偏移是固定的，所以只要确定需求函数与dll基址的偏移，就可以轻松定位到这个函数。如图，将程序被OD附加时，通过点击上方的E按钮，进入模块列表，左边第一栏的Base就是dll的基址，例如IM.dll在此次加载时的基址为0x62840000。 右键View name查看IM.dll的导出函数，可以发现此次加载时PostTask_Session这个函数的地址为0x628E6EF9，相减可得偏移为0xA6EF9，以后每次只需确定IM.dll的基址，就可以通过偏移直接确定PostTask_Session的地址，这在hook代码中很有用。 程序分析流程查找需要被Hook函数根据我们需要Hook的功能来看，要截取实时聊天的数据，需要对接收聊天内容的函数做手脚，猜想这个函数的函数名一定与Message有关，例如GetMessage，RecvMessage等。将程序附加进OD，点击E查看Tim加载的主要模块(dll)，找到一个KernelUtil.dll，为啥找这个dll呢？根据之前逆向，发现很多功能都是由这个dll实现的，从dll名也可以看出这是一个实现功能的dll。右键View name，查看dll的导出函数。 查看和Message有关的函数，最终会发现一个名为GetMsgAbstract的导出函数 为什么选这个函数呢？因为看名字猜测这是一个获取消息摘要的函数，也许和收发消息有一定的关联，因此可以拿出来进行试一试。 在函数的开头，下一个断点，然后在Tim内任何发送一条消息。发现程序断了下来，说明这个函数的确和消息有关。 寻找聊天内容尽管确定了，这个函数和聊天消息有关，但是只有真正找到了消息内容，这个函数才能够被利用，否则还得换另一个函数分析。首先按照F8单步执行(不步入函数，为了节省时间并快速定位)，每当一个函数(call语句)执行完后，都要观察堆栈和寄存器的变化，看看是否有重要内容。继续单步，直到发现一个函数GetMsgAbstractByElement，这个函数执行完后，会在堆栈[ebp-8]的位置出现刚刚发送的消息。 这时，我们可以进一步GetMsgAbstractByElement，来寻找发送的消息是如何出现的。 函数入口 右图开始分析，在调用GetMsgAbstactByElement之前，共push了5个参数进去，其中第一个push进去的参数0x548FA04，此时所指向的堆栈中的值为0，第三个push进去的0x548FA01，所指位置，截断了堆栈中部分数据，也无意义。第四个push进去的参数，值为0，同样也用不到。第五个push进去的参数，首先将[ebp-8]处的地址加载到eax，然后再push进去，根据前一次的步入，已知函数执行后，[ebp-8]的位置即是发送的消息，但该参数用于存放取完后的消息，并不是消息的源头。这样就只剩下第二个参数，右键ebx，Follow in dump，进入数据窗口，并没有发现消息内容的存在，因此可以猜测，这是一个包含了消息的结构体，至于如何结构结构体获取消息，还得步入GetMsgAbstactByElement函数作进一步分析。 GetMsgAbstactByElement函数按F7步入函数 可以发现，栈顶足足降低了0x70字节，所以push进来的参数暂时只能靠[ebp+偏移]来访问，关注点仍然放在第二个参数的值上，目前除了ebx仍然为此值，push进入堆栈，目前位于[ebp+0x14]的位置，值也相同，由于[ebp+0x14]是作为参数push进来的，所以ebx的值多半用不到了，接下来只需关注[ebp+0x14]的值。 同一张图，距离函数开始不远，就有一条赋值语句将[ebp+0x14]的值赋给edi，这时edi的值也会成为第二个参数的值，同样需要关注。接着继续单步分析。 单步执行到这里时发现，在一次函数调用前，将edi作为参数push了，此外又将[ebp-0x20]处的位置清零，需要留意关注，然后单步步过该函数观察变化。 该函数执行后发现，[ebp-0x20]处的位置多了个数，右键-Follow in dump，进入数据窗口发现，在0x18偏移的位置，正好是发送的消息。这下就可以确定，是此处的call dword ptr ds:[eax + 0x48]这条语句，将传入的参数结构体进行解构，找到了消息。 解构参数结构体的函数接下来重新运行程序，再发送一条新的消息并断下。单步到call dword ptr ds:[eax + 0x48]处，按F7单步进入该函数。 这个函数并不长，但是实现了很关键的功能 Code1mov ebx,dword ptr ss:[ebp+0x8] 这一步，将[ebp+8]的值给到ebx，而这个值恰好就是外部传进来的需要解构的结构体，接下来需要关注涉及到ebx的指令。 其中接下来一条，将[ebx+0x38]的地址赋给eax，但是eax接下来就被重新赋值了，所以只需向下关注，其中这里方框框住的两行，实际上做了个减法运算，之后eax的值再一次被重置。接下来的一步，ecx也被清零了。 Code1mov eax,dword ptr ds:[ebx+0x28] 这是非常关键的一步，为什么说它关键呢，因为这时候已经脱离了ebx，说明ebx已经将结构体内部的信息传递给了eax上了，接着继续看eax，同时跟进[ebx+0x28]数据窗口查看。 Code1mov eax,dword ptr ds:[eax+ecx*4] => mov eax,dword ptr ds:[eax] 由于ecx的值为0，便可做一个优化。此时再去跟进[eax]数据窗口查看。 发现，刚好有一条发送出去但是还未接收到的消息。至此大功告成，已经确定GetMsgAbstractElement函数的解构过程： 首先将外部传入的第二个参数，赋值给edi寄存器暂存 接着将edi寄存器内的值作为参数，传入到一个解析结构体的函数内 进入函数，先将原先edi寄存器保存的参数，赋值给ebx寄存器 然后将ebx+0x28所在地址的值赋值给eax寄存器 最后eax寄存器将保存的值作为地址，进入后发现，在0x18处偏移，刚好就是保存的消息。 结论验证通过上述分析可以发现，在执行GetMsgAbstractElement，就可以通过其第二个push进去的参数，获取到消息内容了。这时，我们再次运行重新，发送消息，并重新断下。通过之前推论得出的偏移来计算： Code1[[ebx+0x28]]+18 该命令可以达到一个地址，而这个地址就应该存着消息。 验证成功。尽管我们是从GetMsgAbstract进来开始分析的，但是在分析的过程中发现GetMsgAbstractElement在执行前，就可以拿到消息内容，而GetMsgAbstract，执行的过程中总会执行GetMsgAbstractElement，因此可以在GetMsgAbstractElement函数执行前做手脚，注入我们的代码实现对消息内容的Hook。至于Hook代码的编写，限于篇幅，将在下一个部分呈现","categories":[],"tags":[{"name":"Windows逆向","slug":"Windows逆向","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E9%80%86%E5%90%91/"}]},{"title":"段描述符属性","slug":"段描述符属性","date":"2020-03-09T09:19:09.000Z","updated":"2020-03-13T13:22:38.361Z","comments":true,"path":"2020/03/09/段描述符属性/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/09/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%9E%E6%80%A7/","excerpt":"","text":"之前介绍了，段描述符是用来填充段寄存器余下位置的，然而段寄存器余下位置有80位，而段描述符仅有64位，那到底是如何填充的呢？这篇就从这个问题开始，逐步探究段描述符的属性。首先，回顾一下段描述符的结构： P位P位，位于段描述符高4字节的第15位，是判断描述符是否有效的位置。 P = 1: 该描述符有效 P = 0：该描述符无效 G位在解析G位前，先来回顾下之前的问题，64位的段描述符到底是如何分配给段寄存器余下80位的。 首先回顾一下段寄存器的结构： c123456struct SegMent { WORD selector; WORD attribute; DWORD base; DWORD limit;} 段选择子： 由mov/les/lds/lss/lfs/lgs指令直接写入16位。 属性：段描述符中高4字节的第8-23位，刚好16位，作为属性写入段寄存器。 基址：将段描述符高4字节中第24-31位，与第0-7位拼接成作为高16位，低四字节的第16-31位作为低16位，拼接成32位，作为Base，写入到段寄存器里。 (这里没用~号是因为会转义成删除线) 限长：这里就要用到G位了。首先观察段描述符结构，可以发现，在高4字节的第16-19位，与低4字节的第0-15位，都是段限长，将他们拼接起来，也就是20位，那这20位是如何扩展成32位呢？这里就要用到这部分的关键G位了，当G的值为0时，表示以字节为单位，这时，假设Limit的值加起来为FFFFF(20位)，则取0x000FFFFF作为Limit写入段寄存器；当G的值为1时，表示以4KB为单位，这样去理解，如果一个段的大小为1KB，也就是1024B或0x400B，这时，实际上能取的范围是0-1023或0-0x3FF，所以此时的Limit应该为3FF。这样当以单位为4KB来计算一个段的Limit时，若Limit的值为1，说明可以取0和1两个值，也真正的大小实际上是2，所以用2*4KB=8192B=0x2000B，但是真是可以取到的值为0-1FFF，所以此时写入段寄存器Limit的值为1FFF。同理，若段描述符Limit的值为FFFFF，真正写入段寄存器的值为FFFFFFFF(32位)。 具体的公式如下： Code12345G = 0: = LimitG = 1: (Limit + 1)*4KB - 1 = Limit*4KB + 4KB - 1 = (Limit","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"段描述符与段选择子","slug":"段描述符与段选择子","date":"2020-03-08T11:31:33.000Z","updated":"2020-03-13T13:22:59.224Z","comments":true,"path":"2020/03/08/段描述符与段选择子/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/08/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90/","excerpt":"","text":"在探究段寄存器属性时，注意到，段寄存器在读的时候，只读了16位，但是写的时候会写入96位。那么，段寄存器是如何做到写入96位的呢？今天就要研究两个新的概念：段描述符与段选择子 基础知识Windbg指令Windbg是在调试Windows系统内核时常用的一个调试器，之后也会多次用到；通过Windbg可以实现主机对虚拟机上的Windows系统进行双击调试。搭建双击调试环境可以参考此贴：https://blog.csdn.net/q1007729991/article/details/52710390 这里，简单介绍一下，在研究段描述符和段选择子所需用到的几个Windbg指令： 命令 含义 r 查看和修改寄存器 dd 以4字节分隔，显示指定内存区域的数据内容 dq 以8字节分隔，显示指定内存区域的数据内容 第二个d和q分别是dword和qword的意思，第一个d是一个查看内存的指令，以后会详细说明。 汇编基础这里补充一点汇编基础，如何在确保，给一个拥有6个元素的char型数组赋值时，确保元素所在高位或者低位呢？ 通过观察反汇编可以看出，0x78处在 [ebp-8]的位置上，距离ebp相对较远；0x12处在[ebp-5]的位置上，距离ebp相对较近，两者差了4个字节，我们可以假象在地址空间中的位置如下表： 地址 值 0x12ff40(随便取个值) 0x78 0x12ff41 0x56 0x12ff42 0x34 0x12ff43 0x12 0x12ff44 0x23 0x12ff45 0x00 而Windows操作系统是小端模式，也就是高字节保存在高地址中；例如0x12在0x12345678这个数里属于高字节，0x12所在的地址位0x12ff43相当于0x78位于高地址，所以在赋值时，需要把0x12放到高地址中，根据小端模式在内存中的排列可知，若想确定一个实际值为0x12345678的数，在内存的排列大概是”78563412“这种形势，因此在赋值时按照如下方式： 这里还有一个坑是，赋值时不要加’ ‘，因为一个字节的数不止一个字符，不能放到单引号里。 GDT，LDTGDT和LDT分别指全局描述符表和局部描述符表。由于Windows系统没有使用LDT表，所以可以忽略这个表。而GDT表，表里存储的就是段描述符。 了解GDT表，需要先知道这个表有多大，存在哪里。这时需要借助一个寄存器gdtr，这是个48位的寄存器，其中32位存的是GDT表的位置，16位存的是GDT表的大小；可以通过以下指令进行查询。 由图可知，当前虚拟机中的操作系统，gdt表位于0x8003f000的位置，大小是0x03ff，也就是说从0x8003f000~0x8003f3ff这段内存中，存放着gdt表。 段描述符当执行以下语句时： Code1mov ds, ax CPU会去查表，根据ax的值决定查看GDT表还是LDT表，以及查找表的什么位置，查出哪些数据 首先查看一下GDT表，由于段描述符大小是8字节/64位，所以采用dq指令进行查看。 这里查看了GDT表0x80个字节大小的内存，一个段描述符的大小是8字节，所以显示了16个段描述符。 接下来看一下段描述符表的结构 可以发现，在段描述符中，有着Base，Limit，还有各种Attribute，这些就是从段描述符中查找的数据，并写入段寄存器剩下的80位里。那么有了GDT表和段描述符，那么究竟该选择哪一个段描述符的数据写入段寄存器呢？这就涉及到另一个结构：段选择子 段选择子“段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符”。 这句话怎么理解，怎么又是16位的段描述符，又是GDT表的段描述符？首先，段的Base，Limit以及Attribute都是由GDT表的段描述符来决定的，那么到底是由哪个段描述符来决定的？为了确定这个段描述符，引入了段选择子这个结构，段选择子，指向了GDT表中某一个段描述符，这样就可以把该段描述符的数据写入到段寄存器内了。所以说，段选择子，是一个段描述符的描述符。下面是段选择子的结构。 由图，结构非常简单，各个位的含义也比较好理解。这里有个小g巧，段选择子一共16位，由于Windows没有使用LDT表，所以TI位永远是0。请求特权级别一般也只有0和3，所以段选择子最后4位的值只有4种组合：0000, 0011, 1000, 1011 加载段描述符至段寄存器除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器。 CS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，以后的文章会说到。 Code1les ecx,fword ptr ds:[buffer] //取buffer高2个字节给es，低4个字节给ecx 这里的buffer是一个地址，存了6个字节的数，例如定义buffer为一个6个元素的char型数组。这里的fword指的是三字，也就是6个字节 注意：在数值上需要要求RPL","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"浅谈对称加密传输","slug":"浅谈对称加密传输","date":"2020-03-07T09:19:26.000Z","updated":"2020-03-09T13:59:14.424Z","comments":true,"path":"2020/03/07/浅谈对称加密传输/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/07/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/","excerpt":"","text":"看到crownless一篇关于Tor原理解析的文章，涉及到了加密传输的部分，以前没仔细理解，现在用通俗的语言记录下来。 基础概要对称加密所谓对称加密，就是通信双方，在发送和接收数据时，使用同一个密钥key对数据进行加密与解密。发送方和接收方必须在数据传送前商定好秘钥。 优点：加密速度快、效率高。 缺点：一旦密钥泄露，加密信息不再安全 25519曲线Curve25519椭圆曲线，是基于蒙哥马利曲线的密钥协商算法，具体如下 蒙哥马利曲线算法，可以做到”Time-constant”，也就是说不论他们进行运算的数值是多少，他们所花的时间是相同的，可以规避“ 时间旁路 ”攻击。（crownless文中有提到这是一种很神奇的可以在不安全的信道上建立共享的对称密钥的方法） 传输过程密钥获取Bob为了访问Alice，先访问Tor的目录服务器，获取一部分Tor节点的IP地址，并从中随机选择三个节点的IP地址A、B、C。然后，Bob会先和A节点通过Curve25519椭圆曲线算法以及协商所需的参数，协商一个对称密钥keyA；这时A节点会将Bob协商密钥所需参数发送给Bob。Bob通过算法计算出对称密钥keyA。之后，Bob和节点A之间就会用这把对称密钥keyA进行加密通信。 然后，Bob把B的IP地址和与B协商密钥所需的参数用对称密钥keyA加密后发送给A。A用keyA解密后，将Bob与B协商密钥所需的参数发送到B的IP地址。B收到参数后产生了对称密钥keyB，并将与Bob协商密钥所需的参数发还给A。A将参数通过keyA加密后发还给Bob。Bob用keyA解密后通过算法计算出对称密钥keyB。Bob通过相同的方法和C协商出keyC。至此，Bob有了三把钥匙keyA、keyB、keyC。 需要注意的是，当把协商密钥所需的参数，发给相应的节点时，若一方还没收到协商的参数并生成密钥，另一方就不会对协商参数进行加密。在B收到参数生成密钥keyB后，将与Bob协商密钥所需的参数发还给A，此时不会对协商参数用keyB进行加密，以保证另一方可以拿到参数生成密钥。但已经进行加密通信的双方，则会使用密钥加密通信数据。 加密传输Bob往Alice发送数据包时，先将数据Data用keyC加密，再用keyB加密，再用keyA加密，就好像层层包裹一样，然后发往节点A。节点A解开一层加密，发往节点B。节点B解开一层加密，发往节点C。节点C解开一层加密，得到Bob发往Alice的明文，发送给Alice。 参考文章： https://bbs.pediy.com/thread-248850.htm https://www.jianshu.com/p/5dba044f67b1","categories":[],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"http://cataloc.gitee.io/blog/tags/NetWork/"}]},{"title":"探究段寄存器","slug":"探究段寄存器","date":"2020-03-06T15:00:07.000Z","updated":"2020-03-08T10:35:10.662Z","comments":true,"path":"2020/03/06/探究段寄存器/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/06/%E6%8E%A2%E7%A9%B6%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"被忽视的ds1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域","text":"被忽视的dsCode1mov dword ptr ds:[0x003f048], eax 在进行ring3逆向时，海哥让我们不去管ds寄存器的作用，只需要理解，这条语句的作用是将eax的值，写入0x003f048这个地址处即可；但是到了保护模式，这种说法就不再准确了，接下来一步步探寻ds的本质 段寄存器ds 是 CPU 中的一个寄存器，这种寄存器称为段寄存器，除了ds，还有cs、es、ss、fs、gs 、ldtr、tr共八个。 打开OllyDbg，任意附加一个.exe文件，可以在右侧窗口看到如下一块区域 这些是OllyDbg调试器显示出当前程序运行时段寄存器的各部分属性的值。接下来分析这些值的来源和含义。 段寄存器的读写在后面的部分会经常用到段寄存器的读写，这里先说明一下： 读： Code1mov ax, fs 写： Code1mov ds, ax 段寄存器在读的时候，只读了16位，但是写的时候会写入96位。 注意：ldtr和tr段寄存器不能用mov指令进行读写 段寄存器结构Code123456struct SegmentReg { WORD selector; WORD attribute; DWORD base; DWORD limit;} 由段寄存器的结构可知，段寄存器共96位，由16位的段选择子，16位的段属性，32位的base和32位的limit组成。 打印ds寄存器的值，发现只能显示0x0023，也就是段选择子那16位。不是说好的共96位吗？实际上，剩下来80位是不可见的部分，只不过OD也展示出来了，接下来证明每个属性的存在。 段基址Code1mov eax, dword ptr ds:[0] 理论上，上面这条语句是无法执行成功的，因为零地址是不允许访问的（因为没有给零地址挂物理页） 但是上述程序可以成功执行（这里不使用ds，原因是vc6作者对ds做过优化，写成ds将编译不过去），说明了这里访问的不是零地址，而是其它地址，也就是说，段寄存器修改了写入数据的地址，证明了段基址的存在。 这里真正的将数据写入eax的地址是： Code1gs.base + 0x0 以下是常见段的基址 段寄存器 Base ES 0 CS 0 SS 0 DS 0 FS 0x7FFDE000 GS - 由于将fs段的值赋给了gs段，因此写入eax寄存器的是0x7FFDE000地址上的值。 段属性 上面两段程序的差别仅仅在于插入的汇编的第一条指令，mov ax, cs 和 mov ax, ss。造成结果不同的原因是，ss段寄存器是可读、可写的，而cs段寄存器是可读、可执行，但是不可写；因此在试图向cs段寄存器所指向的基址+偏移（既[ ]内的值）是会发生访问违例的，这也说明了，不同的段寄存器，属性是不同的，证明了段属性的存在。 段限长 又出现了访问违例的情况，此处var的值为0x1000，超过了fs段寄存器的Limit：0xFFF，所以此时已经不能通过fs段来访问fs.base+0x1000这个地址了，这说明段寄存器也有一定的管辖范围，超出这个范围，就没有权限访问了 总结这次的笔记主要探究了段寄存器的属性和结构，大致整理如下 段寄存器 段选择子 属性 基址 限长 ES 0x0023 RW 0 0xFFFFFFFF CS 0x001B RX 0 0xFFFFFFFF SS 0x0023 RW 0 0xFFFFFFFF DS 0x0023 RW 0 0xFFFFFFFF FS 0x003B RW 0x7FFDE000 0xFFF GS - - - - 参考文章：https://blog.csdn.net/q1007729991/article/details/52537943 参考教程：https://www.bilibili.com/video/av68700135?p=7","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]},{"title":"初见保护模式","slug":"初见保护模式","date":"2020-03-05T09:19:09.000Z","updated":"2020-03-09T13:58:29.632Z","comments":true,"path":"2020/03/05/初见保护模式/","link":"","permalink":"http://cataloc.gitee.io/blog/2020/03/05/%E5%88%9D%E8%A7%81%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","excerpt":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。","text":"保护模式从80386开始，CPU有三种工作方式：实模式，保护模式和虚拟8086模式。在计算机刚启动时CPU处于实模式，然后通过切换机制再进入保护模式，所以现在的操作系统，都是运行在保护模式上。 为何要引入保护模式？在80286以前，CPU只有实模式，在这个模式下，所有的段都是可读，可写，可执行的；此时，系统程序和用户程序可以相互访问彼此的地址，用户稍有不慎就可能修改到系统程序段，影响系统程序的正常运行，导致系统崩溃。 保护模式的引入提供了段间的保护机制，防止程序间胡乱访问地址带来的问题，同时也扩大了访问的内存空间（没整明白8086实模式的寻址方式，看结果，保护模式的确扩大了寻址空间）。 段、页机制段，页机制均是CPU所提供的，操作系统利用CPU提供的段，页机制，实现对虚拟地址空间的管理，使得操作系统在保护模式上有序，”安全”的工作。","categories":[],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"http://cataloc.gitee.io/blog/tags/Windows%E5%86%85%E6%A0%B8/"}]}]}